using System;
using System.Xml;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Resources;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using System.Data;
using System.Data.SqlClient;
using System.Reflection;
using System.Linq;
using Microsoft.RuleEngine;
using Microsoft.BizTalk.Tracing;

namespace Microsoft.Solutions.FinancialServices.SWIFT
{
    /// <summary>
    /// Class that adds policies to a StringCollection and returns the
    /// StringCollection through a getter property.
    /// </summary>
    public class BicSqlConnector
    {
        private static string fieldSecurity = string.Empty;
        private static string fieldDatabase = string.Empty;
        private static string fieldDatabaseServer = string.Empty;
        private static string fieldTableName;
        private static bool fieldIsPersistSecurity = false;
        private static int fieldConnectionTimeOut = 30;
        private static string fieldColumnName;

        public static string connectionString
        {
            get
            {
                StringBuilder sb = new StringBuilder(50);
                sb.Append("Persist Security Info=");
                sb.Append(isPersistSecurity.ToString(CultureInfo.InvariantCulture)); //fx-cop correction
                sb.Append(";");

                sb.Append("Integrated Security=");
                sb.Append(security);
                sb.Append(";");

                sb.Append("database=");
                sb.Append(database);
                sb.Append(";");

                sb.Append("server=");
                sb.Append(databaseServer);
                sb.Append(";");

                sb.Append("Connect Timeout=");
                sb.Append(connectionTimeOut.ToString(CultureInfo.InvariantCulture));
                sb.Append(";");

                // Pooling connection strings
                sb.Append("Pooling=true;Connection Lifetime=0;Min Pool Size=0;Max Pool Size=10;");

                return sb.ToString();
            }
        }

        public static bool isPersistSecurity
        {
            get
            {
                return fieldIsPersistSecurity;
            }
            set
            {
                fieldIsPersistSecurity = value;
            }
        }

        public static int connectionTimeOut
        {
            get
            {
                return fieldConnectionTimeOut;
            }
            set
            {
                fieldConnectionTimeOut = value;
            }
        }

        public static string security
        {
            get
            {
                return fieldSecurity;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("security");
                }
                if (value.Trim().Length == 0 ||
                    (value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "yes" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "no" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "true" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "false" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "sspi"))
                {
                    throw new ArgumentException("security");
                }
                fieldSecurity = value;
            }
        }

        public static string database
        {
            get
            {
                return fieldDatabase;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("database");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("database");
                }
                fieldDatabase = value;
            }
        }

        public static string databaseServer
        {
            get
            {
                return fieldDatabaseServer;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("databaseServer");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("databaseServer");
                }
                fieldDatabaseServer = value;
            }
        }

        public static string tableName
        {
            get
            {
                return fieldTableName;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("tableName");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("tableName");
                }
                fieldTableName = value;
            }
        }

        public static string columnName
        {
            get
            {
                return fieldColumnName;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("columnName");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("columnName");
                }
                fieldColumnName = value;
            }
        }
    }

    /// <summary>
    /// Class that adds policies to a StringCollection and returns the
    /// StringCollection through a getter property.
    /// </summary>
    public sealed class PolicyList
    {
        private readonly StringCollection policyCollection;
        private bool isHeaderRequired;
        private string security = string.Empty;
        private string database = string.Empty;
        private string databaseServer = string.Empty;
        private string tableName;
        private string columnName;
        private bool isPersistSecurity;
        private int connectionTimeOut;

        public PolicyList()
        {
            policyCollection = new StringCollection();
            isHeaderRequired = false;
            isPersistSecurity = false;
            connectionTimeOut = 30;
        }

        /// <summary>
        /// Property that returns a StringCollection of policies.
        /// </summary>
        public StringCollection PolicyCollection
        {
            get
            {
                return this.policyCollection;
            }
        }

        /// <summary>
        /// Property to specify header document requirement.
        /// </summary>
        public bool IsHeaderRequired
        {
            set
            {
                isHeaderRequired = value;
            }

            get
            {
                return this.isHeaderRequired;
            }
        }

        /// <summary>
        /// Property to specify the Integrated Security connection string
        /// </summary>
        public string Security
        {
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("Security");
                }
                if (value.Trim().Length == 0 ||
                    (value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "yes" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "no" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "true" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "false" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "sspi"))
                {
                    throw new ArgumentException("Security");
                }
                security = value;
                BicSqlConnector.security = value;
            }
            get
            {
                return security;
            }
        }
        public string Security_CtryCcy
        {
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("Security");
                }
                if (value.Trim().Length == 0 ||
                    (value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "yes" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "no" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "true" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "false" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "sspi"))
                {
                    throw new ArgumentException("Security");
                }
                security = value;
                SqlConnector.Security = value;
            }
            get
            {
                return security;
            }
        }


        /// <summary>
        /// Property to specify the database name in the connection string
        /// </summary>
        public string Database
        {
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("Database");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("Database");
                }
                database = value;
                BicSqlConnector.database = value;
            }
            get
            {
                return database;
            }
        }

        /// <summary>
        /// Property to specify the server name in the connection string
        /// </summary>
        public string DatabaseServer
        {
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("DatabaseServer");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("DatabaseServer");
                }
                databaseServer = value;
                BicSqlConnector.databaseServer = value;
            }
            get
            {
                return databaseServer;
            }
        }
        /// <summary>
        /// Property to specify the database name in the connection string
        /// </summary>
        public string Database_CtryCcy
        {
            set
            {

                if (value == null)
                //Fixing presharp errors
                //				if (string.IsNullOrEmpty(value))
                {
                    throw new ArgumentNullException("Database");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("Database");
                }
                database = value;
                SqlConnector.Database = value;
            }
            get
            {
                return database;
            }
        }

        /// <summary>
        /// Property to specify the server name in the connection string
        /// </summary>
        public string DatabaseServer_CtryCcy
        {
            set
            {
                if (value == null)
                //Fixing presharp errors
                //if (string.IsNullOrEmpty(value))
                {
                    throw new ArgumentNullException("DatabaseServer");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("DatabaseServer");
                }
                databaseServer = value;
                SqlConnector.DatabaseServer = value;
            }
            get
            {
                return databaseServer;
            }
        }

        /// <summary>
        /// Property to specify the server name in the connection string
        /// </summary>
        public string TableName
        {
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("TableName");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("TableName");
                }
                tableName = value;
                BicSqlConnector.tableName = value;
            }
            get
            {
                return tableName;
            }
        }

        /// <summary>
        /// Property to specify the server name in the connection string
        /// </summary>
        public string ColumnName
        {
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("ColumnName");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("ColumnName");
                }
                columnName = value;
                BicSqlConnector.columnName = value;
            }
            get
            {
                return columnName;
            }
        }

        /// <summary>
        /// Property to specify the Persist Security Info in the connection string
        /// </summary>
        public bool IsPersistSecurity
        {
            set
            {
                isPersistSecurity = value;
                BicSqlConnector.isPersistSecurity = value;
            }
            get
            {
                return isPersistSecurity;
            }
        }

        /// <summary>
        /// Property to specify the Connect Timeout in the connection string
        /// </summary>
        public int ConnectionTimeOut
        {
            set
            {
                connectionTimeOut = value;
                BicSqlConnector.connectionTimeOut = value;
            }
            get
            {
                return connectionTimeOut;
            }
        }

        /// <summary>
        /// Function that adds a policy name to a StringCollection.
        /// </summary>
        /// <param name="policyString">Policy name passed in as a string</param>
        /// <returns>Boolean indicating addition status</returns>
        public bool AddPolicyName(string policyString)
        {
            if (null != policyString && policyString.Length != 0)
            {
                this.policyCollection.Add(policyString);
                return true;
            }

            else
            {
                return false;
            }
        }
    }

    public class SqlConnector
    {
        private static string fieldSecurity = string.Empty;
        private static string fieldDatabase = string.Empty;
        private static string fieldDatabaseServer = string.Empty;
        private static string fieldTableName;
        private static bool fieldIsPersistSecurity = false;
        private static int fieldConnectionTimeOut = 30;
        private static string fieldColumnName;
        public static Hashtable hashCountryCodeList = new Hashtable();
        public static Hashtable hashCurrencyCodeList = new Hashtable();
        public static Hashtable hashLegacyCurrencyCodeList = new Hashtable();
        private static object mSyncLock = new object();

        /// <summary>
        ///    Property to get connection string to the database.
        /// </summary>
        public static string ConnectionString
        {
            get
            {
                StringBuilder sb = new StringBuilder(50);
                sb.Append("Persist Security Info=");
                sb.Append(IsPersistSecurity.ToString(CultureInfo.InvariantCulture)); //fx-cop correction
                sb.Append(";");

                sb.Append("Integrated Security=");
                sb.Append(Security);
                sb.Append(";");

                sb.Append("database=");
                sb.Append(Database);
                sb.Append(";");

                sb.Append("server=");
                sb.Append(DatabaseServer);
                sb.Append(";");

                sb.Append("Connect Timeout=");
                sb.Append(ConnectionTimeOut.ToString(CultureInfo.InvariantCulture));
                sb.Append(";");

                // Pooling connection strings
                sb.Append("Pooling=true;Connection Lifetime=0;Min Pool Size=0;Max Pool Size=10;");

                return sb.ToString();
            }
        }


        /// <summary>
        ///    Property to get or set the field security flag.
        /// </summary>
        public static bool IsPersistSecurity
        {
            get
            {
                return fieldIsPersistSecurity;
            }
            set
            {
                fieldIsPersistSecurity = value;
            }
        }

        /// <summary>
        /// Property to get or set the connection timeout.
        /// </summary>
        public static int ConnectionTimeOut
        {
            get
            {
                return fieldConnectionTimeOut;
            }
            set
            {
                fieldConnectionTimeOut = value;
            }
        }


        /// <summary>
        /// Property to get or set the security.
        /// </summary>
        public static string Security
        {
            get
            {
                return fieldSecurity;
            }
            set
            {

                if (value == null)
                //Fixing presharp errors
                //if (string.IsNullOrEmpty(value))
                {
                    throw new ArgumentNullException("security");
                }
                if (value.Trim().Length == 0 ||
                    (value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "yes" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "no" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "true" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "false" &&
                    value.ToLower(System.Globalization.CultureInfo.InvariantCulture) != "sspi"))
                {
                    throw new ArgumentException("security");
                }
                fieldSecurity = value;
            }
        }

        /// <summary>
        /// Property to get or set the databse name.
        /// </summary>
        public static string Database
        {
            get
            {
                return fieldDatabase;
            }
            set
            {
                if (value == null)
                //Fixing presharp errors
                //if (string.IsNullOrEmpty(value))
                {
                    throw new ArgumentNullException("database");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("database");
                }
                fieldDatabase = value;
            }
        }

        /// <summary>
        /// Property to get or set the database server name.
        /// </summary>
        public static string DatabaseServer
        {
            get
            {
                return fieldDatabaseServer;
            }
            set
            {
                if (value == null)
                //Fixing presharp errors
                //if (string.IsNullOrEmpty(value))
                {
                    throw new ArgumentNullException("databaseServer");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("databaseServer");
                }
                fieldDatabaseServer = value;
            }
        }

        /// <summary>
        /// Property to get or set the table name.
        /// </summary>
        public static string TableName
        {
            get
            {
                return fieldTableName;
            }
            set
            {
                if (value == null)
                //Fixing presharp errors
                //if (string.IsNullOrEmpty(value))
                {
                    throw new ArgumentNullException("tableName");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("tableName");
                }
                fieldTableName = value;
            }
        }

        /// <summary>
        /// Property to get or set the coloumn name.
        /// </summary>
        public static string ColumnName
        {
            get
            {
                return fieldColumnName;
            }
            set
            {
                if (value == null)
                //Fixing presharp errors
                //if (string.IsNullOrEmpty(value))
                {
                    throw new ArgumentNullException("columnName");
                }
                if (value.Trim().Length == 0)
                {
                    throw new ArgumentException("columnName");
                }
                fieldColumnName = value;
            }
        }

        /// <summary>
        /// Method to pouplate Hashtables for country and currency codes.
        /// </summary>
        public void PopulateHashTables()
        {
            //fix for 3168
            if (hashCountryCodeList.Count <= 0 && hashCurrencyCodeList.Count <= 0 && hashLegacyCurrencyCodeList.Count <= 0)
            {
                lock (mSyncLock)
                {
                    if (hashCountryCodeList.Count <= 0 && hashCurrencyCodeList.Count <= 0 && hashLegacyCurrencyCodeList.Count <= 0)
                    {
                        StringBuilder[] query = new StringBuilder[3];
                        query[0] = new StringBuilder();
                        query[1] = new StringBuilder();
                        query[2] = new StringBuilder();

                        hashCountryCodeList.Clear();
                        hashCurrencyCodeList.Clear();
                        hashLegacyCurrencyCodeList.Clear();


                        //create parameterized query for populating country codes
                        query[0].Append("USE ");
                        query[0].Append(SqlConnector.Database);
                        query[0].Append(";");
                        query[0].Append("SELECT ");
                        query[0].Append("CountryCode");
                        query[0].Append(" FROM ");
                        query[0].Append("CountryCode_List");

                        //create parameterized query for pouplatuing currency codes
                        query[1].Append("USE ");
                        query[1].Append(SqlConnector.Database);
                        query[1].Append(";");
                        query[1].Append("SELECT ");
                        query[1].Append("CurrencyCode, CurrencyAmtPrecission");
                        query[1].Append(" FROM ");
                        query[1].Append("CurrencyCode_List");

                        //create parameterized query for pouplatuing Legacy currency codes
                        query[2].Append("USE ");
                        query[2].Append(SqlConnector.Database);
                        query[2].Append(";");
                        query[2].Append("SELECT ");
                        query[2].Append("CurrencyCode, ValidDate");
                        query[2].Append(" FROM ");
                        query[2].Append("LegacyCurrencyCode_List");

                        SqlDataReader sqlDataReader = null;
                        SqlCommand sqlCommand = null;
                        SqlConnection sqlConnection = null;

                        try
                        {
                            using (sqlConnection = new SqlConnection(SqlConnector.ConnectionString))
                            {
                                sqlConnection.Open();
                                for (int loop = 0; loop < 3; loop++)
                                {
                                    try
                                    {
                                        sqlCommand = new SqlCommand(query[loop].ToString(), sqlConnection);
                                        sqlDataReader = sqlCommand.ExecuteReader();
                                        int objectKey = 0;
                                        while (sqlDataReader.Read())
                                        {
                                            if (loop == 0) //populating country code hashtable
                                            {
                                                hashCountryCodeList.Add(objectKey, sqlDataReader["CountryCode"].ToString());
                                                objectKey++;
                                            }
                                            else if (loop == 1) //populating currenct code hashtable
                                            {
                                                hashCurrencyCodeList.Add(sqlDataReader["CurrencyCode"].ToString(), sqlDataReader["CurrencyAmtPrecission"].ToString());
                                            }
                                            else if (loop == 2) //populating currenct code hashtable
                                            {
                                                hashLegacyCurrencyCodeList.Add(sqlDataReader["CurrencyCode"].ToString(), sqlDataReader["ValidDate"].ToString());
                                            }
                                        }
                                    }
                                    catch
                                    {
                                        throw;
                                    }
                                    finally
                                    {
                                        if (sqlDataReader != null)
                                        {
                                            sqlDataReader.Close();
                                            //sqlDataReader.Dispose();
                                        }

                                        if (sqlCommand != null)
                                        {
                                            sqlCommand.Dispose();
                                        }
                                    }
                                }
                            }
                        }
                        catch
                        {
                            throw;
                        }
                        finally
                        {

                        }
                    }
                }
            }
        }
    }
    public class BicValidatorClass
    {
        private string bicsNotFound = string.Empty;

        public string BicsNotFound
        {
            set
            {
                bicsNotFound = value;
            }
            get
            {
                return bicsNotFound;
            }
        }


        private string ValidateBICS(StringCollection bicCollection)
        {
            bool bExceptionthrown = false;

            StringBuilder query = new StringBuilder();
            StringBuilder sBicsNotPresent = new StringBuilder();
            StringCollection bicsPresentInDb = new StringCollection();

            //create parameterized query
            query.Append("USE ");
            query.Append(BicSqlConnector.database);
            query.Append(";");

            query.Append("SELECT ");
            query.Append(BicSqlConnector.columnName);
            query.Append(" FROM ");
            query.Append(BicSqlConnector.tableName);
            query.Append(" WHERE BIC=@bic0");
            for (int i = 1; i < bicCollection.Count; i++)
            {
                query.Append(" OR BIC=@bic");
                query.Append(i.ToString(CultureInfo.InvariantCulture));
            }

            SqlDataReader sqlDataReader = null;
            SqlCommand sqlCommand = null;
            SqlConnection sqlConnection = null;

            try
            {
                if (BicSqlConnector.columnName == null)
                {
                    throw new ArgumentNullException("BicSqlConnector.columnName");
                }
                if (BicSqlConnector.columnName.Length == 0)
                {
                    throw new ArgumentException("BicSqlConnector.columnName");
                }
                if (BicSqlConnector.tableName == null)
                {
                    throw new ArgumentNullException("BicSqlConnector.tableName");
                }
                if (BicSqlConnector.tableName.Length == 0)
                {
                    throw new ArgumentException("BicSqlConnector.tableName");
                }

                string paramName;
                int i = 0;
                // Check that the database name and the database server name are given at the least
                sqlConnection = new SqlConnection(BicSqlConnector.connectionString);
                sqlCommand = new SqlCommand(query.ToString(), sqlConnection);
                foreach (string bic in bicCollection)
                {
                    paramName = "@bic" + i.ToString(CultureInfo.InvariantCulture);
                    sqlCommand.Parameters.Add(new SqlParameter(paramName, SqlDbType.NVarChar, 11));
                    sqlCommand.Parameters[paramName].Value = bic;
                    i++;
                }
                sqlConnection.Open();
                sqlDataReader = sqlCommand.ExecuteReader();
                while (sqlDataReader.Read())
                {
                    bicsPresentInDb.Add(
                        sqlDataReader[BicSqlConnector.columnName].ToString());
                }
            }
            catch
            {
                bExceptionthrown = true;
                throw;
            }
            finally
            {
                if (null != bicsPresentInDb && bicsPresentInDb.Count > 0)
                {
                    foreach (string s in bicCollection)
                    {
                        if (bicsPresentInDb.Contains(s))
                        {
                            continue;
                        }
                        else
                        {
                            sBicsNotPresent.Append(s);
                            sBicsNotPresent.Append(", ");
                        }
                    }
                }
                else if (!bExceptionthrown)
                {
                    foreach (string s in bicCollection)
                    {
                        sBicsNotPresent.Append(s);
                        sBicsNotPresent.Append(", ");
                    }
                }

                if (sBicsNotPresent.Length > 0)
                {
                    sBicsNotPresent.Length -= 2;
                }

                if (sqlDataReader != null)
                {
                    sqlDataReader.Close();
                }

                if (sqlCommand != null)
                {
                    sqlCommand.Dispose();
                }

                if (sqlConnection != null)
                {
                    sqlConnection.Close();
                }
            }

            return sBicsNotPresent.ToString();
        }

        private string ValidateBICS(StringCollection bicCollection8, StringCollection bicCollection11)
        {
            bool bExceptionthrown = false;

            StringBuilder sBicsNotPresent = new StringBuilder();
            StringCollection bicsPresentInDb = new StringCollection();

            //create parameterized query
            StringBuilder query = new StringBuilder();
            query.Append("USE ");
            query.Append(BicSqlConnector.database);
            query.Append(";");

            int i = 0;
            if (bicCollection8.Count > 0)
            {
                query.Append(GetBicQuery(bicCollection8, "Bic8", i));
                query.Append(";");
            }
            if (bicCollection11.Count > 0)
            {
                query.Append(GetBicQuery(bicCollection11, "Bic11", i + bicCollection8.Count));
                query.Append(";");
            }

            SqlDataReader sqlDataReader = null;
            SqlCommand sqlCommand = null;
            SqlConnection sqlConnection = null;

            try
            {
                i = 0;
                // Check that the database name and the database server name are given at the least
                sqlConnection = new SqlConnection(BicSqlConnector.connectionString);
                sqlCommand = new SqlCommand(query.ToString(), sqlConnection);
                GetBicParamaters(sqlCommand, bicCollection8, i, 8);
                GetBicParamaters(sqlCommand, bicCollection11, i + bicCollection8.Count, 11);

                sqlConnection.Open();
                sqlDataReader = sqlCommand.ExecuteReader();
                while (sqlDataReader.Read())
                {
                    bicsPresentInDb.Add(
                        sqlDataReader["BIC"].ToString());
                }
                while (sqlDataReader.NextResult())
                {
                    while (sqlDataReader.Read())
                    {
                        bicsPresentInDb.Add(
                            sqlDataReader["BIC"].ToString());
                    }
                }
            }
            catch
            {
                bExceptionthrown = true;
                throw;
            }
            finally
            {
                if (null != bicsPresentInDb && bicsPresentInDb.Count > 0)
                {
                    foreach (string bic in bicCollection8)
                    {
                        if (!bicsPresentInDb.Contains(bic))
                        {
                            sBicsNotPresent.Append(bic);
                            sBicsNotPresent.Append(", ");
                        }
                    }
                    foreach (string bic in bicCollection11)
                    {
                        if (!bicsPresentInDb.Contains(bic))
                        {
                            sBicsNotPresent.Append(bic);
                            sBicsNotPresent.Append(", ");
                        }
                    }
                }
                else if (!bExceptionthrown)
                {
                    foreach (string bic in bicCollection8)
                    {
                        sBicsNotPresent.Append(bic);
                        sBicsNotPresent.Append(", ");
                    }
                    foreach (string bic in bicCollection11)
                    {
                        sBicsNotPresent.Append(bic);
                        sBicsNotPresent.Append(", ");
                    }
                }

                if (sBicsNotPresent.Length > 0)
                {
                    sBicsNotPresent.Length -= 2;
                }

                if (sqlDataReader != null)
                {
                    sqlDataReader.Close();
                }

                if (sqlCommand != null)
                {
                    sqlCommand.Dispose();
                }

                if (sqlConnection != null)
                {
                    sqlConnection.Close();
                }
            }

            return sBicsNotPresent.ToString();
        }

        private void GetBicParamaters(SqlCommand sqlCommand, StringCollection bicCollection, int index, int size)
        {
            foreach (string bic in bicCollection)
            {
                string paramName = "@bic" + index.ToString(CultureInfo.InvariantCulture);
                sqlCommand.Parameters.Add(new SqlParameter(paramName, SqlDbType.NVarChar, size));
                sqlCommand.Parameters[paramName].Value = bic;
                index++;
            }
        }

        private string GetBicQuery(StringCollection bicCollection, string view, int index)
        {
            StringBuilder query = new StringBuilder();
            if (bicCollection.Count > 0)
            {
                query.Append("SELECT BIC ");
                query.Append(" FROM ");
                query.Append(view);
                query.Append(" WHERE ");
                for (int i = index; i < bicCollection.Count + index; i++)
                {
                    query.Append("BIC=@bic");
                    query.Append(i.ToString(CultureInfo.InvariantCulture));
                    if (i < bicCollection.Count + index - 1)
                    {
                        query.Append(" OR ");
                    }
                }
            }
            return query.ToString();
        }

        /// <summary>
        /// Retrieves all the BankIdentifierCodes from the input document and
        /// validates them aganist a specified data source.
        /// </summary>
        /// <param name="xDocument">Inut Document containing BICs</param>
        /// <param name="xPath">XPath of the BankIdentifier node/nodes</param>
        /// <returns></returns>
        public bool GetBicsFromDocument(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath)
        {

            if (xDocument == null ||
                xPath == null ||
                xPath.Length == 0)
            {
                return true;
            }

            bool bRet = false;
            XmlNode xRoot = xDocument.Document;
            XmlNodeList xList = xRoot.SelectNodes(xPath);
            StringCollection bicCollection8 = new StringCollection();
            StringCollection bicCollection11 = new StringCollection();
            StringBuilder sNotAdded = new StringBuilder();

            int count = xList.Count;
            foreach (XmlNode xNode in xList)
            {
                StringBuilder sBuilder = new StringBuilder(20);
                foreach (XmlNode xChildNode in xNode.ChildNodes)
                {
                    sBuilder.Append(xChildNode.InnerText);
                }

                string bic = sBuilder.ToString();

                switch (bic.Length)
                {
                    case 11:
                        if (!bicCollection11.Contains(bic))
                        {
                            bicCollection11.Add(bic);
                        }
                        break;
                    case 8:
                        if (!bicCollection8.Contains(bic))
                        {
                            bicCollection8.Add(bic);
                        }
                        break;
                    default:
                        sNotAdded.Append(bic);
                        sNotAdded.Append(", ");
                        break;
                }
            }

            if (bicCollection8.Count > 0 || bicCollection11.Count > 0)
            {
                if (BicSqlConnector.columnName == null && BicSqlConnector.tableName == null)
                {
                    BicsNotFound = ValidateBICS(bicCollection8, bicCollection11);
                }
                else
                {
                    //old 2.0 behavior: only BIC11s validate
                    if (bicCollection11.Count > 0)
                    {
                        BicsNotFound = ValidateBICS(bicCollection11);
                    }
                    //add any BIC8 to the not found list
                    StringBuilder sb = new StringBuilder(20);
                    foreach (string bic in bicCollection8)
                    {
                        sb.Append(bic);
                        sb.Append(", ");
                    }
                    if (sb.Length > 0)
                    {
                        if (BicsNotFound.Length > 0)
                        {
                            sb.Insert(0, ", ");
                        }
                        sb.Length -= 2;
                        BicsNotFound += sb.ToString();
                    }
                }

                if (sNotAdded.Length > 0)
                {
                    sNotAdded.Length -= 2;

                    Trace.Tracer.TraceMessage(TraceLevel.Messages, "Invalid BICs found in the input - {0}", sNotAdded.ToString());

                    BicsNotFound += sNotAdded.ToString();
                }

                if (null == BicsNotFound || BicsNotFound.Length == 0)
                {
                    bRet = false;
                }
                else
                {
                    bRet = true;
                }
            }

            return bRet;
        }
    }


    /// <summary>
    ///		This class contains functions that validate all tags these functions are called by individual message
    ///		classes.
    /// </summary>
    public class CommonFunctions
    {
        /// <summary>
        ///		Instantiate an object of the resource file.
        /// </summary>check

        static readonly string decimalSeparator = NumberFormatInfo.CurrentInfo.NumberDecimalSeparator;
        static readonly char charDecimalSeparator = Convert.ToChar(decimalSeparator, CultureInfo.InvariantCulture);
        static ResourceManager resManager = new
            ResourceManager("Microsoft.Solutions.FinancialServices.SWIFT.A4SWIFTResources",
            Assembly.GetAssembly(typeof(Microsoft.Solutions.FinancialServices.SWIFT.StringResources)));

        #region Methods

        #region Private Helpers

        /// <method>
        ///		ContainsAllNumber
        /// </method>
        /// <summary>
        ///		This method checks if a string consists of all numbers(digits) or not.
        /// </summary>
        /// <param name ="numberString" type = "string">
        ///		Input containing the digits as a string.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        private static bool ContainsAllNumber(string numberString)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function ContainsAllNumber:");
            // Do not add the length condition here.
            // only null check need be done..
            try
            {
                if (numberString == null || numberString.Length == 0)
                    return false;

                char[] numArray = Constants.NUMBERSET.ToCharArray();

                string[] numIndex = numberString.Split(numArray);
                if (numIndex.GetLength(0) == numberString.Length + 1)
                    return true;
                else
                    return false;
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }


        /// <method>
        ///		VerifyFieldOrder
        /// </method>
        /// <summary>
        ///		Checks if the order of the codes is correct.
        /// </summary>
        /// <param name="fieldValue">
        ///		Input containing the value whose order is to be determined in a given list.
        ///	</param>
        /// <param name="listOfValues">
        ///		The input string list in which the order of "fieldValue" will be determined
        ///	</param>
        /// <param name="indexValue">
        ///		A reference integer that keeps into account the index value of the last
        ///		input string(fieldvalue) passed in.
        ///	</param>
        /// <returns type ="bool">
        ///		Returns false if the indexValue passed in is greater than the index of the
        ///		fieldValue in the listOfValues string.
        /// </returns>
        private static bool VerifyFieldOrder(string fieldValue,
            string listOfValues,
            ref int indexValue)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function VerifyFieldOrder:");
            try
            {
                if (fieldValue != null && fieldValue.Length != 0)
                {
                    if (indexValue == 0)
                    {
                        indexValue = listOfValues.IndexOf(fieldValue);
                    }

                    else
                    {
                        if (listOfValues.IndexOf(fieldValue) < indexValue)
                            return false;

                        else
                        {
                            indexValue = listOfValues.IndexOf(fieldValue);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;
        }


        /*Added for SRG2010*/
        //Purpose of this function is to check if "code" is available in any
        //line number than the allowed one.
        private static bool IsAtValidLine(XmlNode parentNode, string code, int allowedLineNo)
        {
            int lineNo = 1;

            foreach (XmlNode node in parentNode.ChildNodes)
            {
                if ((node.InnerText.StartsWith(code)) && (lineNo != allowedLineNo))
                {
                    return false;
                }
                lineNo++;
            }

            return true;
        }
        #endregion


        #region Public Methods


        /// <method>
        ///		CheckValidDate
        /// </method>
        /// <summary>
        ///		This method performs validation for Date in YYYYMMDD format.
        /// </summary>
        /// <param name="xDocument"  type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathCurrency"  type = "string">
        /// Input reference of the date.
        /// </param>
        ///  <param name="errorCode"  type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName"  type = "string">
        /// Input containing the policy name.
        /// </param>
        /// <param name="ruleName"  type = "string">
        /// Input containing the rule name.
        /// </param>
        /// <param name="errorObject"  type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>

        public static bool CheckValidDate(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidDate" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);

            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;

                }

                string[] xPathDateArray = xPath.Split(Constants.CHRCOMMA);
                int lengthxPathDate = xPathDateArray.Length;

                for (int nCount = 0; nCount <= lengthxPathDate - 1; nCount++)
                {
                    XmlNode xRoot = xDocument.Document;
                    XmlNodeList xList = xRoot.SelectNodes(xPathDateArray[nCount]);

                    if (xList != null)
                    {
                        foreach (XmlNode xNode in xList)
                        {
                            if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                            {
                                if (!IsValidDate(xNode.InnerText, "YYYYMMDD"))
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        xNode.ParentNode.ParentNode.Name, xNode.InnerText);

                                    isValid = false;
                                    break;
                                }

                            }
                        }
                    }
                }


            }

            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// Added Time Check function for rule T38 - T39 
        /// Please refer the SRG for complete details of validation requirement of above rules.

        public static bool CheckValidTime(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath1,
            string timeformat1,
            string xPath2,
            string timeformat2,
            string errorCode1,
            string errorCode2,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidTime" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    timeformat1 == null ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    timeformat2 == null ||
                    errorCode1 == null ||
                    errorCode1.Length == 0 ||
                    errorCode2 == null ||
                    errorCode2.Length == 0 ||
                    errorObject == null)
                {
                    return false;

                }

                string[] xPathDateArray1 = xPath1.Split(Constants.CHRCOMMA);
                int lengthxPathDate1 = xPathDateArray1.Length;

                for (int nCount = 0; nCount <= lengthxPathDate1 - 1; nCount++)
                {
                    XmlNode xRoot1 = xDocument.Document;
                    XmlNodeList xList1 = xRoot1.SelectNodes(xPathDateArray1[nCount]);

                    if (xList1 != null)
                    {
                        foreach (XmlNode xNode in xList1)
                        {
                            if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                            {
                                if (!IsValidTime(xNode.InnerText, timeformat1))
                                {
                                    errorObject.AddError(errorCode1, policyName, ruleName,
                                        xNode.ParentNode.ParentNode.Name, xNode.InnerText);

                                    isValid = false;
                                    break;
                                }
                            }
                        }
                    }
                }


                string[] xPathDateArray2 = xPath2.Split(Constants.CHRCOMMA);
                int lengthxPathDate2 = xPathDateArray2.Length;

                for (int nCount = 0; nCount <= lengthxPathDate2 - 1; nCount++)
                {
                    XmlNode xRoot2 = xDocument.Document;
                    XmlNodeList xList2 = xRoot2.SelectNodes(xPathDateArray2[nCount]);

                    if (xList2 != null)
                    {
                        foreach (XmlNode xNode in xList2)
                        {
                            if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                            {
                                if (!IsValidTime(xNode.InnerText, timeformat2))
                                {
                                    errorObject.AddError(errorCode2, policyName, ruleName,
                                        xNode.ParentNode.ParentNode.Name, xNode.InnerText);

                                    isValid = false;
                                    break;
                                }
                            }
                        }
                    }
                }


            }

            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// Added Time Check function for rule T38 
        /// Please refer the SRG for complete details of validation requirement of above rules.

        public static bool CheckValidTime(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string timeformat,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidTime" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    timeformat == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;

                }

                string[] xPathDateArray = xPath.Split(Constants.CHRCOMMA);
                int lengthxPathDate = xPathDateArray.Length;

                for (int nCount = 0; nCount <= lengthxPathDate - 1; nCount++)
                {
                    XmlNode xRoot = xDocument.Document;
                    XmlNodeList xList = xRoot.SelectNodes(xPathDateArray[nCount]);

                    if (xList != null)
                    {
                        foreach (XmlNode xNode in xList)
                        {
                            if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                            {
                                if (!IsValidTime(xNode.InnerText, timeformat))
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        xNode.ParentNode.ParentNode.Name, xNode.InnerText);

                                    isValid = false;
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }


        /// Added Time Check function for rule T38 - T39 
        /// Please refer the SRG for complete details of validation requirement of above rules.
        public static bool IsValidTime(string timeValue,
            string timeFormat)
        {
            int hour = 0;
            int minute = 0;
            int second = 0;
            int timelength = 0;
            bool longFormat = false;

            if (null == timeFormat) throw new ArgumentNullException("timeFormat");
            if (null == timeValue) return false;

            try
            {
                timelength = Convert.ToInt16(timeValue.Length);

                if (timeValue.Substring(0, 1) == "N")
                {
                    if (timelength == 5)
                    {
                        timeValue = timeValue.Substring(1, 4);
                    }
                    else if (timelength == 3)
                    {
                        timeValue = timeValue.Substring(1, 2);
                    }
                }


                //Check if the timeValue has all numbers
                if (!ContainsAllNumber(timeValue))
                {
                    return false;
                }


                if (!((timeFormat.CompareTo(Constants.HHMMSS_TIMEFORMAT) == 0 && timeValue.Length == Constants.HHMMSS_TIMELENGTH) ||
                    (timeFormat.CompareTo(Constants.HHMM_TIMEFORMAT) == 0 && timeValue.Length == Constants.HHMM_TIMELENGTH) ||
                    (timeFormat.CompareTo(Constants.HHMM_TIMEFORMAT) == 0 && timeValue.Length == Constants.INT2)))
                    return false;

                // Set the format variable
                if (timeFormat.CompareTo(Constants.HHMMSS_TIMEFORMAT) == 0)
                    longFormat = true;


                //// Get the hours
                hour = Convert.ToInt16(timeValue.Substring(0, 2), CultureInfo.InvariantCulture);

                // hour value can't be greater than 59
                if (hour > 23 || hour < 0)
                    return false;


                //// Get the minutes
                if (longFormat)
                {
                    minute = Convert.ToInt16(timeValue.Substring(2, 2), CultureInfo.InvariantCulture);
                }
                else
                {
                    timelength = Convert.ToInt16(timeValue.Length);
                    if (timelength > 2)
                        minute = Convert.ToInt16(timeValue.Substring(2, 2), CultureInfo.InvariantCulture);
                }

                // minutes can't be greater than 59
                if (minute > 59 || minute < 0)
                    return false;


                //// Get the seconds
                if (longFormat)
                    second = Convert.ToInt16(timeValue.Substring(4, 2), CultureInfo.InvariantCulture);

                // seconds can't be greater than 59
                if (second > 59 || second < 0)
                    return false;

            }

            catch (ArgumentOutOfRangeException)
            {
                return false;
            }

            return true;
        }


        /// <method>
        ///		IsValidDate
        /// </method>
        /// <summary>
        ///		This method performs validation for Date. Validates date both
        ///		in YYYYMMDD format or in the YYMMDD format.
        /// </summary>
        /// <param name ="dateValue" type = "string">
        ///		Input containing the date as a string in YYYYMMDD/YYMMDD format.
        /// </param>
        /// <param name ="dateFormat" type = "string">
        ///		Input containing the format string of the date - the value is
        ///		either "YYYYMMDD" or "YYMMDD".
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool IsValidDate(string dateValue,
            string dateFormat)
        {
            int daysInMonth;
            int month;
            int day;
            bool longFormat = false; //Assumes default YYMMDD format.

            if (null == dateFormat) throw new ArgumentNullException("dateFormat");

            if (null == dateValue) return false;

            //Check if the dateValue has all numbers
            if (!ContainsAllNumber(dateValue))
            {
                return false;
            }


            if (!((dateFormat.CompareTo(Constants.YYYYMMDD_DATEFORMAT) == 0 && dateValue.Length == Constants.YYYYMMDD_DATELENGTH) ||
                (dateFormat.CompareTo(Constants.YYMMDD_DATEFORMAT) == 0 && dateValue.Length == Constants.YYMMDD_DATELENGTH)))
                return false;

            // Set the format variable
            if (dateFormat.CompareTo(Constants.YYYYMMDD_DATEFORMAT) == 0)
                longFormat = true;

            // Get the month
            if (longFormat)
                month = Convert.ToInt16(dateValue.Substring(4, 2), CultureInfo.InvariantCulture);
            else
                month = Convert.ToInt16(dateValue.Substring(2, 2), CultureInfo.InvariantCulture);

            // Month can't be greater than 12
            if (month > 12 || month < 1)
                return false;

            try
            {

                //Get the number of days in the month
                if (longFormat)
                    daysInMonth = DateTime.DaysInMonth(Convert.ToInt16(dateValue.Substring(0, 4), CultureInfo.InvariantCulture), month);
                else
                {

                    // We have only the year part, need the century for the year..
                    if (Constants.YEAR_LOWERBOUND_CHARS.IndexOf(dateValue.Substring(0, 1)) != -1)
                        daysInMonth = DateTime.DaysInMonth(Convert.ToInt16(Constants.TWENTIETHCENTURY + dateValue.Substring(0, 2), CultureInfo.InvariantCulture), month);
                    else
                        daysInMonth = DateTime.DaysInMonth(Convert.ToInt16(Constants.TWENTYFIRSTCENTURY + dateValue.Substring(0, 2), CultureInfo.InvariantCulture), month);
                }
            }

            catch (ArgumentOutOfRangeException)
            {
                return false;
            }

            // Convert the day part of date to integer.
            if (longFormat)
                day = Convert.ToInt16(dateValue.Substring(6, 2), CultureInfo.InvariantCulture);
            else
                day = Convert.ToInt16(dateValue.Substring(4, 2), CultureInfo.InvariantCulture);

            //If the day is more than the number of days in the month return false
            if (day > daysInMonth || day < 1)
                return false;

            return true;
        }

        /// <method>
        ///		IsValidNumberField
        /// </method>
        /// <summary>
        ///		This function performs validation specific to the either of the SWIFT types - 'Price',
        ///		'Amount', 'Quantity' or 'Rate'.	The validations performed are, the field -
        ///		(1) Must have one and only one decimal comma. (Error code 'T43')
        ///		(2) The integer part must contain at least one digit (ie the part before the first comma).
        ///		(Error code 'T40')
        /// </summary>
        /// <param name="fieldValue" type = "string">
        ///		Input string containing the field value.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeded, false otherwise.
        /// </returns>
        public static bool IsValidSWIFTNumberField(string fieldValue)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidSWIFTNumberField:");
            try
            {
                char[] chrArray = Constants.COMMA.ToCharArray();

                if (fieldValue == null || fieldValue.Length == 0)
                    return false;

                // Split string based on ","
                string[] strArray = fieldValue.Split(chrArray);

                // If array length is not equal to 2 and the field does not start with a ","
                if (strArray.GetLength(0) == 2 && !fieldValue.StartsWith(Constants.COMMA))
                {
                    // If both the array items are valid numbers, then it's a
                    // valid SWIFT number data.
                    if (ContainsAllNumber(strArray[0]))
                    {
                        //if(ContainsAllNumber(strArray[1]))
                        return true;
                    }
                    else
                        return false;
                }

                else
                    return false;
            }

            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        /// <method>
        ///		IsValidSWIFTNumberField
        /// </method>
        /// <summary>
        ///		This function performs validation specific to the either of the SWIFT types - 'Price',
        ///		'Amount', 'Quantity' or 'Rate'.	The validations performed are, the field -
        ///		(1) Must have one and only one decimal comma. (Error code 'T43')
        ///		(2) The integer part must contain at least one digit (ie the part before the first comma).
        ///		(Error code 'T40')
        /// </summary>
        /// <param name="xDocument">
        /// Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns>True if validation succeeded, false otherwise.</returns>
        //public static bool IsValidSWIFTNumberField(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPath,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{
        //    bool isValid = true;
        //    char[] chrArray = Constants.COMMA.ToCharArray();

        //    if(xDocument == null ||
        //        xPath == null ||
        //        xPath.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    XmlNode xRoot = xDocument.Document;
        //    XmlNodeList xList = xRoot.SelectNodes(xPath);
        //    foreach(XmlNode xNode in xList)
        //    {
        //        if(xNode.InnerText != null && xNode.InnerText.Length != 0)
        //        {
        //            // Split string based on ","
        //            string [] strArray = xNode.InnerText.Split(chrArray);

        //            // If array length is not equal to 2 and the field does not start with a ","
        //            if(strArray.GetLength(0) == 2 && !(xNode.InnerText.StartsWith(Constants.COMMA)))
        //            {
        //                // If both the array items are valid numbers, then it's a
        //                // valid "SWIFT Number".
        //                if(!ContainsAllNumber(strArray[0]) || !ContainsAllNumber(strArray[1]))
        //                {
        //                    errorObject.AddError(errorCode, policyName, ruleName,
        //                        xNode.ParentNode.Name, xNode.InnerText);
        //                    isValid = false;
        //                }
        //            }

        //            else
        //            {
        //                errorObject.AddError(errorCode, policyName, ruleName,
        //                    xNode.ParentNode.Name, xNode.InnerText);
        //                isValid = false;
        //            }
        //        }

        //        else
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                xNode.ParentNode.Name, Constants.NOCONTENT);
        //            isValid = false;
        //        }
        //    }
        //    return isValid;
        //}

        /// <method>
        ///		HasValidMultipleQualifiers
        /// </method>
        /// <summary>
        ///		This method performs validation for fields with	multiple qualifiers to check for
        ///		non-repetitive qualifiers.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xList" type = "string">
        ///		Input reference of the list of elements to be validated.
        /// </param>
        /// <param name="qualifierList">
        /// 	List of qualifiers
        /// </param>
        /// <param name="nonrepetitiveQualifierList">
        /// 	List of qualifiers
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool HasValidMultipleQualifiers(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            XmlNodeList xList,
            ref string qualifierList,
            ref string nonrepetitiveQualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function HasValidMultipleQualifiers" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xList == null ||
                    xList.Count == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                if (null == qualifierList) throw new ArgumentNullException("qualifierList");
                if (null == nonrepetitiveQualifierList) throw new ArgumentNullException("nonrepetitiveQualifierList");


                string qualifier = string.Empty;

                XmlNode xRoot = xDocument.Document;

                foreach (XmlNode xNode in xList)
                {
                    if (xNode != null && xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        //Extract the value of the Qualifier
                        qualifier = xNode.InnerText.ToString().Trim();

                        //Search for the Qualifier's value in the Qualifier list.
                        //If not present, report error
                        if (qualifierList.IndexOf(qualifier) == -1 &&
                            nonrepetitiveQualifierList.IndexOf(qualifier) != -1)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                xNode.ParentNode.Name, xNode.InnerText);
                            isValid = false;
                        }

                        //Remove the Qualifier value from the Qualifier's list.
                        qualifier = qualifier + Constants.COMMA;
                        qualifierList = qualifierList.Replace(qualifier, Constants.BLANK);

                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            (xNode != null && xNode.ParentNode != null) ? xNode.ParentNode.Name : String.Empty,
                                Constants.NOCONTENT);
                        isValid = false;
                    }

                }
            }

            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }


        /// <method>
        ///		IsValidReference
        /// </method>
        /// <summary>
        ///		This function performs validation specific to the 'Reference' attribute.
        ///		The validations performed are:-
        ///		This attribute -
        ///		(1)	Must not start with a slash / (Error code 'T26')
        ///		(2) Must not end with a slash / (Error code 'T26') and
        ///		(3) Must not contain two consecutive slashes //
        ///		(Error code 'T26')
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidReference(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidReference" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);

            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;

                }


                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        if (xNode.InnerText.StartsWith(Constants.SLASH) ||
                            xNode.InnerText.EndsWith(Constants.SLASH) ||
                            xNode.InnerText.IndexOf(Constants.DOUBLESLASH) != -1)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                xNode.ParentNode.ParentNode.Name, xNode.InnerText);

                            isValid = false;
                        }

                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		IsValidMaxSequence
        /// </method>
        /// <summary>
        ///		This function performs validation to ensure that the maximum occurrence
        ///		for the Sequence is within specified limits.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="nCountRepetition" type = "int">
        ///		Reference containing the number of repetitions allowed.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the Conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidMaxSequence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            int nCountRepetition,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidMaxSequence" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                int nCount = 0;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);
                nCount = xList.Count;

                if (nCount > nCountRepetition)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType,
                        conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;

        }

        /// <method>
        ///		CheckNonRepetitiveQualifiers
        /// </method>
        /// <summary>
        ///		This method performs validation for fields with	multiple qualifiers to check for non-repetitive qualifiers.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Comma separated input references of the elements to be validated.
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the list of the qualifiers.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckNonRepetitiveQualifiers(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath,
            string qualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckNonRepetitiveQualifiers" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                int lengthxPath = 0;
                string qualifierListTemp = qualifierList;
                string nonrepetitiveQualifierList = string.Empty;

                qualifierListTemp = qualifierListTemp + Constants.COMMA;
                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);

                lengthxPath = xPathArray.Length;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        qualifierList = qualifierListTemp;
                        nonrepetitiveQualifierList = qualifierList;

                        for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                        {
                            XmlNodeList xList = xNodeSequence.SelectNodes(xPathArray[nCount].ToString());
                            if (xList.Count != 0)
                            {
                                isValid = CommonFunctions.HasValidMultipleQualifiers(xDocument, xList, ref qualifierList, ref nonrepetitiveQualifierList, errorCode, policyName, ruleName, errorObject);
                            }
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNodeSequence.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;
        }

        //Start of  RFH 2704

        /// <method>
        ///		CheckQualifiersRepetition
        /// </method>
        /// <summary>
        ///		This method performs validation for fields with	multiple qualifiers to check the repetition of the qualifiers.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Comma separated input references of the elements to be validated.
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the list of the qualifiers.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckQualifiersRepetition(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath,
            string qualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckQualifiersRepetition" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                int lengthxPath = 0;
                string qualifierListTemp = qualifierList;
                string nonrepetitiveQualifierList = string.Empty;

                qualifierListTemp = qualifierListTemp + Constants.COMMA;
                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);

                lengthxPath = xPathArray.Length;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        qualifierList = qualifierListTemp;
                        nonrepetitiveQualifierList = qualifierList;

                        for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                        {
                            XmlNodeList xList = xNodeSequence.SelectNodes(xPathArray[nCount].ToString());
                            if (xList.Count != 0)
                            {
                                isValid = CommonFunctions.HasValidMultipleQualifiers(xDocument, xList, ref qualifierList, ref nonrepetitiveQualifierList, errorCode, policyName, ruleName, errorObject);
                            }
                        }
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        //End of RFH 2704

        /// <method>
        ///		IsValidPartyIdentifier
        /// </method>
        /// <summary>
        ///		This method performs validation for PartyIdentifier field.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidPartyIdentifier(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidPartyIdentifier" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }



                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        if (xNode.InnerText.Length == Constants.INT35)
                        {
                            if (xNode.InnerText.StartsWith(Constants.SLASH))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNode.ParentNode.ParentNode.Name, xNode.InnerText);
                                isValid = false;
                            }
                            else if (!(xNode.InnerText.Substring(1, xNode.InnerText.Length - 1).StartsWith(Constants.SLASH)))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNode.ParentNode.ParentNode.Name, xNode.InnerText);
                                isValid = false;
                            }
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		ReturnXPathValue
        /// </method>
        /// <summary>
        ///		This method returns the string value of the node being accessed using the xPath.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static string ReturnXPathValue(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function ReturnXPathValue:");
            string tempValue = string.Empty;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0)
                {
                    return tempValue;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNode xNode = xRoot.SelectSingleNode(xPath);

                if (xNode != null && xNode.InnerText != null && xNode.InnerText.Length != 0)
                {
                    return xNode.InnerText;
                }
                else
                {
                    return tempValue;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        /// <method>
        ///		ReturnXPathSubType4Value
        /// </method>
        /// <summary>
        ///		This method returns the sub field 4 Type string value of the node being accessed using the xPath.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static string ReturnXPathSubType4Value(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function ReturnXPathValue:");
            string tempValue = string.Empty;
            string Type4Value = string.Empty;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0)
                {
                    return tempValue;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNode xNode = xRoot.SelectSingleNode(xPath);

                if (xNode != null && xNode.InnerText != null && xNode.InnerText.Length != 0)
                {
                    string completeValue = xNode.InnerText;

                    string[] tempArrayList = completeValue.Split('/');

                    if (tempArrayList.Length >= 2)
                    {
                        Type4Value = tempArrayList[2].Substring(5, 4);
                    }
                    return Type4Value;
                }
                else
                {
                    return tempValue;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        /// <method>
        ///		ReturnXPathUnitValueFromSignUnitAmount
        /// </method>
        /// <summary>
        ///		This method returns the Unit Value from the SignUnitAmount node being accessed using the xPath.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static string ReturnXPathUnitValueFromSignUnitAmount(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function ReturnXPathValue:");
            string tempValue = string.Empty;
            string UnitValue = string.Empty;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0)
                {
                    return tempValue;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNode xNode = xRoot.SelectSingleNode(xPath);

                if (xNode != null && xNode.InnerText != null && xNode.InnerText.Length != 0)
                {
                    string completeValue = xNode.InnerText;

                    string strSign = completeValue.Substring(0, 1);

                    if (strSign == "N")
                    {
                        UnitValue = completeValue.Substring(1, 3);
                    }
                    else
                    {
                        UnitValue = completeValue.Substring(0, 3);
                    }
                    return UnitValue;
                }
                else
                {
                    return tempValue;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }


        /// <method>
        ///		ReturnFirstSixChar
        /// </method>
        /// <summary>
        ///		This method returns the string value of first six characters
        ///     for the node being accessed using the xPath.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <returns type = "string">
        ///		Returns First six chars of the string.
        /// </returns>


        //public static string ReturnFirstSixChar(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPath)
        //{
        //    string tempValue = string.Empty;

        //    if (xDocument == null ||
        //        xPath == null ||
        //        xPath.Length == 0)
        //    {
        //        return tempValue;
        //    }

        //    XmlNode xRoot = xDocument.Document;
        //    XmlNode xNode = xRoot.SelectSingleNode(xPath);

        //   // Returns the first six characters if length is not equal to zero
        //    if (xNode != null && xNode.InnerText != null && xNode.InnerText.Length != 0)
        //    {
        //        string qualifier;
        //        qualifier = xNode.InnerText;
        //        qualifier = qualifier.Substring(0, 6);
        //        return qualifier;
        //    }
        //    else
        //    {
        //        return tempValue;
        //    }
        //}


        /// <method>
        ///		CheckCurrencyCodeValue
        /// </method>
        /// <summary>
        ///     This method performs following validations:
        ///	- Checks if the first six characters of the node being accessed using the xPath are equal to /SETC/
        ///	- returns the next three characters which should be valid currency code. 
        ///	- checks that the tenth character is the end of line code, ie Cr Lf
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <returns type = "boolean">
        ///		Returns the currency code if the second line is present and contains "/SETC/" otherwise returns false.
        /// </returns>


        //public static string CheckCurrencyCodeValue(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //  string xPath)
        //{

        //    string tempValue = Constants.FALSE;

        //    if (xDocument == null ||
        //         xPath == null ||
        //         xPath.Length == 0)
        //    {
        //        return tempValue;
        //    }

        //    XmlNode xRoot = xDocument.Document;
        //    XmlNode xNode = xRoot.SelectSingleNode(xPath);

        //   if (xNode != null && xNode.InnerText != null && xNode.InnerText.Length != 0 && xNode.InnerText.Length == 9)
        //    {
        //        String qualifier = String.Empty;
        //        String currencyCode = String.Empty;

        //        // Get first six characters 
        //          qualifier = xNode.InnerText.Substring(0, 6);

        //        // Get Country Code
        //         currencyCode = xNode.InnerText.Substring(6, 3);

        //        // If the first six characters of xPath are equal to /SETC/ return currencyCode

        //        if (qualifier.Equals(Constants.CODESETC))
        //            return currencyCode;
        //        else
        //        {
        //            return tempValue;
        //        }

        //    }
        //    else
        //    {
        //        return tempValue;
        //    }


        //}
        /// <method>
        /// 	SWIFTNetworkRule73
        /// </method>
        /// <summary>
        /// 	This function performs Conditional Rule C73 Validation which ensures that
        /// 	if SequenceB is present two or more times, field 83a must be present in each occurrence
        /// 	of the repetitive sequence
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPath35A" type = "string">
        /// 	Input containing the xpath of Tag 35A, first mandatory non-repetitive tag of SequenceB.
        /// </param>
        /// <param name="xPath83A" type = "string">
        /// 	Input containing the xpath of Tag 83A.
        /// </param>
        /// <param name="xPath83C" type = "string">
        /// 	Input containing the xpath of Tag 83C.
        /// </param>
        /// <param name="xPath83D" type = "string">
        /// 	Input containing the xpath of Tag 83D.
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Inutput containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule73(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath35A,
            string xPath83A,
            string xPath83C,
            string xPath83D,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule73" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int nCountSeqRepetition = 0;
            int nCountTag83aRepetition = 0;

            ArrayList arrxPath = new ArrayList();
            arrxPath.Add(xPath83A);
            arrxPath.Add(xPath83C);
            arrxPath.Add(xPath83D);
            try
            {
                if (xDocument == null ||
                    xPath35A == null ||
                    xPath83A == null ||
                    xPath83C == null ||
                    xPath83D == null ||
                    xPath35A.Length == 0 ||
                    xPath83A.Length == 0 ||
                    xPath83C.Length == 0 ||
                    xPath83D.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList1 = xRoot.SelectNodes(xPath35A);

                foreach (XmlNode xNode in xList1)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        nCountSeqRepetition++;
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }


                for (int nCount = 0; nCount <= 2; nCount++)
                {
                    XmlNodeList xList2 = xRoot.SelectNodes(arrxPath[nCount].ToString());
                    foreach (XmlNode xNode in xList2)
                    {
                        if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                        {
                            nCountTag83aRepetition++;
                        }
                    }
                }
                if (nCountSeqRepetition >= Constants.INT2)
                {
                    if (nCountSeqRepetition != nCountTag83aRepetition)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType,
                            conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule281
        /// </method>
        /// <summary>
        ///		This method checks whether the Balance From is different
        ///		from the Balance To i.e. The Sub-balance type of field :93A::FROM
        ///		must be different from the Sub-balance type of field :93A::TOBA.
        ///		This check applies to sequence B.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing message number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing name of the conditional rule
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing number of the conditional rule
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule281(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule281" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //declarations of variables
                string strChildNodeName = string.Empty;
                string strChildNodeValue = string.Empty;

                XmlNode xRoot = xDocument.Document;

                //get a data for sub balance. This nodelist will be used to check if
                //sub balance is different when qualifiers are FROM and TOBA
                XmlNodeList xNodeListGetSubBalance = xRoot.SelectNodes(xPath);

                ArrayList storeSubBalance = new ArrayList();

                if (xNodeListGetSubBalance.Count == 2)
                {
                    //get the sub balance of the 2 tags in an array list
                    //compare the values and raise an error if the sub balance values are same
                    foreach (XmlNode xNode in xNodeListGetSubBalance)
                    {
                        strChildNodeName = xNode.Name;
                        strChildNodeValue = xNode.LastChild.InnerText;

                        storeSubBalance.Add(xNode.LastChild.InnerText);
                    }

                    if (storeSubBalance[0].Equals(storeSubBalance[1]))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }



        ////// <method>
        ///		SWIFTNetworkRule028
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 028.
        ///		In any occurrence of subsequence E3, if value date field :98a::VALU is present, 
        ///		then in sequence E field :22F::STCO//SPST must be present, and settlement amount field 
        ///		:19A::SETT must be present in the same subsequence E3
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath98a" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath19A" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence to be validated.
        /// </param>
        /// <param name ="qualifierValue98a" type = "string">
        ///		Input containing the qualifier value of tag 98a.
        /// </param>
        /// <param name ="qualifierValue19A" type = "string">
        ///		Input containing the qualifier value of tag 19A.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule028(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath98a,
            string xPath19A,
            string xPathSequence,
            string xPath22F,
            string xPathDataSource,
            string qualifierValue98a,
            string qualifierValue19A,
            string qualifierValue22F,
            string indicatorValue22F,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule28" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int lengthxPath1;

            try
            {
                if (xDocument == null ||
                    xPath98a == null ||
                    xPath98a.Length == 0 ||
                    xPath19A == null ||
                    xPath19A.Length == 0 ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath22F == null ||
                    xPath22F.Length == 0 ||
                    xPathDataSource == null ||
                    xPathDataSource.Length == 0 ||
                    qualifierValue98a == null ||
                    qualifierValue19A == null ||
                    qualifierValue22F == null ||
                    indicatorValue22F == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                bool isPresent = false;
                string[] xPathArray1 = xPath98a.Split(Constants.CHRCOMMA);
                lengthxPath1 = xPathArray1.Length;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {

                    for (int nCount1 = 0; nCount1 <= lengthxPath1 - 1; nCount1++)
                    {
                        // check for both the Options 98A or 98C whichever is present
                        XmlNodeList xNode98aList = xNodeSequence.SelectNodes(xPathArray1[nCount1].ToString());

                        foreach (XmlNode xNode1 in xNode98aList)
                        {
                            if (xNode1 != null)
                            {
                                // check for presence of qualifier VALU in 98a Field
                                if (xNode1.InnerText.CompareTo(qualifierValue98a) == 0)
                                {
                                    XmlNodeList xNode19AList = xNodeSequence.SelectNodes(xPath19A);

                                    foreach (XmlNode xNode in xNode19AList)
                                    {
                                        if (xNode.FirstChild != null)
                                        {
                                            // check for presence of qualifier SETT in 19A Field
                                            if (xNode.FirstChild.InnerText.CompareTo(qualifierValue19A) == 0)
                                            {
                                                isPresent = true;
                                                break;
                                            }
                                            else
                                            {
                                                isPresent = false;
                                            }
                                        }
                                    }

                                }
                            }

                            if (isPresent == false)
                            {
                                isValid = false;
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                break;
                            }
                        }
                    }
                }

                string xPathIndicator = Constants.XPATH + Constants.INDICATOR;
                XmlNodeList xNode22FList = xRoot.SelectNodes(xPath22F);
                XmlNode xDataSourceScheme;
                XmlNode xNodeIndicator;

                if (isPresent)
                {
                    foreach (XmlNode xNode22F in xNode22FList)
                    {
                        // if E3::98a::VALU and E3::19A::SETT are present then qualifier in sequence E::22F node must be STCO
                        if (xNode22F != null && xNode22F.FirstChild != null)
                        {
                            if (xNode22F.FirstChild.InnerText.CompareTo(qualifierValue22F) == 0)
                            {
                                xDataSourceScheme = xNode22F.SelectSingleNode(xPathDataSource);
                                xNodeIndicator = xNode22F.SelectSingleNode(xPathIndicator);

                                // check for absence of datasource scheme and presence for indicator under 22F::STCO which should be SPST
                                if (xDataSourceScheme == null && xNodeIndicator != null && xNodeIndicator.FirstChild.InnerText.CompareTo(indicatorValue22F) == 0)
                                {
                                    isValid = true;
                                }
                                else
                                {
                                    isValid = false;
                                }
                                break;
                            }
                            else
                            {
                                isValid = false;
                            }
                        }
                    }
                    if (!isValid)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    }
                }


            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }



        ////// <method>
        ///		SWIFTNetworkRule28
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 28.
        ///		If value Date field  (field :98a::VALU) is present, the corresponding Settled Amount (field :19A::ESTT) must be
        ///		present in the same subsequence. If the Date field is not present, the Settled Amount is not allowed (Error
        ///		code(s): C28).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath98a" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath19A" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence to be validated.
        /// </param>
        /// <param name ="qualifierValue98a" type = "string">
        ///		Input containing the qualifier value of tag 98a.
        /// </param>
        /// <param name ="qualifierValue19A" type = "string">
        ///		Input containing the qualifier value of tag 19A.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule28(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath98a,
            string xPath19A,
            string xPathSequence,
            string qualifierValue98a,
            string qualifierValue19A,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule28" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int lengthxPath1;

            try
            {
                if (xDocument == null ||
                    xPath98a == null ||
                    xPath98a.Length == 0 ||
                    xPath19A == null ||
                    xPath19A.Length == 0 ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    qualifierValue19A == null ||
                    qualifierValue98a == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                bool isPresent = false;
                string[] xPathArray1 = xPath98a.Split(Constants.CHRCOMMA);
                lengthxPath1 = xPathArray1.Length;

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {

                    for (int nCount1 = 0; nCount1 <= lengthxPath1 - 1; nCount1++)
                    {
                        XmlNodeList xList1 = xNodeSequence.SelectNodes(xPathArray1[nCount1].ToString());

                        foreach (XmlNode xNode1 in xList1)
                        {
                            if (xNode1 != null)
                            {
                                if (xNode1.InnerText.CompareTo(qualifierValue98a) == 0)
                                {
                                    XmlNodeList xNode19AList = xNodeSequence.SelectNodes(xPath19A);

                                    foreach (XmlNode xNode in xNode19AList)
                                    {
                                        if (xNode.FirstChild != null)
                                        {
                                            if (xNode.FirstChild.InnerText.CompareTo(qualifierValue19A) == 0)
                                            {
                                                isPresent = true;
                                                break;

                                            }
                                        }
                                    }
                                }
                            }


                            if (isPresent == false)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;

                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule208
        /// </method>
        /// <summary>
        /// 	This method checks if the Function Of Message (Field 23G) is CANC. If yes,
        /// 	it checks whether the SubSequence A1 is present and the Field 20C within
        /// 	SubSequence A1 is present and having a qualifier PREV (only once).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xpathSubField" type = "string">
        ///		Input reference of the sub field to be checked.
        /// </param>
        /// <param name ="qualifier23G" type = "string">
        ///		Input reference of the sub field to be checked.
        /// </param>
        /// <param name ="qualifier20C" type = "string">
        ///		Input reference of the sub field to be checked.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing message number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing name of the conditional rule
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing number of the conditional rule
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule208(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xpathSubField,
            string qualifier23G,
            string qualifier20C,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule208" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    xpathSubField == null ||
                    xpathSubField.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                int countError = 0;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.FirstChild != null && xNode.FirstChild.InnerText != null)
                    {
                        if (xNode.FirstChild.InnerText.CompareTo(qualifier23G) == 0)
                        {
                            //get the node for sub sequence
                            XmlNodeList chkSubField = xRoot.SelectNodes(xpathSubField);

                            foreach (XmlNode xSubNode in chkSubField)
                            {
                                if (xSubNode.FirstChild != null)
                                {
                                    if (xSubNode.FirstChild.InnerText.CompareTo(qualifier20C) == 0)
                                    {
                                        countError++;
                                    }
                                }
                            }

                            if (countError != 1) //to check the presence of 20C:PREV only once
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule208
        /// </method>
        /// <summary>
        /// 	This method checks if the Function Of Message (Field 23G) is CANC. If yes,
        /// 	it checks whether the SubSequence A1 is present and the Field 20C within
        /// 	SubSequence A1 is present and having a qualifier PREV (at least once). (for MT381)
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xpathSubField" type = "string">
        ///		Input reference of the sub field to be checked.
        /// </param>
        /// <param name ="qualifier23G" type = "string">
        ///		Input reference of the sub field to be checked.
        /// </param>
        /// <param name ="qualifier20C" type = "string">
        ///		Input reference of the sub field to be checked.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing message number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing name of the conditional rule
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing number of the conditional rule
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule208_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xpathSubField,
            string qualifier23G,
            string qualifier20C,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule208_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    xpathSubField == null ||
                    xpathSubField.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                int countNode = 0;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.FirstChild != null && xNode.FirstChild.InnerText != null)
                    {
                        if (xNode.FirstChild.InnerText.CompareTo(qualifier23G) == 0)
                        {
                            //get the node for sub sequence
                            XmlNodeList chkSubField = xRoot.SelectNodes(xpathSubField);

                            foreach (XmlNode xSubNode in chkSubField)
                            {
                                if (xSubNode.FirstChild != null)
                                {
                                    if (xSubNode.FirstChild.InnerText.CompareTo(qualifier20C) == 0)
                                    {
                                        countNode++;
                                    }
                                }
                            }

                            if (countNode == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }



        /// <method>
        ///		IsValidStatementLine61
        /// </method>
        /// <summary>
        ///		This method performs validation for fields with	multiple qualifiers to check for non-repetitive qualifiers.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathCurrencyCode" type = "string">
        ///		Input reference of Currency code to be validated.
        /// </param>
        /// <param name ="codeList" type = "string">
        ///		Reference containing the list of the DebitCreditCodes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "Microsoft.Solutions.FinancialServices.SWIFT.ErrorCollection">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidStatementLine61(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xPathCurrencyCode,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidStatementLine61" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                string currencyCodeLastChar = string.Empty;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);
                XmlNode currencyNode = xRoot.SelectSingleNode(xPathCurrencyCode);

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.InnerText != null)
                    {
                        if (currencyNode != null)
                        {
                            currencyCodeLastChar = currencyNode.InnerText.Substring(2, 1);
                            IsValidLine1Attribute(xNode.ParentNode.Name, xNode.Name, xNode.InnerText, currencyCodeLastChar, codeList, errorCode, policyName, ruleName, errorObject);
                        }
                    }
                    else
                    {
                        return false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return true;

        }


        /// <method>
        ///		IsValidLine1Attribute
        /// </method>
        /// <summary>
        ///		This method performs validation for attribute
        /// </summary>
        /// <param name ="elementName" type = "string">
        ///		Input containing the element name.
        /// </param>
        /// <param name ="fieldElementName" type = "string">
        ///		Input containing the attribute name.
        /// </param>
        /// <param name ="fieldElementValue" type = "string">
        ///		Input containing the sub attribute value.
        /// </param>
        /// <param name="currencyCodeLastChar">
        ///		Input containing the last character of the Currency code.
        /// </param>
        /// <param name="codeList">
        /// 	CodeList
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "Microsoft.Solutions.FinancialServices.SWIFT.ErrorCollection">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidLine1Attribute(string elementName,
            string fieldElementName,
            string fieldElementValue,
            string currencyCodeLastChar,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidLine1Attribute" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            int startPositionSubfield4 = 0;
            int startPositionSubfield5 = 0;
            int startPositionSubfield6 = 0;
            int startPositionSubfield7 = 0;
            int startPositionSubfield8 = 0;
            int nNumPart = 0;
            string numPart = string.Empty;
            string amount = string.Empty;
            string transTypeIDCode = string.Empty;
            string line1SecondPart = string.Empty;
            string refForAcctOwner = string.Empty;
            string acctServInstRef = string.Empty;
            string fundsCode = string.Empty;
            bool existsSubfield2 = false;
            bool IsSingleCharSubfield3 = false;
            bool existsSubfield4 = false;
            bool isValid = true;
            try
            {

                if (null == fieldElementValue) throw new ArgumentNullException("fieldElementValue");
                if (null == errorObject) throw new ArgumentNullException("errorObject");
                if (null == codeList) throw new ArgumentNullException("codeList");

                //If field element has a value with length more than max permissible for Statement Line
                if (fieldElementValue.Length < Constants.MINLEN_STMTLINE)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                    return false;
                }

                // Validation for Subfield 1 - Date : This must be a valid date in YYMMDD format.
                if (!IsValidDateYYMMDD(fieldElementValue.Substring(0, 6)))
                {
                    errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                    isValid = false;
                }

                /* Validation for Subfield 2 - Entry Date : This is optional and if it occurs it is
                    * validated by the SWIFT system for a valid date in MMDD format*/
                if (ContainsAllNumber(fieldElementValue.Substring(6, 4)))
                {
                    existsSubfield2 = true;
                    string currentYear = System.DateTime.Today.Year.ToString(CultureInfo.InvariantCulture);
                    currentYear += fieldElementValue.Substring(6, 4);

                    if (!IsValidDateYYYYMMDDFormat(currentYear))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                        isValid = false;
                    }
                }

                /*If Subfield2 - Entry Date is not present, check for the next subfield 3- Debit/Credit mark. This is
                        * mandatory and must be validated for a Debit/credit mark*/


                string dcCodeAtSixth = fieldElementValue.Substring(6, 2).ToString();
                string dcCodeAtTenth = fieldElementValue.Substring(10, 2).ToString();
                string[] codeListArray;
                bool bIsDCCodeAtSixth = false;
                bool bIsDCCodeAtTenth = false;

                codeListArray = codeList.Split(Constants.CHRCOMMA);

                for (int i = 0; i < codeListArray.Length; i++)
                {
                    if (dcCodeAtSixth.StartsWith(codeListArray[i].ToString()))
                    {
                        if ((codeListArray[i].ToString()).Length < 2)
                        {
                            IsSingleCharSubfield3 = true;
                        }
                        existsSubfield2 = false;
                        bIsDCCodeAtSixth = true;
                        break;
                    }
                }

                if (!bIsDCCodeAtSixth)
                {
                    for (int i = 0; i < codeListArray.Length; i++)
                    {
                        if (dcCodeAtTenth.StartsWith((codeListArray[i].ToString())))
                        {
                            if ((codeListArray[i].ToString()).Length < 2)
                            {
                                IsSingleCharSubfield3 = true;
                            }
                            existsSubfield2 = true;
                            bIsDCCodeAtTenth = true;
                            break;
                        }
                    }
                }

                if (!bIsDCCodeAtTenth && !bIsDCCodeAtSixth)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                    isValid = false;

                }


                /* Validation for Subfield 4 - Funds code : This Subfield can occur at the 8th, 9th,
                    * 12th or 13th position depending upon whether the SubField 2 occured or not and whether
                    * or not Subfield 3 occured with a single character with double characters. This Subfield
                    * is optional and if it occurs it must it must be the 3rd character of the currency code */
                if (existsSubfield2 && IsSingleCharSubfield3)
                    startPositionSubfield4 = 12;
                else if (existsSubfield2 && !IsSingleCharSubfield3)
                    startPositionSubfield4 = 13;
                else if (!existsSubfield2 && IsSingleCharSubfield3)
                    startPositionSubfield4 = 8;
                else if (!existsSubfield2 && !IsSingleCharSubfield3)
                    startPositionSubfield4 = 9;

                fundsCode = fieldElementValue.Substring(startPositionSubfield4 - 1, 1);
                if (Convert.ToChar(fundsCode, CultureInfo.InvariantCulture) >= Constants.CHRA &&
                    Convert.ToChar(fundsCode, CultureInfo.InvariantCulture) <= Constants.CHRZ)
                {

                    existsSubfield4 = true;

                    //This validation is not required...
                    /*if (currencyCodeLastChar != null &&
                        fundsCode.CompareTo(currencyCodeLastChar) == 0)
                    {
                        existsSubfield4 = true;
                    }


                    else
                    {
                        errorObject.AddError(errorCode,policyName,ruleName,fieldElementName,fieldElementValue);
                        isValid = false;
                    }*/
                }
                else
                {
                    existsSubfield4 = false;
                }

                /* Validation for Subfield 5 - Amount : This Subfield can occur at 9th, 10th, 12th,
                    * 13th, 14th - position depending upon the existence of Subfields 2 and 4 and
                    * the number of characters in Subfield 3. This Subfield is mandatory and must be a
                    * valid amount, i.e. the integer part of Amount must contain at least one digit.
                    * The decimal comma , is mandatory and is included in the maximum length.*/
                if (existsSubfield2 && IsSingleCharSubfield3 && existsSubfield4)
                    startPositionSubfield5 = 13;
                else if (existsSubfield2 && IsSingleCharSubfield3 && !existsSubfield4)
                    startPositionSubfield5 = 12;
                else if (existsSubfield2 && !IsSingleCharSubfield3 && existsSubfield4)
                    startPositionSubfield5 = 14;
                else if (existsSubfield2 && !IsSingleCharSubfield3 && !existsSubfield4)
                    startPositionSubfield5 = 13;
                else if (!existsSubfield2 && IsSingleCharSubfield3 && existsSubfield4)
                    startPositionSubfield5 = 9;
                else if (!existsSubfield2 && IsSingleCharSubfield3 && !existsSubfield4)
                    startPositionSubfield5 = 8;
                else if (!existsSubfield2 && !IsSingleCharSubfield3 && existsSubfield4)
                    startPositionSubfield5 = 10;
                else if (!existsSubfield2 && !IsSingleCharSubfield3 && !existsSubfield4)
                    startPositionSubfield5 = 9;

                // Get the part of statement line starting from Amount (Subfield 5) upto the end.
                line1SecondPart = fieldElementValue.Substring(startPositionSubfield5 - 1);

                // Get the starting position of Subfield 6 which is mandatory and must begin with S,N or F.
                if ((startPositionSubfield6 = line1SecondPart.IndexOfAny(Constants.ALPHASET.ToCharArray())) == -1)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                    isValid = false;
                }

                // Get the amount part.
                amount = line1SecondPart.Substring(0, startPositionSubfield6);

                // Validate the amount.
                if (!IsValidNumberField(elementName, Constants.AMOUNT, amount, policyName, ruleName, errorObject, errorCode))
                    isValid = false;

                /* Validation for Subfield 6 - Transaction type Identification code : This Subfield is
                        * mandatory and the first character may be S, N or F. (This has already been
                        * validated). If the first character is 'S' then the remaining 3 characters must
                        * be in the range 100-999. */

                transTypeIDCode = line1SecondPart.Substring(startPositionSubfield6, 4);
                numPart = transTypeIDCode.Substring(1);

                if (transTypeIDCode.StartsWith(Constants.ALPHAS))
                {
                    if (!ContainsAllNumber(numPart))
                    {
                        // suriyan - 2/10/2006 - PreSharp warning 56056 - errorObject can be null - how?
                        //#pragma warning suppress 6506
                        errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                        isValid = false;
                        return isValid;
                    }

                    nNumPart = Convert.ToInt32(numPart, CultureInfo.InvariantCulture);

                    if (!(nNumPart >= Constants.INT100 && nNumPart <= Constants.INT999))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                        isValid = false;
                    }
                }
                else
                {
                    if (!(IsUpperCaseAlphaNum(transTypeIDCode, elementName, fieldElementName, policyName, ruleName, errorObject, errorCode)))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                        isValid = false;
                    }
                }

                /* Validation for Subfield 7 - Reference for the Account Owner : This Subfield is
                        * mandatory and must contain a maximum of 16 characters. */
                startPositionSubfield7 = startPositionSubfield6 + 4;

                // Check if Subfield 8 exists or not. This Subfield starts with "//".
                if ((startPositionSubfield8 = line1SecondPart.IndexOf(Constants.DOUBLESLASH)) == -1)
                    refForAcctOwner = line1SecondPart.Substring(startPositionSubfield7);
                else
                    refForAcctOwner = line1SecondPart.Substring(startPositionSubfield7,
                        startPositionSubfield8 - startPositionSubfield7);

                // Validate length of this Subfield
                if (refForAcctOwner.Length > 16 || refForAcctOwner.Length < 1)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                    isValid = false;
                }

                /* Validation for Subfield 8 - Account Servicing Institution's Reference : This
                        * Subfield is optional. It must begin with "//" and must contain a maximum of
                        * 16 characters. */
                if (startPositionSubfield8 != -1)
                {
                    acctServInstRef = line1SecondPart.Substring(startPositionSubfield8 + 2);

                    if (acctServInstRef.Length > 16 || acctServInstRef.Length < 1)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		IsValidDate
        /// </method>
        /// <summary>
        ///		This method performs validation for Date (YYMMDD).
        ///		It checks if a string value is a valid date expressed in the format specified.
        /// </summary>
        /// <param name ="dateValue" type = "string">
        ///		Input containing the date as a string.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        //public static bool IsValidDate(string dateValue)
        //{
        //    int		daysInMonth;
        //    int		month;
        //    int		day;

        //    //Check if the dateValue has all numbers
        //    if (!ContainsAllNumber(dateValue))
        //        return false;

        //    //Get the month
        //    month = Convert.ToInt16(dateValue.Substring(2, 2), CultureInfo.InvariantCulture);

        //    //Month can't be greater than 12
        //    if (month > Constants.INT12 || month < Constants.INT1)
        //    {
        //        return false;
        //    }

        //    //Get the number of days in the month
        //    daysInMonth = DateTime.DaysInMonth(Convert.ToInt16(dateValue.Substring(0, 2), CultureInfo.InvariantCulture), month);

        //    // Convert the day part of date to integer.
        //    day = Convert.ToInt16(dateValue.Substring(4, 2), CultureInfo.InvariantCulture);

        //    //If the day is more than the number of days in the month return false
        //    if (day > daysInMonth || day < 1)
        //        return false;

        //    return true;
        //}

        /// <method>
        ///		IsValidDate
        /// </method>
        /// <summary>
        ///		This method performs validation for Date (YYYYMMDD).
        ///		It checks if a string value is a valid date expressed in the format specified.
        /// </summary>
        /// <param name ="dateValue" type = "string">
        ///		Input containing the date as a string.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool IsValidDateYYYYMMDDFormat(string dateValue)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidDateYYYYMMDDFormat:");

            int daysInMonth;
            int month;
            int day;
            try
            {


                //Check if the dateValue has all numbers
                if (!ContainsAllNumber(dateValue))
                    return false;

                //Get the month
                month = Convert.ToInt16(dateValue.Substring(4, 2), CultureInfo.InvariantCulture);

                //Month cannot be greater than 12
                if (month > Constants.INT12 || month < Constants.INT1)
                {
                    return false;
                }

                //Get the number of days in the month
                if (!(Convert.ToInt16(dateValue.Substring(0, 4), CultureInfo.InvariantCulture) >= Constants.INT1 && Convert.ToInt16(dateValue.Substring(0, 4), CultureInfo.InvariantCulture) <= Constants.INT9999))
                {
                    return false;
                }
                daysInMonth = DateTime.DaysInMonth(Convert.ToInt16(dateValue.Substring(0, 4), CultureInfo.InvariantCulture), month);

                // Convert the day part of date to integer.
                day = Convert.ToInt16(dateValue.Substring(6, 2), CultureInfo.InvariantCulture);

                //If the day is more than the number of days in the month return false
                if (day > daysInMonth || day < Constants.INT1)
                    return false;
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return true;
        }

        /// <method>
        ///		IsValidNumberField
        /// </method>
        /// <summary>
        ///		This function performs validation specific to the either of the attributes 'Price', 'Amount', 'Quantity',
        ///		'Rate'.	The validations performed are, this atribute -
        ///		(1) Must have one and only one decimal comma. (Error code 'T43')
        ///		(2) The integer part must contain at least one digit (ie the part before the first comma).
        ///		(Error code 'T40')
        /// </summary>
        /// <param name="elementName" type = "string">
        ///		Input containing the name of the element to which the attribute	belongs to.
        /// </param>
        /// <param name="fieldElementName" type = "string">
        ///		Input containing the name of the attribute.
        /// </param>
        /// <param name="fieldElementValue" type = "string">
        ///		Input containing the attribute value.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "Microsoft.Solutions.FinancialServices.SWIFT.ErrorCollection">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidNumberField(string elementName,
            string fieldElementName,
            string fieldElementValue,
            string policyName,
            string ruleName,
            ErrorCollection errorObject,
            string errorCode)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidNumberField" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == errorObject) throw new ArgumentNullException("errorObject");
                if (null == fieldElementValue) throw new ArgumentNullException("fieldElementValue");

                string charValue = string.Empty;


                //Split the Number attribute array on decimal comma
                if (fieldElementValue.Length > 15)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                    return false;
                }
                string[] elementArray = fieldElementValue.Split(Constants.CHRCOMMA);

                //Loop through the fieldElementValue
                for (int counter = 0; counter < fieldElementValue.Length; counter++)
                {
                    charValue = fieldElementValue.Substring(counter, 1);

                    // Check if the attribute is composed only of commas and digits
                    if ((Constants.NUMBERSET.IndexOf(charValue) == -1 && charValue.CompareTo(Constants.COMMA) != 0) || (charValue.CompareTo(Constants.BLANK) == 0))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                        isValid = false;
                    }
                }

                //If both the integer part and the decimal part are not present report error
                if (elementArray.Length != 2)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                    isValid = false;
                }

                //Check if the integer value is not ""
                if (elementArray[0].Length == 0)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, fieldElementValue);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		IsUpperCaseAlphaNum
        /// </method>
        /// <summary>
        ///		The function checks if the string is composed of only uppercase alphanumeric characters
        /// </summary>
        /// <param name="elementVal" type="string">
        ///		Element whose attribute is to be checked for uppercase alphanumeric
        ///	</param>
        /// <param name="elementName" type="XmlElement">
        ///		Name of the Element
        ///	</param>
        /// <param name="fieldElementName" type="string">
        ///		Name of the Attribute
        ///	</param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "Microsoft.Solutions.FinancialServices.SWIFT.ErrorCollection">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsUpperCaseAlphaNum(string elementVal,
            string elementName,
            string fieldElementName,
            string policyName,
            string ruleName,
            ErrorCollection errorObject,
            string errorCode)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsUpperCaseAlphaNum" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (null == errorObject) throw new ArgumentNullException("errorObject");
                if (null == elementVal) throw new ArgumentNullException("elementVal");

                string singleChar = string.Empty;

                //Check for uppercase
                if (elementVal == elementVal.ToUpper(System.Globalization.CultureInfo.InvariantCulture))
                {
                    //Loop through the string and check if each char is alphanumeric
                    for (int counter = 0; counter < elementVal.Length; counter++)
                    {
                        singleChar = elementVal.Substring(counter, 1);

                        if ((Constants.ALPHANUMBERSET.IndexOf(singleChar) == -1))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, elementVal);
                            return false;
                        }
                    }
                }
                else
                {
                    errorObject.AddError(errorCode, policyName, ruleName, fieldElementName, elementVal);
                    return false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return true;
        }

        /// <method>
        ///		SWIFTNetworkRule27
        /// </method>
        /// <summary>
        ///		The function checks if the first two characters of CurrencyCode Element are same in all occurances in the XML Document.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns>
        ///		True if CurrencyCode is same.
        ///	</returns>

        public static bool SWIFTNetworkRule27(TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule27" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                int index = 0;
                string currencyCheck = string.Empty;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.InnerText != null)
                    {
                        if (index == 0)
                        {
                            currencyCheck = xNode.InnerText.Substring(0, 2);
                            index = index + 1;
                        }
                        else
                        {
                            if (!VerifyCurrency(xNode.InnerText, currencyCheck))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                return false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return true;
        }

        /// <method>
        ///		SWIFTNetworkRule27
        /// </method>
        /// <summary>
        ///		The function checks if the first two characters of CurrencyCode Element are same in all occurances in the XML Document.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath90CD" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns>
        ///		True if CurrencyCode is Same.
        ///	</returns>

        public static bool SWIFTNetworkRule27(TypedXmlDocument xDocument,
            string xPath,
            string xPath90CD,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule27" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            int index = 0;
            string currencyCheck = null;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    xPath90CD == null ||
                    xPath90CD.Length == 0 ||
                    policyName == null ||
                    ruleName == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);


                foreach (XmlNode xNode in xList)
                {
                    if (xNode.InnerText != null)
                    {
                        if (index == 0)
                        {
                            currencyCheck = xNode.InnerText.Substring(0, 2);
                            index = index + 1;
                        }
                        else
                        {
                            if (!VerifyCurrency(xNode.InnerText, currencyCheck))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                return false;
                            }
                        }
                    }
                }

                XmlNodeList xList90CD = xRoot.SelectNodes(xPath90CD);

                foreach (XmlNode xNode in xList90CD)
                {
                    if (xNode.InnerText != null)
                    {
                        int startPositionCurrency = 0;

                        //	startPositionCurrency is the position in the fieldElementValue of Node 90C/D from where Currency Starts.

                        if ((startPositionCurrency = xNode.InnerText.IndexOfAny(Constants.ALPHASET.ToCharArray())) == -1)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            return false;
                        }

                        string currency90CD = xNode.InnerText.Substring(startPositionCurrency, 3);

                        if (currencyCheck == null)
                        {
                            currencyCheck = xNode.InnerText.Substring(startPositionCurrency, 2);

                        }
                        else
                        {
                            if (!VerifyCurrency(currency90CD, currencyCheck))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                return false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return true;
        }


        /// <method>
        ///		VerifyCurrency
        /// </method>
        /// <summary>
        ///		The function checks if first two characters of "fieldValue" is same as "currencyCheck"
        /// </summary>
        /// <param name="fieldValue" type="string">
        ///		The field element whose value is to be checked against "currencyCheck".
        ///	</param>
        /// <param name="currencyCheck" type="string">
        ///		Name of the Element
        ///	</param>
        private static bool VerifyCurrency(string fieldValue, string currencyCheck)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function VerifyCurrency:");
            string tempCurrency = string.Empty;
            try
            {
                if (fieldValue != null && fieldValue.Length != 0)
                {
                    tempCurrency = fieldValue.Substring(0, 2);

                    if (tempCurrency.CompareTo(currencyCheck) != 0)
                        return false;

                }
                else
                    return false;
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;
        }

        /// <method>
        ///		SWIFTNetworkRule6
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 6.Either field 50a or field 52a, but not both, must be present in a repetitive sequence
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the first mandatory element of the sequence.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of the element 50(option1) to be validated.
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of the element 50(option2) to be validated.
        /// </param>
        /// <param name ="xPath3" type = "string">
        ///		Input reference of the element 50(option3) to be validated.
        /// </param>
        /// <param name ="xPath4" type = "string">
        ///		Input reference of the element 52(option1) to be validated.
        /// </param>
        /// <param name ="xPath5" type = "string">
        ///		Input reference of the element 52(option2) to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule6(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath1,
            string xPath2,
            string xPath3,
            string xPath4,
            string xPath5,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule6" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool bln50Present = false;
            bool bln52Present = false;
            bool isValid = true;
            int lastChildFlag = 0;
            try
            {

                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    xPath3 == null ||
                    xPath3.Length == 0 ||
                    xPath4 == null ||
                    xPath4.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNode xNode = xRoot.SelectSingleNode(xPathSequence);

                if (xNode != null)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        while (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0 || xNode.NextSibling != null)
                        {
                            if (xRoot.SelectSingleNode(xPathSequence) != null)
                            {
                                while (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) != 0 && lastChildFlag <= 1)
                                {
                                    if (xRoot.SelectSingleNode(xPath1) != null)
                                    {
                                        if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath1).Name) == 0)
                                        {
                                            bln50Present = true;
                                        }
                                    }
                                    if (xRoot.SelectSingleNode(xPath2) != null)
                                    {
                                        if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath2).Name) == 0)
                                        {
                                            bln50Present = true;
                                        }
                                    }
                                    if (xRoot.SelectSingleNode(xPath3) != null)
                                    {
                                        if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath3).Name) == 0)
                                        {
                                            bln50Present = true;
                                        }
                                    }
                                    if (xRoot.SelectSingleNode(xPath4) != null)
                                    {
                                        if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath4).Name) == 0)
                                        {
                                            bln52Present = true;
                                        }
                                    }
                                    if (xRoot.SelectSingleNode(xPath5) != null)
                                    {
                                        if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath5).Name) == 0)
                                        {
                                            bln52Present = true;
                                        }
                                    }

                                    if (xRoot.LastChild.LastChild != null)
                                    {
                                        if ((xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling != null) || (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0))
                                        {
                                            xNode = xNode.NextSibling;
                                        }

                                        if (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling == null)
                                        {
                                            lastChildFlag++;
                                        }
                                    }

                                    if (xRoot.SelectSingleNode(xPathSequence) != null)
                                    {
                                        if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) == 0)
                                        {
                                            if ((bln50Present == true && bln52Present == true) || (bln50Present == false && bln52Present == false))
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }
                                            bln50Present = false;
                                            bln52Present = false;
                                        }
                                    }
                                }

                            }
                            if (xRoot.LastChild.LastChild != null)
                            {
                                if ((xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling != null) || (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0))
                                {
                                    xNode = xNode.NextSibling;
                                }
                            }
                        }
                        if ((bln50Present == true && bln52Present == true) || (bln50Present == false && bln52Present == false))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                        bln50Present = false;
                        bln52Present = false;

                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		IsValidCode
        /// </method>
        /// <summary>
        ///		This method performs validation for fields where validation is, if Data Source Scheme is not present,
        ///		indicator must contain one of the codes in the string array(Error code 'Not Defined').
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathField" type = "string">
        ///		Input reference of the field element which should not be present to be validated.
        /// </param>
        /// <param name ="xPathCode" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="codeList" type = "string">
        ///		Reference containing the list of the codes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidCode(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathField,
            string xPathCode,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCode" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                string code = string.Empty;
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathField == null ||
                    xPathField.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTag = xRoot.SelectNodes(xPathTag);

                foreach (XmlNode xNode in xListTag)
                {
                    //check if the node has an DataSourceScheme tag
                    XmlNode xNodeField = xNode.SelectSingleNode(xPathField);

                    //Since the DataSourceScheme is not present, check for validity of code
                    if (xNodeField == null)
                    {
                        if (xNode.SelectSingleNode(xPathCode) != null)
                        {
                            code = xNode.SelectSingleNode(xPathCode).InnerText;
                        }
                        //Check for the presence of the code value in the codelist. If not present report error
                        if ((codeList.IndexOf(code) == -1) || (code == Constants.BLANK))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                xNode.Name, code);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		IsValidRateStatus
        /// </method>
        /// <summary>
        ///		This method performs validation for fields where validation is, if Data Source Scheme is not present,
        ///		indicator must contain one of the codes in the string array(Error code 'Not Defined').
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathField" type = "string">
        ///		Input reference of the field element which should not be present to be validated.
        /// </param>
        /// <param name ="xPathCode" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="codeList" type = "string">
        ///		Reference containing the list of the codes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidRateStatus(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathField,
            string xPathCode,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidRateStatus" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                string code = string.Empty;
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathField == null ||
                    xPathField.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTag = xRoot.SelectNodes(xPathTag);

                foreach (XmlNode xNode in xListTag)
                {
                    //check if the node has an DataSourceScheme tag
                    XmlNode xNodeField = xNode.SelectSingleNode(xPathField);

                    //Since the DataSourceScheme is not present, check for validity of code
                    if (xNodeField == null)
                    {
                        if (xNode.SelectSingleNode(xPathCode) != null)
                        {
                            code = xNode.SelectSingleNode(xPathCode).InnerText;
                            //Check for the presence of the code value in the codelist. If not present report error
                            if ((codeList.IndexOf(code) == -1) || (code == Constants.BLANK))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNode.Name, code);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }
        /// <method>
        ///		SWIFTNetworkRule259
        /// </method>
        /// <summary>
        ///This method checks if the Function Of Message (Field 23G) is not CANC. then,
        ///it checks whether the SubSequence A1 is present and the Field 13A within
        ///SubSequence A1 is present and contains the value as 515.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xpathSubSeq" type = "string">
        ///		Input reference of the SubSequence to be checked.
        /// </param>
        /// <param name ="xpathSubField" type = "string">
        ///		Input reference of the sub field to be checked.
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the qualifier value.
        /// </param>
        /// <param name ="constantValue" type = "string">
        ///		Input containing the constant value.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule259(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xpathSubSeq,
            string xpathSubField,
            string qualifierValue,
            string constantValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule259" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    xpathSubSeq == null ||
                    xpathSubSeq.Length == 0 ||
                    xpathSubField == null ||
                    xpathSubField.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);
                bool isPresent = false;

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.FirstChild != null)
                    {
                        if (xNode.FirstChild.InnerText != null)
                        {
                            if (xNode.FirstChild.InnerText.CompareTo(qualifierValue) != 0)
                            {
                                //get the node for sub sequence
                                XmlNodeList chkSubSeq = xRoot.SelectNodes(xpathSubSeq);
                                XmlNodeList chkSubField = xRoot.SelectNodes(xpathSubField);

                                //check if the sub sequence exists in the XML document
                                if (chkSubSeq.Count > 0)
                                {
                                    if (chkSubField.Count == 0)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                    }
                                    else
                                    {
                                        foreach (XmlNode xSubNode in chkSubField)
                                        {
                                            if (xSubNode.InnerText.Substring(4).CompareTo(constantValue) == 0)
                                            {
                                                isPresent = true;
                                            }
                                        }
                                        if (isPresent == false)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isValid = false;

                                        }
                                    }
                                }
                            }

                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }


        /// <method>
        ///		IsValidIdentificationOfSecurities
        /// </method>
        /// <summary>
        ///		This method performs validation for Valid IdentificationOfSecurities
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the tag to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidIdentificationOfSecurities(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidIdentificationOfSecurities" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                XmlNodeList recordList = xRoot.SelectNodes(xPath);
                foreach (XmlNode xNode in recordList)
                {
                    if (xNode.HasChildNodes)
                    {
                        foreach (XmlNode childNode in xNode.ChildNodes)
                        {
                            if (childNode != null && childNode.InnerText.Length == 0)
                            {
                                isValid = false;
                            }
                        }
                    }
                    else
                    {
                        isValid = false;
                    }
                    if (!isValid)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, xNode.Name, xNode.InnerText);
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }


        /// <method>
        ///		SWIFTSRG2001NetworkRule108
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 108.If used in any repetitive sequence, both fields 57a and 58a must be present.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the first mandatory element of the sequence.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of the element 57(option1) to be validated.
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of the element 57(option2) to be validated.
        /// </param>
        /// <param name ="xPath3" type = "string">
        ///		Input reference of the element 58(option1) to be validated.
        /// </param>
        /// <param name ="xPath4" type = "string">
        ///		Input reference of the element 58(option2) to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule108(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence,
        //    string xPath1,
        //    string xPath2,
        //    string xPath3,
        //    string xPath4,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    bool bln57Present = false;
        //    bool bln58Present = false;
        //    bool isValid	  = true;
        //    int lastChildFlag = 0;


        //    if(xDocument == null ||
        //        xPathSequence == null ||
        //        xPathSequence.Length == 0 ||
        //        xPath1 == null ||
        //        xPath1.Length == 0 ||
        //        xPath2 == null ||
        //        xPath2.Length == 0 ||
        //        xPath3 == null ||
        //        xPath3.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    XmlNode xRoot = xDocument.Document;

        //    XmlNode xNode = xRoot.SelectSingleNode(xPathSequence);

        //    if(xNode != null)
        //    {
        //        if(xNode.InnerText != null && xNode.InnerText.Length != 0)
        //        {
        //            if(xRoot.LastChild.LastChild != null)
        //            {
        //                while(xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0 || xNode.NextSibling != null)
        //                {
        //                    if(xRoot.SelectSingleNode(xPathSequence) != null)
        //                    {
        //                        while(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) != 0 && lastChildFlag <= 1 )
        //                        {
        //                            if(xRoot.SelectSingleNode(xPath1) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath1).Name) == 0)
        //                                {
        //                                    bln57Present = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath2) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath2).Name) == 0)
        //                                {
        //                                    bln57Present = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath3) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath3).Name) == 0)
        //                                {
        //                                    bln58Present = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath4) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath4).Name) == 0)
        //                                {
        //                                    bln58Present = true;
        //                                }
        //                            }

        //                            if((xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling != null)||(xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0))
        //                            {
        //                                xNode = xNode.NextSibling ;
        //                            }

        //                            if(xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling == null)
        //                            {
        //                                lastChildFlag ++;
        //                            }

        //                            if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) == 0)
        //                            {
        //                                if((bln57Present == true && bln58Present == false)||(bln57Present == false && bln58Present == true))
        //                                {
        //                                    errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                                    isValid = false;
        //                                }
        //                                bln57Present = false;
        //                                bln58Present = false;
        //                            }
        //                        }
        //                    }
        //                    if((xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling != null)||(xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0))
        //                    {
        //                        xNode = xNode.NextSibling ;
        //                    }

        //                }

        //            }
        //            if((bln57Present == true && bln58Present == false)||(bln57Present == false && bln58Present == true))
        //            {
        //                errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                isValid = false;
        //            }
        //            bln57Present=false;
        //            bln58Present=false;

        //        }
        //        else
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                xNode.ParentNode.Name, Constants.NOCONTENT);
        //            isValid = false;
        //        }
        //    }
        //    return isValid;

        //}


        /// <method>
        ///		SWIFTSRG2001NetworkRule110
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 110.Fields 31T, 33T, 32M, 37J, 34(G or H), 37L, 33S and 37P may only be present in a
        ///		repetitive sequence if field 31P is present in the same repetitive sequence
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the first mandatory element of the sequence.
        /// </param>
        /// <param name ="xPath31P" type = "string">
        ///		Input reference of the element 31P to be validated.
        /// </param>
        /// <param name ="xPath31T" type = "string">
        ///		Input reference of the element 31T to be validated.
        /// </param>
        /// <param name ="xPath33T" type = "string">
        ///		Input reference of the element 33T to be validated.
        /// </param>
        /// <param name ="xPath32M" type = "string">
        ///		Input reference of the element 32M to be validated.
        /// </param>
        /// <param name ="xPath37J" type = "string">
        ///		Input reference of the element 37J to be validated.
        /// </param>
        /// <param name ="xPath34G" type = "string">
        ///		Input reference of the element 34G to be validated.
        /// </param>
        /// <param name ="xPath34H" type = "string">
        ///		Input reference of the element 34H to be validated.
        /// </param>
        /// <param name ="xPath37L" type = "string">
        ///		Input reference of the element 37L to be validated.
        /// </param>
        /// <param name ="xPath33S" type = "string">
        ///		Input reference of the element 33S to be validated.
        /// </param>
        /// <param name ="xPath37P" type = "string">
        ///		Input reference of the element 37P to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule110(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence,
        //    string xPath31P,
        //    string xPath31T,
        //    string xPath33T,
        //    string xPath32M,
        //    string xPath37J,
        //    string xPath34G,
        //    string xPath34H,
        //    string xPath37L,
        //    string xPath33S,
        //    string xPath37P,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    bool bln31PPresent = false;
        //    bool bln31TPresent = false;
        //    bool bln33TPresent = false;
        //    bool bln32MPresent = false;
        //    bool bln37JPresent = false;
        //    bool bln34Present  = false;
        //    bool bln37LPresent = false;
        //    bool bln33SPresent = false;
        //    bool bln37PPresent = false;
        //    bool isValid	   = true;
        //    int lastChildFlag  = 0;


        //    if(xDocument == null ||
        //        xPathSequence == null ||
        //        xPathSequence.Length == 0 ||
        //        xPath31P == null ||
        //        xPath31P.Length == 0 ||
        //        xPath31T == null ||
        //        xPath31T.Length == 0 ||
        //        xPath33T == null ||
        //        xPath33T.Length == 0 ||
        //        xPath32M == null ||
        //        xPath32M.Length == 0 ||
        //        xPath37J == null ||
        //        xPath37J.Length == 0 ||
        //        xPath34G == null ||
        //        xPath34G.Length == 0 ||
        //        xPath34H == null ||
        //        xPath34H.Length == 0 ||
        //        xPath37L == null ||
        //        xPath37L.Length == 0 ||
        //        xPath33S == null ||
        //        xPath33S.Length == 0 ||
        //        xPath37P == null ||
        //        xPath37P.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    XmlNode xRoot = xDocument.Document;

        //    XmlNode xNode = xRoot.SelectSingleNode(xPathSequence);

        //    if(xNode != null)
        //    {
        //        if(xNode.InnerText != null && xNode.InnerText.Length != 0)
        //        {
        //            if(xRoot.LastChild.LastChild != null)
        //            {
        //                while(xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0 || xNode.NextSibling != null)
        //                {
        //                    if(xRoot.SelectSingleNode(xPathSequence) != null)
        //                    {
        //                        while(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) != 0 && lastChildFlag <= 1 )
        //                        {
        //                            if(xRoot.SelectSingleNode(xPath31P) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath31P).Name) == 0)
        //                                {
        //                                    bln31PPresent = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath31T) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath31T).Name) == 0)
        //                                {
        //                                    bln31TPresent = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath32M) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath32M).Name) == 0)
        //                                {
        //                                    bln32MPresent = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath33S) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath33S).Name) == 0)
        //                                {
        //                                    bln33SPresent = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath33T) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath33T).Name) == 0)
        //                                {
        //                                    bln33TPresent = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath34G) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath34G).Name) == 0)
        //                                {
        //                                    bln34Present = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath34H) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath34H).Name)== 0)
        //                                {
        //                                    bln34Present = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath37J) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath37J).Name) == 0)
        //                                {
        //                                    bln37JPresent = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath37L) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath37L).Name) == 0)
        //                                {
        //                                    bln37LPresent = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath37P) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath37P).Name) == 0)
        //                                {
        //                                    bln37PPresent = true;
        //                                }
        //                            }
        //                            if((xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling != null)||(xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0))
        //                            {
        //                                xNode = xNode.NextSibling ;
        //                            }

        //                            if(xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling == null)
        //                            {
        //                                lastChildFlag ++;
        //                            }
        //                            if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) == 0)
        //                            {
        //                                if((bln31TPresent == true || bln32MPresent == true || bln33SPresent == true
        //                                    || bln33TPresent == true || bln34Present == true ||
        //                                    bln37JPresent == true || bln37LPresent == true ||
        //                                    bln37PPresent == true ) && (bln31PPresent == false ))
        //                                {
        //                                    errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                                    isValid = false;
        //                                }
        //                                bln31PPresent = false;
        //                                bln31TPresent = false;
        //                                bln33TPresent = false;
        //                                bln32MPresent = false;
        //                                bln37JPresent = false;
        //                                bln34Present = false;
        //                                bln37LPresent = false;
        //                                bln33SPresent = false;
        //                                bln37PPresent = false;
        //                            }
        //                        }
        //                    }
        //                    if((xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling != null)
        //                        ||(xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0))
        //                    {
        //                        xNode = xNode.NextSibling ;
        //                    }
        //                }
        //            }
        //            if((bln31TPresent == true || bln32MPresent == true || bln33SPresent == true ||
        //                bln33TPresent == true || bln34Present == true || bln37JPresent == true ||
        //                bln37LPresent == true || bln37PPresent == true ) && (bln31PPresent == false ))
        //            {
        //                errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                isValid = false;
        //            }
        //            bln31PPresent = false;
        //            bln31TPresent = false;
        //            bln33TPresent = false;
        //            bln32MPresent = false;
        //            bln37JPresent = false;
        //            bln34Present = false;
        //            bln37LPresent = false;
        //            bln33SPresent = false;
        //            bln37PPresent = false;

        //        }
        //        else
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                xNode.ParentNode.Name, Constants.NOCONTENT);
        //            isValid = false;
        //        }
        //    }
        //    return isValid;
        //}

        /// <method>
        /// 	SWIFTSRG2003NetworkRule107
        /// </method>
        /// <summary>
        /// 	This function performs Conditional Rule D07 Validation which ensures that Field 20 in the non-repetitive sequence must be present if the repetitive sequence is
        /// 	present two or more times.
        ///
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPath23" type = "string">
        /// 	Input containing the xpath of Tag 23, first mandatory non-repetitive tag of Sequence.
        /// </param>
        /// <param name="xPath20" type = "string">
        /// 	Input containing the xpath of Tag 20.
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Inutput containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule107(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPath23,
        //    string xPath20,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{

        //    bool isValid = true;
        //    bool bln20Present = false;
        //    if(xDocument == null ||
        //        xPath23 == null ||
        //        xPath20 == null ||
        //        xPath23.Length == 0 ||
        //        xPath20.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    int nCountSeqRepetition = 0;
        //    XmlNode xRoot = xDocument.Document;
        //    XmlNodeList xList1 = xRoot.SelectNodes(xPath23);

        //    foreach(XmlNode xNode in xList1)
        //    {
        //        if(xNode.InnerText != null && xNode.InnerText.Length != 0)
        //        {
        //            nCountSeqRepetition++;
        //        }
        //        else
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                xNode.ParentNode.Name, Constants.NOCONTENT);
        //            isValid = false;
        //        }
        //    }


        //    for(int nCount = 0;nCount <= 2;nCount++)
        //    {
        //        XmlNodeList xList2 = xRoot.SelectNodes(xPath20);
        //        foreach(XmlNode xNode in xList2)
        //        {
        //            if(xNode.InnerText != null && xNode.InnerText.Length != 0)
        //            {
        //                bln20Present = true;
        //            }
        //        }
        //    }
        //    if (nCountSeqRepetition >= Constants.INT2 && bln20Present == false)
        //    {
        //        errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //        isValid = false;
        //    }
        //    return isValid;
        //}

        /// <method>
        ///		CheckAtLeastOneMandatoryQualifier
        /// </method>
        /// <summary>
        ///		This method performs validation for fields with	multiple qualifiers to check
        ///		for one of these as mandatory qualifiers.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Comma separated input references of the elements to be validated.
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the list of the qualifiers.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckAtLeastOneMandatoryQualifier(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath,
            string qualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckAtLeastOneMandatoryQualifier" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                int countQualifier = 0;

                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                if (null == qualifierList) throw new ArgumentNullException("qualifierList");

                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        countQualifier = 0;
                        for (int i = 0; i <= xPathArray.Length - 1; i++)
                        {
                            XmlNodeList xNodeList = xNodeSequence.SelectNodes(xPathArray[i]);
                            foreach (XmlNode xNode in xNodeList)
                            {
                                if (qualifierList.IndexOf(xNode.InnerText) != -1)
                                {
                                    countQualifier++;
                                }
                            }
                        }

                        if (countQualifier < 1)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                Constants.QUALIFIER, qualifierList);
                            isValid = false;
                        }

                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNodeSequence.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		CheckMandatoryQualifiers
        /// </method>
        /// <summary>
        ///		This method performs validation for fields to check for mandatory qualifiers.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Comma separated input references of the elements to be validated.
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the list of the qualifiers.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckMandatoryQualifiers(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath,
            string qualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckMandatoryQualifiers" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == qualifierList) throw new ArgumentNullException("qualifierList");


                int lengthxPath = 0;

                string qualifierListTemp = qualifierList;
                string qualifierListCompare = string.Empty;

                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                qualifierListTemp = qualifierListTemp + Constants.COMMA;
                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);

                lengthxPath = xPathArray.Length;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        qualifierList = qualifierListTemp;
                        qualifierListCompare = qualifierList;
                        for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                        {
                            XmlNodeList xList = xNodeSequence.SelectNodes(xPathArray[nCount].ToString());
                            if (xList.Count != 0)
                            {
                                isValid = CommonFunctions.HasValidMandatoryQualifiers(xDocument, xList, ref qualifierList, ref qualifierListCompare, errorCode, policyName, ruleName, errorObject);
                            }
                        }

                        // suriyan - 2/10/2006 - PreSharp warning 56056 - qualifierListCompare can be null... how?
                        //#pragma warning suppress 6506
                        if (qualifierListCompare.Length != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                Constants.QUALIFIER, qualifierListCompare);
                            isValid = false;
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNodeSequence.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }


        /// <method>
        ///		HasValidMandatoryQualifiers
        /// </method>
        /// <summary>
        ///		This method performs validation for fields with	mandatory qualifiers.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xList" type = "string">
        ///		Input reference of the list of elements to be validated.
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the list of the qualifiers.
        /// </param>
        /// <param name ="qualifierListCompare" type = "string">
        ///		Reference containing the list of the qualifiers to compare.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool HasValidMandatoryQualifiers(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            XmlNodeList xList,
            ref string qualifierList,
            ref string qualifierListCompare,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function HasValidMandatoryQualifiers" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            string strQualifier;
            try
            {

                if (xDocument == null ||
                    xList == null ||
                    xList.Count == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                if (null == qualifierListCompare) throw new ArgumentNullException("qualifierListCompare");
                if (null == qualifierList) throw new ArgumentNullException("qualifierList");

                XmlNode xRoot = xDocument.Document;

                foreach (XmlNode xNode in xList)
                {
                    if (xNode != null && xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        //Extract the value of the Qualifier
                        strQualifier = xNode.InnerText.ToString().Trim();

                        //Search for the Qualifier's value in the Qualifier list. If not present, report error
                        if (qualifierList.IndexOf(strQualifier) != -1)
                        {
                            //Remove the Qualifier value from the Qualifier's list.
                            strQualifier = strQualifier + Constants.COMMA;
                            qualifierListCompare = qualifierListCompare.Replace(strQualifier, Constants.BLANK);
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            (xNode != null && xNode.ParentNode != null ? xNode.ParentNode.Name : String.Empty),
                            Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule22
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 22.If field 12 contains the value 942, at least one field 34F must be present in the same repetitive sequence.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the first mandatory element of the sequence.
        /// </param>
        /// <param name ="xPathFloorLimitIndicator1" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathFloorLimitIndicator2" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="constantValue" type = "string">
        ///		Input containing the constant value.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule22(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathFloorLimitIndicator1,
            string xPathFloorLimitIndicator2,
            string constantValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule22" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool bln1Present = true;
            bool bln2Present = true;
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathFloorLimitIndicator1 == null ||
                    xPathFloorLimitIndicator1.Length == 0 ||
                    xPathFloorLimitIndicator2 == null ||
                    xPathFloorLimitIndicator2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                XmlNode xRoot = xDocument.Document;

                XmlNode xNode = xRoot.SelectSingleNode(xPathSequence);

                if (xNode != null)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        if (xRoot.LastChild.LastChild != null)
                        {
                            while (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0 || xNode.NextSibling != null)
                            {
                                if (xRoot.SelectSingleNode(xPathSequence) != null)
                                {
                                    if (xNode.InnerText.CompareTo(constantValue) == 0)
                                    {
                                        bln1Present = false;
                                        bln2Present = false;

                                        xNode = xNode.NextSibling;

                                        while ((xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) != 0)
                                            && (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0
                                            || xNode.NextSibling != null))
                                        {
                                            if (xRoot.SelectSingleNode(xPathFloorLimitIndicator1) != null)
                                            {
                                                if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathFloorLimitIndicator1).Name) == 0)
                                                {
                                                    bln1Present = true;
                                                }
                                            }
                                            if (xRoot.SelectSingleNode(xPathFloorLimitIndicator2) != null)
                                            {
                                                if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathFloorLimitIndicator2).Name) == 0)
                                                {
                                                    bln2Present = true;
                                                }
                                            }

                                            if ((xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0
                                                && xNode.NextSibling != null)
                                                || (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0))
                                            {
                                                xNode = xNode.NextSibling;
                                            }
                                        }

                                        if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) == 0)
                                        {
                                            if (bln1Present == false && bln2Present == false)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }
                                            bln1Present = true;
                                            bln2Present = true;
                                        }

                                    }
                                    else
                                    {
                                        xNode = xNode.NextSibling;

                                        while ((xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) != 0) && (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0 || xNode.NextSibling != null))
                                        {
                                            xNode = xNode.NextSibling;
                                            String str = xNode.InnerText;
                                        }
                                    }
                                }
                            }
                        }
                        if (xRoot.LastChild.LastChild != null)
                        {
                            if (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling == null)
                            {
                                if (xRoot.SelectSingleNode(xPathFloorLimitIndicator1) != null)
                                {
                                    if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathFloorLimitIndicator1).Name) == 0)
                                    {
                                        bln1Present = true;
                                    }
                                }
                                if (xRoot.SelectSingleNode(xPathFloorLimitIndicator2) != null)
                                {
                                    if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathFloorLimitIndicator2).Name) == 0)
                                    {
                                        bln2Present = true;
                                    }
                                }
                                if (bln1Present == false && bln2Present == false)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }

                            }
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule23
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 22.If field 12 contains the value 942, at least one field 34F must be present in the same repetitive sequence.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the first mandatory element of the sequence.
        /// </param>
        /// <param name ="xPathFloorLimitIndicator1" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathFloorLimitIndicator2" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule23(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathFloorLimitIndicator1,
            string xPathFloorLimitIndicator2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule23" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool bln1Present = false;
            bool bln2Present = false;
            bool isValid = true;
            string DCMark1 = string.Empty;
            string DCMark2 = string.Empty;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathFloorLimitIndicator1 == null ||
                    xPathFloorLimitIndicator1.Length == 0 ||
                    xPathFloorLimitIndicator2 == null ||
                    xPathFloorLimitIndicator2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                XmlNode xNode = xRoot.SelectSingleNode(xPathSequence);

                if (xNode != null)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        if (xRoot.LastChild.LastChild != null)
                        {
                            while (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0 || xNode.NextSibling != null)
                            {
                                if (xRoot.SelectSingleNode(xPathSequence) != null)
                                {
                                    while ((xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) != 0) && (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0 || xNode.NextSibling != null))
                                    {
                                        if (xRoot.SelectSingleNode(xPathFloorLimitIndicator1) != null)
                                        {
                                            if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathFloorLimitIndicator1).Name) == 0)
                                            {
                                                bln1Present = true;
                                                DCMark1 = xNode.InnerText.Substring(3, 1);
                                            }
                                        }
                                        if (xRoot.SelectSingleNode(xPathFloorLimitIndicator2) != null)
                                        {
                                            if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathFloorLimitIndicator2).Name) == 0)
                                            {
                                                bln2Present = true;
                                                DCMark2 = xNode.InnerText.Substring(3, 1);
                                            }
                                        }

                                        if ((xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling != null)
                                            || (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0))
                                        {
                                            xNode = xNode.NextSibling;
                                        }

                                    }
                                    if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) == 0)
                                    {
                                        if (bln1Present == false && bln2Present == true)
                                        {
                                            if (DCMark2.CompareTo(Constants.CREDIT) == 0 || DCMark2.CompareTo(Constants.DEBIT) == 0)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }

                                        }
                                        if (bln1Present == true && bln2Present == false)
                                        {
                                            if (DCMark1.CompareTo(Constants.DEBIT) == 0 || DCMark1.CompareTo(Constants.CREDIT) == 0)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }
                                        }
                                        if (bln1Present == true && bln2Present == true)
                                        {
                                            if (DCMark1.CompareTo(Constants.DEBIT) != 0 || DCMark2.CompareTo(Constants.CREDIT) != 0)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }
                                        }
                                        xNode = xNode.NextSibling;
                                        bln1Present = false;
                                        bln2Present = false;
                                    }
                                }
                            }

                            if (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling == null)
                            {
                                if (xRoot.SelectSingleNode(xPathFloorLimitIndicator1) != null)
                                {
                                    if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathFloorLimitIndicator1).Name) == 0)
                                    {
                                        bln1Present = true;
                                        DCMark1 = xNode.InnerText.Substring(3, 1);
                                    }
                                }
                                if (xRoot.SelectSingleNode(xPathFloorLimitIndicator2) != null)
                                {
                                    if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathFloorLimitIndicator2).Name) == 0)
                                    {
                                        bln2Present = true;
                                        DCMark2 = xNode.InnerText.Substring(3, 1);
                                    }
                                }

                                if (bln1Present == true && bln2Present == false)
                                {
                                    if (DCMark1.CompareTo(Constants.DEBIT) == 0 || DCMark1.CompareTo(Constants.CREDIT) == 0)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                    }
                                }
                                if (bln1Present == false && bln2Present == true)
                                {
                                    if (DCMark2.CompareTo(Constants.CREDIT) == 0 || DCMark2.CompareTo(Constants.DEBIT) == 0)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                    }
                                }
                                if (bln1Present == true && bln2Present == true)
                                {
                                    if (DCMark1.CompareTo(Constants.DEBIT) != 0 || DCMark2.CompareTo(Constants.CREDIT) != 0)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTSRG2001NetworkRule109
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 109.Field 37S may only be present in a repetitive sequence if field 34a is present within the
        ///		same sequence and contains the number of days accrued
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the first mandatory element of the sequence.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of the element 37S to be validated.
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of the element 34(option1) to be validated.
        /// </param>
        /// <param name ="xPath3" type = "string">
        ///		Input reference of the element 34(option2) to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule109(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence,
        //    string xPath1,
        //    string xPath2,
        //    string xPath3,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    bool bln37SPresent = false;
        //    bool bln34Present = false;
        //    bool isValid	  = true;
        //    int lastChildFlag = 0;

        //    if(xDocument == null ||
        //        xPathSequence == null ||
        //        xPathSequence.Length == 0 ||
        //        xPath1 == null ||
        //        xPath1.Length == 0 ||
        //        xPath2 == null ||
        //        xPath2.Length == 0 ||
        //        xPath3 == null ||
        //        xPath3.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    XmlNode xRoot = xDocument.Document;

        //    XmlNode xNode = xRoot.SelectSingleNode(xPathSequence);

        //    if(xNode != null)
        //    {
        //        if(xNode.InnerText != null && xNode.InnerText.Length != 0)
        //        {
        //            if(xRoot.LastChild.LastChild != null)
        //            {
        //                while(xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0 || xNode.NextSibling != null)
        //                {
        //                    if(xRoot.SelectSingleNode(xPathSequence) != null)
        //                    {
        //                        while(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) != 0 && lastChildFlag <= 1 )
        //                        {
        //                            if(xRoot.SelectSingleNode(xPath1) != null)
        //                            {
        //                                if(xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath1).Name) == 0)
        //                                {
        //                                    bln37SPresent = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath2) != null)
        //                            {
        //                                if((xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath2).Name) == 0)&& (xNode.FirstChild.FirstChild.Name.CompareTo(Constants.NUMBER)) == 0)
        //                                {
        //                                    bln34Present = true;
        //                                }
        //                            }
        //                            if(xRoot.SelectSingleNode(xPath3) != null)
        //                            {
        //                                if((xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath3).Name) == 0)&& (xNode.FirstChild.Name.CompareTo(Constants.NUMBER)) == 0)
        //                                {
        //                                    bln34Present = true;
        //                                }
        //                            }
        //                            if((xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling != null)||(xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name))!= 0)
        //                            {
        //                                xNode = xNode.NextSibling ;
        //                            }
        //                            if(xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling == null)
        //                            {
        //                                lastChildFlag ++;
        //                            }
        //                            if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) == 0)
        //                            {
        //                                if(bln37SPresent == true && bln34Present == false)
        //                                {
        //                                    errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                                    isValid = false;
        //                                }
        //                                bln37SPresent = false;
        //                                bln34Present = false;
        //                            }
        //                        }
        //                        if((xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling != null)||(xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0))
        //                        {
        //                            xNode = xNode.NextSibling ;
        //                        }
        //                    }
        //                }
        //                if(bln37SPresent == true && bln34Present == false)
        //                {
        //                    errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                    isValid = false;
        //                }
        //                bln37SPresent=false;
        //                bln34Present=false;
        //            }
        //        }
        //        else
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                xNode.ParentNode.Name, Constants.NOCONTENT);
        //            isValid = false;
        //        }
        //    }
        //    return isValid;

        //}

        /// <method>
        ///	SWIFTNetworkRule287
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 287.The 19A Amount fields
        ///		enumerated cannot occur in more than one occurrence of Sequence E3.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element 37S to be validated.
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the list of the qualifiers.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule287(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string qualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule287" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //Variables used
            string qualifierListHold = qualifierList + Constants.COMMA;
            string tempQualifierList = qualifierListHold;
            bool isValidQualifier = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //Check for Number of occurences of the field in the input instance
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                if (xList.Count != 0)
                {
                    qualifierList = qualifierListHold;
                    tempQualifierList = qualifierList;

                    //Calling Overloaded HasValidMultipleQualifiers (2)
                    isValidQualifier = CommonFunctions.HasValidMultipleQualifiers(xDocument, xList, ref qualifierList,
                        ref tempQualifierList, errorCode, policyName, ruleName,
                        messageType, conditionalRuleName, conditionalRuleNumber, errorObject);
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValidQualifier;
        }


        /// <method>
        ///		CheckQualifierOccurence
        /// </method>
        /// <summary>
        ///		This method performs validation for fields with	multiple qualifiers
        ///		having 'or' condition and out of which only one should occur.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence which contains the elements to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the elements to be validated.
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the list of the qualifiers.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckQualifierOccurence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath,
            string qualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckQualifierOccurence" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int lengthxPath = 0;
            string code = string.Empty;
            try
            {

                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                if (null == qualifierList) throw new ArgumentNullException("qualifierList");

                //Initialise a string array to hold the xPath values
                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);
                lengthxPath = xPathArray.Length;

                XmlNode xRoot = xDocument.Document;

                //Select all the occurences of the sequence having xPath XPathSequence
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    int count = 0;

                    //Check that the sequence doesn't have NULL data
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                        {
                            //Select all the occurences of the field having xPath present in the array
                            XmlNodeList xList = xNodeSequence.SelectNodes(xPathArray[nCount].ToString());
                            foreach (XmlNode xNode in xList)
                            {
                                code = xNode.InnerText;

                                //Search for the Qualifier's value in the Qualifier list.
                                if (qualifierList.IndexOf(code) != -1)
                                {
                                    count++;
                                }

                                //If the Qualifier in the code List occurs more than once, throw an error
                                if (count > 1)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, xNode.Name, xNode.InnerText);
                                    isValid = false;
                                    break;
                                }
                            }
                        }
                    }



                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, xNodeSequence.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule40
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 40.The currency code must be the same for each occurrence of the indicated fields within each repetitive sequence.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the first mandatory element of the sequence.
        /// </param>
        /// <param name ="xPathFloorLimitIndicator1" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathFloorLimitIndicator2" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule40(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathFloorLimitIndicator1,
            string xPathFloorLimitIndicator2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule40" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool bln1Present = false;
            bool bln2Present = false;
            bool isValid = true;
            string currency1 = string.Empty;
            string currency2 = string.Empty;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathFloorLimitIndicator1 == null ||
                    xPathFloorLimitIndicator1.Length == 0 ||
                    xPathFloorLimitIndicator2 == null ||
                    xPathFloorLimitIndicator2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                XmlNode xNode = xRoot.SelectSingleNode(xPathSequence);

                if (xNode != null)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        if (xRoot.LastChild.LastChild != null)
                        {
                            while (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0 || xNode.NextSibling != null)
                            {
                                if (xRoot.SelectSingleNode(xPathSequence) != null)
                                {
                                    while ((xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) != 0) && (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0 || xNode.NextSibling != null))
                                    {
                                        if (xRoot.SelectSingleNode(xPathFloorLimitIndicator1) != null)
                                        {
                                            if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathFloorLimitIndicator1).Name) == 0)
                                            {
                                                bln1Present = true;
                                                currency1 = xNode.FirstChild.InnerText;
                                            }
                                        }
                                        if (xRoot.SelectSingleNode(xPathFloorLimitIndicator2) != null)
                                        {
                                            if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathFloorLimitIndicator2).Name) == 0)
                                            {
                                                bln2Present = true;
                                                currency2 = xNode.FirstChild.InnerText;
                                            }
                                        }
                                        if ((xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling != null)
                                            || (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0))
                                        {
                                            xNode = xNode.NextSibling;
                                        }
                                    }
                                    if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) == 0)
                                    {
                                        if (bln1Present == true && bln2Present == true)
                                        {
                                            if (currency1.CompareTo(currency2) != 0)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }
                                        }
                                        xNode = xNode.NextSibling;
                                        bln1Present = false;
                                        bln2Present = false;
                                    }
                                }
                            }
                            if (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0 && xNode.NextSibling == null)
                            {
                                if (xRoot.SelectSingleNode(xPathFloorLimitIndicator1) != null)
                                {
                                    if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathFloorLimitIndicator1).Name) == 0)
                                    {
                                        bln1Present = true;
                                        currency1 = xNode.FirstChild.InnerText;
                                    }
                                }
                                if (xRoot.SelectSingleNode(xPathFloorLimitIndicator2) != null)
                                {
                                    if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathFloorLimitIndicator2).Name) == 0)
                                    {
                                        bln2Present = true;
                                        currency2 = xNode.FirstChild.InnerText;
                                    }
                                }
                                if (bln1Present == true && bln2Present == true)
                                {
                                    if (currency1.CompareTo(currency2) != 0)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule24
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 24.If field 86 is
        ///		present in any occurrence of the repetitive sequence, it must be preceded by a field 61.
        ///		In addition, if field 86 is present, it must be present on the
        ///		same page (message) of the statement as the related field 61.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathInformationToAccountOwner1" type = "string">
        ///		Input reference of the first mandatory element of the sequence.
        /// </param>
        /// <param name ="xPathStatementLine" type = "string">
        ///		Input reference of the element to be validated.
        ///	</param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule24(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathInformationToAccountOwner1,
            string xPathStatementLine,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule24" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathInformationToAccountOwner1 == null ||
                    xPathInformationToAccountOwner1.Length == 0 ||
                    xPathStatementLine == null ||
                    xPathStatementLine.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xNodeList = xRoot.SelectNodes(xPathInformationToAccountOwner1);

                if (xRoot.SelectSingleNode(xPathStatementLine) != null)
                {
                    foreach (XmlNode xNode in xNodeList)
                    {
                        if (xNode.PreviousSibling != null && !(string.Compare(messageType, "MT942", true, CultureInfo.InvariantCulture) == 0 && xNode.NextSibling == null))
                        {
                            if (xNode.PreviousSibling.Name.CompareTo(xRoot.SelectSingleNode(xPathStatementLine).Name) != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                    }
                }
                else
                {
                    XmlNode xNode = xRoot.SelectSingleNode(xPathInformationToAccountOwner1);
                    if (xNode != null && !(string.Compare(messageType, "MT942", true, CultureInfo.InvariantCulture) == 0 && xNode.NextSibling == null))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule1
        /// </method>
        /// <summary>
        ///		The amount in field 19 must equal the sum of the amounts in all occurrences of field 32B
        ///		or 34A.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSumOfAmounts" type = "string">
        ///		Input reference of 'Amount' Element of Tag 19.
        /// </param>
        /// <param name ="xPathAmount" type = "string">
        ///		Input reference of the element 32B to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the messageType.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber.
        /// </param>
        /// <param name ="errorObj" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule1(TypedXmlDocument xDocument,
            string xPathSumOfAmounts,
            string xPathAmount,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule1" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == errorObj) throw new ArgumentNullException("errorObj");


                if (xDocument != null)
                {
                    XmlNode xRoot = xDocument.Document;

                    XmlNodeList xListOfAmounts = xRoot.SelectNodes(xPathAmount);
                    XmlNode xSumOfAmounts = xRoot.SelectSingleNode(xPathSumOfAmounts);

                    if (xSumOfAmounts != null)
                    {
                        decimal sumOfAmounts = Convert.ToDecimal(xSumOfAmounts.InnerText.Replace(Constants.COMMA, decimalSeparator), CultureInfo.InvariantCulture);
                        decimal dAmount = 0.0M;
                        decimal dSum = 0.0M;

                        foreach (XmlNode xNodeAmount in xListOfAmounts)
                        {
                            if (xNodeAmount.InnerText != null)
                            {
                                dAmount = Convert.ToDecimal(xNodeAmount.InnerText.Substring(3).Replace(Constants.COMMA, decimalSeparator), CultureInfo.InvariantCulture);
                                dSum = dSum + dAmount;
                            }
                        }
                        if (sumOfAmounts != dSum)
                        {
                            errorObj.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
                else
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule279
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 279, i.e.,
        ///		This method checks for a tag existence in a particular sequence with the desired
        ///		value of qualifier and indicator provided the datasource scheme does not exists,
        ///		if it exists then in the same given sequence it checks that the dependent desired
        ///		tag having the desired value must exists at least once.
        ///		For eg.:
        ///			 If in Sequence D the tag 22F exists with the following fields and values,
        ///				Qualifier	=	CAOP
        ///				Indicator	=	SPLI, and
        ///				Datasource	=	does not exists (taken for granted)
        ///			Then
        ///				in the same Sequence D the tag 70E must exists at least once with the
        ///				following fields and values,
        ///					Qualifier	=	INST
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the sequence
        ///		e.g.:	//Sequence D
        /// </param>
        /// <param name ="xPathConditionalTag" type = "string">
        ///		Input containing the xPath of the Tag on which the condition to evaluate
        ///		e.g.: ./Indicator_D_22F
        /// </param>
        /// <param name ="conditionalTagQualifierValue" type = "string">
        ///		Input containing the value of a Qualifier for the tag to evaluate
        ///		e.g.:	CAOP
        /// </param>
        /// <param name ="conditionalTagIndicatorValue" type = "string">
        ///		Input containing the value of a Indicator for the tag to evaluate
        ///		e.g.:	SPLI
        /// </param>
        /// <param name ="xPathSearchTag" type = "string">
        ///		Input containing the xPath of a tag need to search for existence in a given sequence
        ///		e.g.:	./Narrative_D_70E
        /// </param>
        /// <param name ="searchTagQualifierValue" type = "string">
        ///		Input containing the value of a Qualifier for the tag to search
        ///		e.g.:	INST
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the messageType.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber.
        /// </param>
        /// <param name ="errorObj" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule279(TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathConditionalTag,
            string conditionalTagQualifierValue,
            string conditionalTagIndicatorValue,
            string xPathSearchTag,
            string searchTagQualifierValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule279" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathConditionalTag == null ||
                    xPathConditionalTag.Length == 0 ||
                    conditionalTagQualifierValue == null ||
                    conditionalTagQualifierValue.Length == 0 ||
                    conditionalTagIndicatorValue == null ||
                    conditionalTagIndicatorValue.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    xPathSearchTag == null ||
                    xPathSearchTag.Length == 0 ||
                    searchTagQualifierValue == null ||
                    searchTagQualifierValue.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObj == null)
                {
                    return false;
                }
                // get the root node of the xml document
                XmlNode xRoot = xDocument.Document;

                // Concatenate the qualifier and indicator into the given xPath
                //	e.g.: "//SequenceD/Indicator_D_22F[Qualifier='CAOP' and Indicator='SPLI' and not(descendant::DataSourceScheme)]"
                string xPathCondTag = xPathConditionalTag + Constants.OPENSQUAREBRACKET + Constants.QUALIFIER + Constants.EQUAL + Constants.SINGLEQUOTE + conditionalTagQualifierValue + Constants.SINGLEQUOTE + Constants.SPACE + Constants.AND + Constants.SPACE + Constants.INDICATOR + Constants.EQUAL + Constants.SINGLEQUOTE + conditionalTagIndicatorValue + "' and not(descendant::" + Constants.DATASOURCESCHEME + ")]";

                // get the list of all the sequences satisfying the xpath for the sequence
                // i.e., getting the sequence node for which the validation is to perform
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        XmlNodeList xListConditionalTags = xNodeSequence.SelectNodes(xPathCondTag);
                        // if at least one conditional tag found then find the required tag with the specified qualifier
                        // e.g.: "//SequenceD/Narrative_D_70E[Qualifier='INST']"
                        // if the required tag not found raise an error
                        if (xListConditionalTags.Count != 0)
                        {
                            string xPathConcatSearchTag = xPathSearchTag + Constants.OPENSQUAREBRACKET + Constants.QUALIFIER + Constants.EQUAL + Constants.SINGLEQUOTE + searchTagQualifierValue + Constants.SINGLEQUOTE + Constants.CLOSESQUAREBRACKET;
                            XmlNodeList xListSearchTags = xNodeSequence.SelectNodes(xPathConcatSearchTag);
                            if (xListSearchTags.Count == 0)
                            {
                                errorObj.AddError(errorCode, policyName, ruleName,
                                    xNodeSequence.Name, Constants.NOCONTENT);
                                isValid = false;
                            }
                        }
                    }
                    else
                    {
                        errorObj.AddError(errorCode, policyName, ruleName,
                            xNodeSequence.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///	SWIFTNetworkRule280_SRG2006
        /// </method>
        /// <summary>
        /// In each occurrence of sequence D, E and E1, if field :92J::TAXE is present then
        /// in the same occurrence the field :92F::GRSS should be present (Error code(s): E80).
        /// </summary>
        /// <param name="xDocument">
        /// Input Reference to XML document
        /// </param>
        /// <param name="xPathSequenceList">
        /// Input Reference to the Sequences in which the check is to be made.
        /// </param>
        /// <param name="xPathList1">
        /// Input Reference to List of Tags in which the check is to be made for the existing field.
        /// </param>
        /// <param name="xPathQualifier1">
        /// Input xPath of Qualifier
        /// </param>
        /// <param name="qualifier92a1">
        /// Qualifier codelist for 92a used for checking the particular constant value in Field :92J
        /// </param>
        /// /// <param name="xPathList2">
        /// Input Reference to List of Tags which is to be verified for its existence if :92J::TAXE is present
        /// </param>
        /// <param name="xPathQualifier2">
        /// Input xPath of Qualifier
        /// </param>
        /// <param name="qualifier92a2">
        /// Qualifier codelist for 92a used for checking the particular constant value in Field :92F
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        /// 	The Message Type that callls the function
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	ConditionalRule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	ConditionalRule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule280_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceList,
            string xPathList1,
            string xPathQualifier1,
            string qualifier92a1,
            string xPathList2,
            string xPathQualifier2,
            string qualifier92a2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule280_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            //errorcount used for keeping track of the final value to be returned
            int errorCount = 0;
            try
            {
                if (xDocument == null ||
                    xPathSequenceList == null ||
                    xPathSequenceList.Length == 0 ||
                    xPathList1 == null ||
                    xPathList1.Length == 0 ||
                    xPathQualifier1 == null ||
                    xPathQualifier1.Length == 0 ||
                    xPathList2 == null ||
                    xPathList2.Length == 0 ||
                    xPathQualifier2 == null ||
                    xPathQualifier2.Length == 0 ||
                    errorObject == null)
                {
                    isValid = false;
                }
                else
                {
                    if (null == qualifier92a1 || null == qualifier92a2) throw new ArgumentNullException("qualifier92a");

                    int lengthxPath = 0;
                    int lengthxPathSequence = 0;
                    int lengthxPath_Check = 0;

                    // Splitting the Sequences
                    string[] xPathSequenceArray = xPathSequenceList.Split(Constants.CHRCOMMA);
                    lengthxPathSequence = xPathSequenceArray.Length;

                    // Splitting the Xpath Field List1
                    string[] xPathArray = xPathList1.Split(Constants.CHRCOMMA);
                    lengthxPath = xPathArray.Length;

                    // Splitting the Xpath Field List2
                    string[] xPathArray_Check = xPathList2.Split(Constants.CHRCOMMA);
                    lengthxPath_Check = xPathArray_Check.Length;

                    XmlNode xRoot = xDocument.Document;
                    for (int i = 0; i <= lengthxPathSequence - 1; i++)
                    {
                        //Set isValid = true for each sequence
                        isValid = true;

                        //Selecting the nodes on the base of the sequence
                        XmlNodeList xSequenceList = xRoot.SelectNodes(xPathSequenceArray[i].ToString());

                        foreach (XmlNode xSequenceNode in xSequenceList)
                        {
                            for (int j = 0; j <= lengthxPath - 1; j++)
                            {
                                // Searching for the nodes for the field to be checked (:92J)
                                XmlNodeList xList = xSequenceNode.SelectNodes(xPathArray[j].ToString());
                                foreach (XmlNode xNode in xList)
                                {
                                    // Getting the value of the sub-field (./Qualifier)
                                    XmlNode xNodeQualifier = xNode.SelectSingleNode(xPathQualifier1);

                                    if (xNodeQualifier != null && xNodeQualifier.InnerText != null
                                        && xNodeQualifier.InnerText.ToString().IndexOf(qualifier92a1) != -1)
                                    {
                                        # region "Verification for Field :92F::GRSS"
                                        for (int k = 0; k <= lengthxPath_Check - 1; k++)
                                        {
                                            // Searching for the nodes for the field to be checked (:92F)
                                            XmlNodeList xList_Check = xSequenceNode.SelectNodes(xPathArray_Check[k].ToString());

                                            if (xList_Check != null && xList_Check.Count > 0)
                                            {
                                                foreach (XmlNode xNode_Check in xList_Check)
                                                {
                                                    // Getting the value of the sub-field. (./Qualifier)
                                                    XmlNode xNodeQualifier_Check = xNode_Check.SelectSingleNode(xPathQualifier2.ToString());

                                                    // Comparing for the value of the sub-field with qualifier92a2   													
                                                    if (xNodeQualifier_Check != null && xNodeQualifier_Check.InnerText != null &&
                                                        xNodeQualifier_Check.InnerText.ToString().IndexOf(qualifier92a2) != -1)
                                                    {
                                                        // Setting  isValid = True to indicate that the value has been found
                                                        isValid = true;
                                                        //Setting k to the max length-1 so that the loop doesn't 
                                                        // check for other values then as the value has to be present
                                                        // atleast once
                                                        k = lengthxPath_Check - 1;
                                                        // breaking to exit the loop
                                                        break;
                                                    }
                                                    isValid = false;
                                                }
                                            }
                                            else
                                            {
                                                // Setting isValid=false when the node searched for was not found
                                                isValid = false;
                                            }
                                        }
                                        # endregion "Verification for Field :92F::GRSS"
                                    }
                                }
                            }
                        }
                        if (!isValid)
                        {
                            // To add on error for each sequence 
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            errorCount += 1;
                        }
                    }
                }
                // Chceking for the value of error count, if this count was incremented then 
                // isvalid is set to false.
                if (errorCount != 0)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        /// SWIFTSRG2001NetworkRule112
        /// </method>
        /// <summary>
        /// 	This function performs Conditional Rule D12 Validation(for message MT583) which ensures that , field 83a must be present in either SequenceA or
        /// 	every occurrence of the repetitive sequence B
        ///
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPathMandatory" type = "string">
        /// 	Input containing the xpath of Tag 35B, first mandatory non-repetitive tag of SequenceB.
        /// </param>
        /// <param name="xPathTagSequenceA" type = "string">
        /// 	Input containing the xpath of Tag 83A of SequenceA,Input containing the xpath of Tag 83C of SequenceA,Input containing the xpath of Tag 83D of SequenceA.
        /// </param>
        /// <param name="xPathTagSequenceB" type = "string">
        /// 	Input containing the xpath of Tag 83A of SequenceB,Input containing the xpath of Tag 83C of SequenceB,Input containing the xpath of Tag 83D of SequenceB.
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Inutput containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule112(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathMandatory,
        //    string xPathTagSequenceA,
        //    string xPathTagSequenceB,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    bool isValid = true;
        //    int lengthxPathTagSequenceA = 0;
        //    int lengthxPathTagSequenceB= 0;
        //    bool exists = false;

        //    if(xDocument == null ||
        //        xPathMandatory == null ||
        //        xPathMandatory.Length == 0 ||
        //        xPathTagSequenceA == null ||
        //        xPathTagSequenceB == null ||
        //        xPathTagSequenceA.Length == 0 ||
        //        xPathTagSequenceB.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    string[] xPathTagSequenceAArray = xPathTagSequenceA.Split(Constants.CHRCOMMA);
        //    string[] xPathTagSequenceBArray = xPathTagSequenceB.Split(Constants.CHRCOMMA);
        //    lengthxPathTagSequenceA = xPathTagSequenceAArray.Length;
        //    lengthxPathTagSequenceB = xPathTagSequenceBArray.Length;

        //    int countSeqBRepetition = 0;
        //    int countTag83aRep = 0;

        //    XmlNode xRoot = xDocument.Document;

        //    for(int count = 0;count <= lengthxPathTagSequenceA - 1;count++)
        //    {
        //        if(xRoot.SelectSingleNode(xPathTagSequenceAArray[count]) != null)
        //        {
        //            exists = true;
        //        }
        //    }

        //    XmlNodeList xListSequence = xRoot.SelectNodes(xPathMandatory);
        //    countSeqBRepetition = xListSequence.Count;
        //    for(int nCount = 0;nCount <= lengthxPathTagSequenceB - 1;nCount++)
        //    {
        //        XmlNodeList xListTag = xRoot.SelectNodes(xPathTagSequenceBArray[nCount]);
        //        countTag83aRep = countTag83aRep + xListTag.Count;
        //    }
        //    if((exists == false) && (countSeqBRepetition != countTag83aRep))
        //    {
        //        errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //        isValid = false;
        //    }
        //    if((exists == true) && (countTag83aRep != 0) && (countSeqBRepetition != countTag83aRep))
        //    {
        //        errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //        isValid = false;
        //    }

        //    return isValid;
        //}

        /// <method>
        /// SWIFTSRG2001NetworkRule112
        /// </method>
        /// <summary>
        /// 	This function performs Conditional Rule D12 Validation(for messages MT570 and MT573) which ensures that , field 83a must be present in either SequenceA or
        /// 	every occurrence of the repetitive sequence B
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPathOptional" type = "string">
        /// 	Input containing the xpath of Tag 35B, first mandatory non-repetitive tag of SequenceB.
        /// </param>
        /// <param name="xPathMandatory" type = "string">
        /// 	Input containing the xpath of Tag 35B, first mandatory non-repetitive tag of SequenceB.
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Input containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Input containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule112(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathOptional,
        //    string xPathMandatory,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{

        //    if(xDocument == null ||
        //        xPathOptional == null ||
        //        xPathOptional.Length == 0 ||
        //        xPathMandatory == null ||
        //        xPathMandatory.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    if (null == conditionalRuleName) throw new ArgumentNullException("conditionalRuleName");


        //    XmlNode xRoot = xDocument.Document;
        //    bool isValid = true;

        //    int nCountSeqBRepetition = 0;
        //    int nCountSeqCRepetition = 0;

        //    char[] chrArray = Constants.COMMA.ToCharArray();

        //    // Split string based on ","
        //    string [] xPathSeqRepetition = xPathMandatory.Split(chrArray);
        //    string [] xPathOptRepetition = xPathOptional.Split(chrArray);

        //    //Multiple Conditional Rules C1,C3,C4,C5
        //    string [] xConditionalRuleName = conditionalRuleName.Split(chrArray);
        //    int count = 0;
        //    XmlNodeList [] xListMandatory = new XmlNodeList[xPathSeqRepetition.Length];
        //    foreach (string xPath in xPathSeqRepetition)
        //    {
        //        xListMandatory[count] = xRoot.SelectNodes(xPath);
        //        count++;
        //    }

        //    count = 0;
        //    XmlNodeList [] xListOptional = new XmlNodeList[xPathOptRepetition.Length];
        //    foreach (string xPath in xPathOptRepetition)
        //    {
        //        xListOptional[count] = xRoot.SelectNodes(xPath);
        //        count++;
        //    }
        //    //No of Repetitive SequenceB is stored in nCountSeqBRepetition

        //    foreach(XmlNode xNode in xListMandatory[0])
        //    {
        //        if(xNode.InnerText != null && xNode.InnerText.Length != 0)
        //        {
        //            nCountSeqBRepetition++;
        //        }
        //        else
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                xNode.ParentNode.Name, Constants.NOCONTENT);
        //            isValid = false;
        //        }
        //    }

        //    //No of Repetitive SequenceC is stored in nCountSeqCRepetition
        //    foreach(XmlNode xNode in xListMandatory[1])
        //    {
        //        if(xNode.InnerText != null && xNode.InnerText.Length != 0)
        //        {
        //            nCountSeqCRepetition++;
        //        }
        //        else
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                xNode.ParentNode.Name, Constants.NOCONTENT);
        //            isValid = false;
        //        }
        //    }
        //    // When 83A is present in both Sequence B and C ( Error code D12 with Condition C3)
        //    if((xListOptional[2].Count != 0 || xListOptional[3].Count != 0)&&(xListOptional[4].Count != 0 || xListOptional[5].Count != 0))
        //    {
        //        errorObject.AddError(errorCode,policyName,ruleName,messageType,xConditionalRuleName[1],conditionalRuleNumber);
        //        isValid = false;
        //    }
        //    if (isValid == true)
        //    {
        //        // When 83A is present in neither Sequence B and C ( Error code D12 with Condition C1)
        //        if( ( (xListOptional[0].Count == 0) && (xListOptional[1].Count == 0) ) && ( (xListOptional[2].Count == 0) && (xListOptional[3].Count == 0) )&&( (xListOptional[4].Count == 0) && (xListOptional[5].Count == 0) ))
        //        {
        //            errorObject.AddError(errorCode,policyName,ruleName,messageType,xConditionalRuleName[0],conditionalRuleNumber);
        //            isValid = false;
        //        }
        //        else if (nCountSeqBRepetition > 1)
        //        {
        //            if(nCountSeqBRepetition == xListOptional[2].Count || nCountSeqBRepetition == xListOptional[3].Count)
        //            {
        //            }
        //            else
        //            {
        //                // ( Error code D12 with Condition C4)
        //                errorObject.AddError(errorCode,policyName,ruleName,messageType,xConditionalRuleName[2],conditionalRuleNumber);
        //                isValid = false;
        //            }
        //        }
        //        else if (nCountSeqCRepetition > 1)
        //        {
        //            if(nCountSeqCRepetition == xListOptional[4].Count || nCountSeqCRepetition == xListOptional[5].Count)
        //            {
        //            }
        //            else
        //            {
        //                // ( Error code D12 with Condition C5)
        //                errorObject.AddError(errorCode,policyName,ruleName,messageType,xConditionalRuleName[3],conditionalRuleNumber);
        //                isValid = false;
        //            }

        //        }
        //    }
        //    return isValid;
        //}


        /// <method>
        ///		IsValidNumberOfDays
        /// </method>
        /// <summary>
        ///		This method performs validation for the valid Function when Number of Days is Present
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathField" type = "string">
        ///		Input reference of the field element which need to be validated.
        /// </param>
        /// <param name ="codeListNumberOfDays" type = "string">
        ///		Reference containing the list of the codes.
        /// </param>
        /// <param name ="codeListFunction" type = "string">
        ///		Reference containing the list of the codes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidNumberOfDays(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathField,
            string codeListNumberOfDays,
            string codeListFunction,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidNumberOfDays" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            bool exists = true;
            string NumberOfDays = string.Empty;
            string Function = string.Empty;
            try
            {
                if (xDocument == null ||
                    xPathField == null ||
                    xPathField.Length == 0 ||
                    codeListNumberOfDays == null ||
                    codeListFunction == null ||
                    codeListNumberOfDays.Length == 0 ||
                    codeListFunction.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListField = xRoot.SelectNodes(xPathField);

                foreach (XmlNode xNode in xListField)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        NumberOfDays = xNode.InnerText.Substring(0, 2);
                        if ((codeListNumberOfDays.IndexOf(NumberOfDays)) == -1 || (NumberOfDays == Constants.BLANK))
                        {
                            exists = false;
                        }

                        if (exists == true)
                        {
                            Function = xNode.InnerText.Substring(2).Trim();

                            if (Function.CompareTo(codeListFunction) != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, xNode.ParentNode.Name, xNode.InnerText);

                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		IsValidCode
        /// </method>
        /// <summary>
        ///		This method performs validation for fields where validation is,if Qualifier is a specified value and
        ///		if Data Source Scheme is not present,
        ///		indicator must contain one of the codes in the string array(Error code 'Not Defined').
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathField" type = "string">
        ///		Input reference of the field element which should not be present to be validated.
        /// </param>
        /// <param name ="xPathCode" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the Qualifier.
        /// </param>
        /// <param name ="codeList" type = "string">
        ///		Reference containing the list of the codes.
        /// </param>
        /// <param name ="qualifier" type = "string">
        ///		Reference containing the qualifier.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidCode(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathField,
            string xPathCode,
            string xPathQualifier,
            string qualifier,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCode" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {

                string code = string.Empty;
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathField == null ||
                    xPathField.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTag = xRoot.SelectNodes(xPathTag);

                foreach (XmlNode xNode in xListTag)
                {
                    if (xNode.SelectSingleNode(xPathQualifier) != null)
                    {
                        if (xNode.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifier) == 0)
                        {
                            //check if the node has an DataSourceScheme tag
                            XmlNode xNodeField = xNode.SelectSingleNode(xPathField);

                            //Since the DataSourceScheme is not present, check for validity of code
                            if (xNodeField == null)
                            {
                                if (xNode.SelectSingleNode(xPathCode) != null)
                                {
                                    code = xNode.SelectSingleNode(xPathCode).InnerText;
                                    //Check for the presence of the code value in the codelist. If not present report error
                                }
                                if ((codeList.IndexOf(code) == -1) || (code == Constants.BLANK))
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        xNode.Name, code);
                                    isValid = false;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule83
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 83.Either Field 23 or25 Should be present in any Repetitive Sequence.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the first mandatory element of the sequence.
        /// </param>
        /// <param name ="xPathField23" type = "string">
        ///		Input reference of the element 23
        /// </param>
        /// <param name ="xPathField25" type = "string">
        ///		Input reference of the element 25
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule83(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathField23,
            string xPathField25,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule83" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathField23 == null ||
                    xPathField23.Length == 0 ||
                    xPathField25 == null ||
                    xPathField25.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                string field23Name = string.Empty;
                string field25Name = string.Empty;

                if (xRoot.SelectSingleNode(xPathField23) != null)
                    field23Name = xRoot.SelectSingleNode(xPathField23).Name;
                if (xRoot.SelectSingleNode(xPathField25) != null)
                    field25Name = xRoot.SelectSingleNode(xPathField25).Name;

                if (xRoot.SelectSingleNode(xPathField23) == null && xRoot.SelectSingleNode(xPathField25) == null)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
                else
                {
                    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                    foreach (XmlNode xNodeSequence in xListSequence)
                    {
                        if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                        {
                            if (xNodeSequence.PreviousSibling != null)
                            {
                                if ((xNodeSequence.PreviousSibling.Name.CompareTo(field25Name) == 0))
                                {
                                    if (xNodeSequence.PreviousSibling.PreviousSibling != null)
                                    {
                                        if (xNodeSequence.PreviousSibling.PreviousSibling.Name.CompareTo(field23Name) == 0)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isValid = false;
                                        }
                                    }
                                }
                                else if ((xNodeSequence.PreviousSibling.Name.CompareTo(field23Name) != 0))
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		CheckSingleMandatoryQualifier
        /// </method>
        /// <summary>
        ///		This method performs validation for fields with	multiple qualifiers to check
        ///		for a single mandatory qualifiers.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Comma separated input references of the elements to be validated.
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the list of the qualifiers.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckSingleMandatoryQualifier(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath,
            string qualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckSingleMandatoryQualifier" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                int countQualifier = 0;

                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                if (null == qualifierList) throw new ArgumentNullException("qualifierList");

                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        countQualifier = 0;
                        for (int i = 0; i <= xPathArray.Length - 1; i++)
                        {
                            XmlNodeList xNodeList = xNodeSequence.SelectNodes(xPathArray[i]);
                            foreach (XmlNode xNode in xNodeList)
                            {
                                if (qualifierList.IndexOf(xNode.InnerText) != -1)
                                {
                                    countQualifier++;
                                }
                            }
                        }

                        if (countQualifier != 1)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                Constants.QUALIFIER, qualifierList);
                            isValid = false;
                        }

                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNodeSequence.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		CheckDataSourceSchemePresence
        /// </method>
        /// <summary>
        ///		This method performs validation for field Indicator where when the Qualifier is OCCU,
        ///		 Data Source Scheme must be present.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the field element Qualifier.
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="qualifier" type = "string">
        ///		Reference containing the Qualifier.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckDataSourceSchemePresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathQualifier,
            string xPathDataSourceScheme,
            string qualifier,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "CheckDataSourceSchemePresence:");

            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                if (null == qualifier) throw new ArgumentNullException("qualifier");

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes with the xPath xPathTag
                XmlNodeList xList = xRoot.SelectNodes(xPathTag);

                //Check in each of the selected nodes
                foreach (XmlNode xNode in xList)
                {
                    if (xNode.SelectSingleNode(xPathQualifier) != null)
                    {
                        // Check whether the Data Source Scheme is present in the
                        // specified qualifier list
                        if (qualifier.IndexOf(xNode.SelectSingleNode(xPathQualifier).InnerText) != -1 && xNode.SelectSingleNode(xPathDataSourceScheme) == null)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                xNode.Name, Constants.NOCONTENT);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule288
        /// </method>
        /// <summary>
        ///This method performs validation for Conditional Rule 288.
        ///	If the Financial Instrument/Account sequence C is present once, the Effective Settlement
        /// Amount (field :19A::SETT) must not be present in sequence C (Error code E88).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///	Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="qualifier" type = "string">
        ///		Qualifier value to be validated
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule288(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xPathSequence,
            string qualifier,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule288" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValidQualifier = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPathSequence == null ||
                    xPath.Length == 0 ||
                    xPathSequence.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                //Variables used


                bool blnQualifierExist = false;
                string qualifierTemp = qualifier;
                //Check for Number of occurences of sequence in input instance
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                if (xListSequence.Count == 1)
                {
                    foreach (XmlNode xNodeList in xListSequence)
                    {
                        //Check for occurence of field in sequence list
                        XmlNodeList xList = xNodeList.SelectNodes(xPath);
                        foreach (XmlNode xNode in xList)
                        {
                            //if required qualifier is found then blnQualifierExist becomes True
                            if (xNode.InnerText.CompareTo(qualifier) == 0)
                            {
                                blnQualifierExist = true;
                            }
                        }
                    }
                    //if unwanted qualifier exists
                    if (blnQualifierExist == true)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName,
                            conditionalRuleNumber);
                        isValidQualifier = false;

                    }
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValidQualifier;
        }

        /// <method>
        ///		SWIFTNetworkRule289
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 289.
        ///		If sequence C is present two or more times, the Settlement Amount (field :19A::SETT)
        ///		must be present in every occurrence of sequence C or in none
        ///		In the former case (when sequence C is present two or more times and the Settlement
        ///		Amount (field :19A::SETT) is present in every occurrence of sequence C) then:
        ///		the sum of all occurrences of the Settlement Amount (field :19A::SETT) in sequence C
        ///		must be equal to the Settlement Amount (field :19A::SETT) in sequence E3 and
        ///		the currency code in the Settlement Amounts (fields 19A::SETT in sequences C and E3)
        ///		must be the same for all occurrences of these fields in the message.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///	Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///	Input reference of the second Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="qualifier" type = "string">
        ///		Qualifier value to be validated
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule289(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xPathSequence,
            string xPath1,
            string qualifier,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule289" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValidQualifier = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPathSequence == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                //Variables used

                bool cond3SeqC = false;
                int qualifierCounter = 0;
                int sequenceCount = 0;
                int arrCountTag = 0;
                int amtStIndex;
                int actAmountlength;
                int amtLength;
                double totalAmountC = 0;
                double totalAmountE3 = 0;
                char[] ArrayNum = new char[10];
                string valCurrencyFirst = string.Empty;

                ArrayList arraySeqCAmount = new ArrayList();
                ArrayList arraySeqE3Amount = new ArrayList();

                //Check for Number of occurences of sequence in input instance
                XmlNode xRoot = xDocument.Document;
                //checking for Sequence C
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                //Checking for Sequence //Amount_E3_19A/Qualifier
                XmlNodeList xTagE3List = xRoot.SelectNodes(xPath1);
                sequenceCount = xListSequence.Count;
                if (xListSequence.Count >= 2)
                {
                    qualifierCounter = 0;

                    foreach (XmlNode xNodeList in xListSequence)
                    {


                        //Check for occurence of field './Amount_C_19A/Qualifier' in sequence list
                        XmlNodeList xList = xNodeList.SelectNodes(xPath);
                        if (xList.Count != 0)
                        {
                            foreach (XmlNode xNode in xList)
                            {
                                //Increase count when required qualifier is present in sequenceC
                                if (xNode.InnerText.CompareTo(qualifier) == 0)
                                {
                                    qualifierCounter++;
                                    arraySeqCAmount.Add(xNode.NextSibling.InnerText);
                                    arrCountTag++;

                                }
                            }


                        }
                    }

                    if (qualifierCounter < sequenceCount && qualifierCounter != 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType,
                            conditionalRuleName, conditionalRuleNumber);
                        isValidQualifier = false;
                    }


                    //Following condition will check first subcondition in rule 289
                    if (isValidQualifier == true && xTagE3List.Count != 0 && qualifierCounter != 0)
                    {
                        bool negativeVal = false;
                        string amtValue = string.Empty;
                        string valCurrencyTemp = string.Empty;
                        string strAmount = string.Empty;
                        double tmpAmount = 0;

                        //Find SUM of all '19A:SETT' in sequence C
                        //-----Populate array to hold Numbers(0-9)---
                        for (int i = 0; i <= 9; i++)
                        {
                            ArrayNum[i] = Convert.ToChar(i.ToString(CultureInfo.InvariantCulture).Trim(), CultureInfo.InvariantCulture);
                        }
                        //-------------------------------------
                        for (int i = 0; i <= arraySeqCAmount.Count - 1; i++)
                        {
                            negativeVal = false;
                            amtValue = arraySeqCAmount[i].ToString();
                            if (amtValue.Substring(0, 1).CompareTo(Constants.ALPHAN) == 0)
                            {
                                negativeVal = true;
                            }
                            amtLength = amtValue.Length;
                            amtStIndex = amtValue.IndexOfAny(ArrayNum);
                            actAmountlength = amtLength - amtStIndex;

                            //-----Extracting currencey value to check third subsecond codition
                            valCurrencyTemp = amtValue.Substring(0, amtStIndex);
                            if (valCurrencyTemp.Length != 3)
                            {
                                valCurrencyTemp = valCurrencyTemp.Substring(1, 3);
                            }
                            if (i == 0)
                            {
                                valCurrencyFirst = valCurrencyTemp;

                            }
                            if (valCurrencyFirst.CompareTo(valCurrencyTemp) != 0)
                            {
                                cond3SeqC = true;
                            }

                            //-----------------SubCondition2 check is over for seq C--------------------------------------
                            strAmount = amtValue.Substring(amtStIndex);
                            strAmount = strAmount.Replace(Constants.COMMA, decimalSeparator);
                            tmpAmount = Convert.ToDouble(strAmount, CultureInfo.InvariantCulture);
                            if (negativeVal == true)
                            {
                                totalAmountC = totalAmountC - tmpAmount;
                            }
                            else
                            {
                                totalAmountC = totalAmountC + tmpAmount;
                            }

                        }	//--------------------------------------------------------
                        // Reading //Amount_E3_19A/Qualifier value
                        foreach (XmlNode xNode in xTagE3List)
                        {
                            if (xNode.InnerText.CompareTo(qualifier) == 0)
                            {
                                if (xNode.NextSibling != null)
                                {
                                    //	arraySeqE3Amount[arrCountTag] = xNode.NextSibling.InnerText;
                                    arraySeqE3Amount.Add(xNode.NextSibling.InnerText);
                                }
                            }
                        }
                        //Calculating SUM for all //Amount/E3/19A/Qualifier
                        for (int countE3 = 0; countE3 <= arraySeqE3Amount.Count - 1; countE3++)
                        {
                            negativeVal = false;
                            amtValue = arraySeqE3Amount[countE3].ToString();
                            if (amtValue.Substring(0, 1).CompareTo(Constants.ALPHAN) == 0)
                            {
                                negativeVal = true;
                            }
                            amtLength = amtValue.Length;
                            amtStIndex = amtValue.IndexOfAny(ArrayNum);
                            actAmountlength = amtLength - amtStIndex;
                            //-----Extracting currencey value to check third subsecond codition
                            valCurrencyTemp = amtValue.Substring(0, amtStIndex);
                            if (valCurrencyTemp.Length != 3)
                            {
                                valCurrencyTemp = valCurrencyTemp.Substring(1, 3);
                            }
                            if (valCurrencyFirst.CompareTo(valCurrencyTemp) != 0)
                            {
                                cond3SeqC = true;
                            }
                            //-----------------SubCondition3 check is over for seq E3--------------------------------------
                            strAmount = amtValue.Substring(amtStIndex);
                            strAmount = strAmount.Replace(Constants.COMMA, decimalSeparator);
                            tmpAmount = Convert.ToDouble(strAmount, CultureInfo.InvariantCulture);
                            if (negativeVal == true)
                            {
                                totalAmountE3 = totalAmountE3 - tmpAmount;
                            }
                            else
                            {
                                totalAmountE3 = totalAmountE3 + tmpAmount;
                            }
                        }


                        //--Check for second and third Subcondition;
                        if ((totalAmountC != totalAmountE3) || (cond3SeqC == true))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValidQualifier = false;
                        }

                    }
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValidQualifier;
        }

        /// <method>
        ///		HasValidMultipleQualifiers
        /// </method>
        /// <summary>
        ///		This is overloaded method.This method performs validation for fields with	multiple qualifiers to check for non-repetitive qualifiers.This method is called while performing conditional rule validation.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xList" type = "string">
        ///		Input reference of the list of elements to be validated.
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the list of the qualifiers.
        /// </param>
        /// <param name ="nonrepetitiveQualifierList" type = "string">
        ///		Reference containing the list of the non-repetitive qualifiers.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool HasValidMultipleQualifiers(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            XmlNodeList xList,
            ref string qualifierList,
            ref string nonrepetitiveQualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function HasValidMultipleQualifiers" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            string qualifier;
            try
            {
                if (xDocument == null ||
                    xList == null ||
                    xList.Count == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                if (null == nonrepetitiveQualifierList) throw new ArgumentNullException("nonrepetitiveQualifierList");
                if (null == qualifierList) throw new ArgumentNullException("qualifierList");

                XmlNode xRoot = xDocument.Document;

                foreach (XmlNode xNode in xList)
                {
                    if (xNode != null && xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        //Extract the value of the Qualifier
                        qualifier = xNode.InnerText.ToString().Trim();

                        //Search for the Qualifier's value in the Qualifier list. If not present, report error
                        if (qualifierList.IndexOf(qualifier) == -1 && nonrepetitiveQualifierList.IndexOf(qualifier) != -1)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            isValid = false;
                        }

                        //Remove the Qualifier value from the Qualifier's list.
                        qualifier = qualifier + Constants.COMMA;
                        qualifierList = qualifierList.Replace(qualifier, Constants.BLANK);

                    }

                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            (xNode != null && xNode.ParentNode != null ? xNode.ParentNode.Name : String.Empty),
                            Constants.NOCONTENT);
                        isValid = false;
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule292
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 292. One occurance of the
        /// subsequence E3 Amounts,must contain amount field with specified qualifier value.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="qualifier" type = "string">
        ///		Qualifier value to be validated
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule292(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string qualifier,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule292" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValidQualifier = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                //Variables used

                bool blnQualifierExist = false;
                string qualifierTemp = qualifier;
                //Check for Number of occurance of field in input instance
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                //if required qualifier is found then blnQualifierExist becomes True
                foreach (XmlNode xNode in xList)
                {
                    if (xNode.InnerText.CompareTo(qualifier) == 0)
                    {
                        blnQualifierExist = true;
                    }
                }

                if (blnQualifierExist == false)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType,
                        conditionalRuleName, conditionalRuleNumber);
                    isValidQualifier = false;

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValidQualifier;
        }

        /// <method>
        ///		SWIFTNetworkRule266
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 266
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B whose occurence is to be checked
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element 17B of Sequence A.
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the value of the qualifier for element 17B of Sequence A.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        /// For MT535
        /// 
        public static bool SWIFTNetworkRule266(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xPathSequence,
            string qualifierValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule266" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);

            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    qualifierValue == null ||
                    qualifierValue.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Tag 17B in Sequence A
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.FirstChild != null)
                    {
                        //Check if the Qualifier value is 'ACTI'
                        if (xNode.FirstChild.InnerText.CompareTo(qualifierValue) == 0)
                        {
                            if (xNode.LastChild != null)
                            {
                                //If the Flag is 'Y' and the Sequence B is not present or the Flag is 'N' and the Sequence B is present, throw an error
                                if ((xNode.LastChild.InnerText.CompareTo(Constants.ALPHAY) == 0
                                    && xRoot.SelectNodes(xPathSequence).Count == 0)
                                    || (xNode.LastChild.InnerText.CompareTo(Constants.ALPHAN) == 0
                                    && xRoot.SelectNodes(xPathSequence).Count != 0))
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule282
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 282
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequenceB" type = "string">
        ///		Input reference of the Sequence B whose occurence is to be checked
        /// </param>
        /// <param name ="xPathSequenceB1" type = "string">
        ///		Input reference of the Sequence B1 in which the occurence of elements 90a and 19A is to be checked
        /// </param>
        /// <param name ="xPathTag22F" type = "string">
        ///		Input reference of the element 22F of Sequence A.
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Input reference of the DataSourceScheme for element 22F of Sequence A.
        /// </param>
        /// <param name ="xPathTag90a" type = "string">
        ///		Comma separated input references of the elements 90a of Sequence B1.
        /// </param>
        /// <param name ="xPathTag19A" type = "string">
        ///		Input reference of the element 19A of Sequence B1.
        /// </param>
        /// <param name ="qualifierValue22F" type = "string">
        ///		Input containing the value of the qualifier for element 22F of sequence A.
        /// </param>
        /// <param name ="indicatorValue" type = "string">
        ///		Input containing the value of the indicator for element 22F of sequence A.
        /// </param>
        /// <param name ="qualifierValue19A" type = "string">
        ///		Input containing the value of the qualifier for element 19A of sequence B1.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule282(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag22F,
            string xPathTag90a,
            string xPathTag19A,
            string xPathDataSourceScheme,
            string xPathSequenceB,
            string xPathSequenceB1,
            string qualifierValue22F,
            string indicatorValue,
            string qualifierValue19A,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule282" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPathSequenceB1 == null ||
                    xPathSequenceB1.Length == 0 ||
                    xPathTag22F == null ||
                    xPathTag22F.Length == 0 ||
                    xPathTag90a == null ||
                    xPathTag90a.Length == 0 ||
                    xPathTag19A == null ||
                    xPathTag19A.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Check if the Sequence B is present
                if (xRoot.SelectNodes(xPathSequenceB).Count != 0)
                {
                    //Select all the Indicator nodes in Sequence A
                    XmlNodeList xList1 = xRoot.SelectNodes(xPathTag22F);
                    foreach (XmlNode xNode1 in xList1)
                    {
                        if (xNode1.FirstChild != null && xNode1.LastChild != null)
                        {
                            //Check if one of the nodes has Qualifier 'STTY', Data source Scheme absent and Indicator 'ACCT'
                            if (xNode1.FirstChild.InnerText.CompareTo(qualifierValue22F) == 0
                                && xNode1.SelectSingleNode(xPathDataSourceScheme) == null
                                && xNode1.LastChild.InnerText.CompareTo(indicatorValue) == 0)
                            {
                                //Check for the occurence of Sequence B1
                                if (xRoot.SelectNodes(xPathSequenceB1).Count == 0)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                                else
                                {
                                    //Select all the occurences of Sequence B1 in the message
                                    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequenceB1);

                                    foreach (XmlNode xNodeSequence in xListSequence)
                                    {
                                        int lCount = 0;
                                        //Store the xPaths of all the options of 90a in a string array
                                        string[] xPathArray = xPathTag90a.Split(Constants.CHRCOMMA);
                                        int lengthxPath = xPathArray.Length;

                                        //Check for all the options of 90a
                                        for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                                        {
                                            XmlNodeList xList2 = xNodeSequence.SelectNodes(xPathArray[nCount].ToString());
                                            lCount = lCount + xList2.Count;
                                        }

                                        //If 90a tag is not present in Sequence B1, throw an error
                                        if (lCount == 0)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isValid = false;
                                        }
                                        else
                                        {

                                            int qCount = 0;
                                            //Select all the nodes of Tag 19A in Sequence B1
                                            XmlNodeList xList3 = xNodeSequence.SelectNodes(xPathTag19A);

                                            foreach (XmlNode xNode2 in xList3)
                                            {
                                                //Check if one of the nodes of Tag 19A has Qualifier 'HOLD'
                                                if (xNode2.FirstChild.InnerText.CompareTo(qualifierValue19A) == 0)
                                                {
                                                    qCount = qCount + 1;
                                                }
                                            }
                                            //If there is no 19A Tag with Qualifier 'HOLD', throw an error
                                            if (qCount == 0)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }
                                        }
                                    }
                                }
                            }

                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }



        /// <method>
        ///		SWIFTNetworkRule282
        ///	</method>
        /// <summary>
        ///		In each occurrence of subsequence B1, if NO subsequence B1b is present, then both fields Price (field :90a:) and Holding Value (field :19A::HOLD) must be specified in subsequence B1 . 
        ///		In each occurrence of subsequence B1, if one or more occurrence of subsequence B1b are present, then both fields Price (field :90a:) and Holding Value (field :19A::HOLD) must be specified in each occurrence of subsequence B1b.(Error code(s): E82). 
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequenceB1" type = "string">
        ///		Input reference of the Sequence B1 whose occurence is to be checked
        /// </param>
        /// <param name ="xPathSequenceB1b" type = "string">
        ///		Input reference of the Sequence B1b in which the occurence of elements 90a and 19A is to be checked
        /// </param>
        /// <param name ="xPathSeqB1Tag90a" type = "string">
        ///		Comma separated input references of the elements 90a of Sequence B1.
        /// </param>
        /// <param name ="xPathSeqB1bTag90a" type = "string">
        ///		Comma separated input references of the elements 90a of Sequence B1b.
        /// </param>
        /// <param name ="xPathSeqB1Tag19A" type = "string">
        ///		Input reference of the element 19A of Sequence B1.
        /// </param>
        /// <param name ="xPathSeqB1bTag19A" type = "string">
        ///		Input reference of the element 19A of Sequence B1b.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the qualifier to be checked
        /// </param>
        /// <param name ="qualifier19A" type = "string">
        ///		Input containing the value of the qualifier for element 19A.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool SWIFTNetworkRule282(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequenceB1,
        //    string xPathSequenceB1b,
        //    string xPathSeqB1Tag90a,
        //    string xPathSeqB1bTag90a,
        //    string xPathSeqB1Tag19A,
        //    string xPathSeqB1bTag19A,
        //    string xPathQualifier,
        //    string qualifier19A,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{

        //    bool isValid = true;


        //    if(xDocument == null ||
        //        xPathSequenceB1 == null ||
        //        xPathSequenceB1.Length == 0 ||
        //        xPathSequenceB1b == null ||
        //        xPathSequenceB1b.Length == 0 ||
        //        xPathSeqB1Tag90a == null ||
        //        xPathSeqB1Tag90a.Length == 0 ||
        //        xPathSeqB1bTag90a == null ||
        //        xPathSeqB1bTag90a.Length == 0 ||
        //        xPathSeqB1Tag19A == null ||
        //        xPathSeqB1Tag19A.Length == 0 ||
        //        xPathSeqB1bTag19A == null ||
        //        xPathSeqB1bTag19A.Length == 0 ||
        //        xPathQualifier == null ||
        //        xPathQualifier.Length == 0||
        //        qualifier19A == null ||
        //        qualifier19A.Length == 0 ||
        //        messageType == null ||
        //        messageType.Length == 0 ||
        //        conditionalRuleName == null ||
        //        conditionalRuleName.Length == 0 ||
        //        conditionalRuleNumber == null ||
        //        conditionalRuleNumber.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    XmlNode xRoot = xDocument.Document;
        //    XmlNodeList xList1= xRoot.SelectNodes(xPathSequenceB1);

        //    foreach(XmlNode xNode1 in xList1)
        //    {
        //        //Check if the Sequence B1b is present
        //        if(xNode1.SelectNodes(xPathSequenceB1b).Count == 0)
        //        {
        //            int lCount = 0;
        //            //Store the xPaths of all the options of 90a in a string array
        //            string[] xPathArray = xPathSeqB1Tag90a.Split(Constants.CHRCOMMA);
        //            int lengthxPath = xPathArray.Length;

        //            //Check for all the options of 90a
        //            for(int nCount = 0;nCount<= lengthxPath - 1;nCount++)
        //            {
        //                XmlNodeList xList2 = xNode1.SelectNodes(xPathArray[nCount].ToString());
        //                lCount = lCount + xList2.Count;
        //            }
        //            bool isPresent = false;
        //            XmlNodeList xList3 = xNode1.SelectNodes(xPathSeqB1Tag19A);
        //            foreach(XmlNode xNode3 in xList3)
        //            {
        //                if(xNode3.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifier19A)== 0)
        //                {
        //                    isPresent = true;
        //                    break;
        //                }
        //            }

        //            if(lCount != 0 && isPresent)
        //            {						
        //                isValid= true;
        //            }
        //            else
        //            {
        //                errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                isValid= false;						
        //            }
        //        }
        //        else
        //        {	
        //            XmlNodeList xListB1b = xNode1.SelectNodes(xPathSequenceB1b);
        //            foreach(XmlNode xNodeB1b in xListB1b)
        //            {
        //                int lCount = 0;
        //                //Store the xPaths of all the options of 90a in a string array
        //                string[] xPathArray = xPathSeqB1bTag90a.Split(Constants.CHRCOMMA);
        //                int lengthxPath = xPathArray.Length;

        //                //Check for all the options of 90a
        //                for(int nCount = 0;nCount<= lengthxPath - 1;nCount++)
        //                {
        //                    XmlNodeList xList2 = xNodeB1b.SelectNodes(xPathArray[nCount].ToString());
        //                    lCount = lCount + xList2.Count;
        //                }

        //                bool isPresent = false;
        //                XmlNodeList xList3 = xNodeB1b.SelectNodes(xPathSeqB1bTag19A);
        //                foreach(XmlNode xNode3 in xList3)
        //                {
        //                    if(xNode3.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifier19A)== 0)
        //                    {
        //                        isPresent = true;
        //                        break;
        //                    }
        //                }

        //                if(lCount != 0 && isPresent)
        //                {						
        //                    isValid= true;
        //                }
        //                else
        //                {
        //                    errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                    isValid= false;						
        //                }
        //            }

        //        }
        //    }
        //    return isValid;
        //}



        /// <method>
        ///		SWIFTNetworkRule266Test
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 266
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B whose occurence is to be checked
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element 17B of Sequence A.
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the value of the qualifier for element 17B of Sequence A.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>

        public static bool SWIFTNetworkRule266Test(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xPathSequence,
            string qualifierValue)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule266Test");
            bool isValid = true;
            bool isPresent = false;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    qualifierValue == null ||
                    qualifierValue.Length == 0)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Tag 17B in Sequence A
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.FirstChild != null)
                    {
                        //Check if the Qualifier value is 'ACTI'
                        if (xNode.FirstChild.InnerText.CompareTo(qualifierValue) == 0)
                        {
                            if (xNode.LastChild != null)
                            {
                                //If the Flag is 'Y' return true
                                if (xNode.LastChild.InnerText.CompareTo(Constants.ALPHAY) == 0)
                                {
                                    isPresent = true;
                                    break;
                                }
                            }
                        }
                    }
                }

                if (isPresent)
                    isValid = true;
                else
                    isValid = false;

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///    SWIFTNetworkRule267Test
        /// </method>
        /// <summary>
        ///		if field :22F::STTY//ACCT is present, then at least one occurrence of subsequence B1 is required.		
        ///	</summary>
        ///	xPathSeqB,
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSeqB1" type = "string">
        ///		Input reference of the Sequence B1.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the Element 23F in Sequence A.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="qualifier22F" type = "string">
        ///		Reference containing the value of the Type for xPathQualifier.
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="xPathCode" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="codes" type = "string">
        ///		Reference containing the value of the Type for xPathCode.
        ///	</param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule267Test(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSeqB,
            string xPathSeqB1,
            string xPath22F,
            string xPathQualifier,
            string qualifier22F,
            string xPathDataSourceScheme,
            string xPathCode,
            string codes,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule267Test" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isPresent = false;
            try
            {
                if (xDocument == null ||
                    xPathSeqB == null ||
                    xPathSeqB1 == null ||
                    xPath22F == null ||
                    xPathQualifier == null ||
                    xPathDataSourceScheme == null ||
                    xPathCode == null ||
                    xPathSeqB.Length == 0 ||
                    xPathSeqB1.Length == 0 ||
                    xPath22F.Length == 0 ||
                    xPathQualifier.Length == 0 ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathCode.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //to check the existence of Tag 97A/97B of Sequence A
                XmlNodeList xList22F = xRoot.SelectNodes(xPath22F);

                foreach (XmlNode xNode22F in xList22F)
                {
                    if (xNode22F.SelectSingleNode(xPathQualifier) != null)
                    {
                        if (xNode22F.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifier22F) == 0)
                        {
                            if (xNode22F.SelectSingleNode(xPathDataSourceScheme) == null)
                            {
                                if (xNode22F.SelectSingleNode(xPathCode) != null)
                                {
                                    string xNode22FCode = xNode22F.SelectSingleNode(xPathCode).InnerText;
                                    if ((codes.IndexOf(xNode22FCode) != -1) && (xNode22FCode != Constants.BLANK))
                                    {
                                        XmlNodeList xListSeqB = xRoot.SelectNodes(xPathSeqB);
                                        foreach (XmlNode xNodeSeqB in xListSeqB)
                                        {
                                            if (xNodeSeqB.SelectSingleNode(xPathSeqB1) != null)
                                            {
                                                isPresent = true;
                                                break;
                                            }

                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (isPresent == true)
                {
                    isValid = true;
                }
                else
                {
                    //errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule282
        ///	</method>
        /// <summary>
        ///		In each occurrence of subsequence B1, if NO subsequence B1b is present, then both fields Price (field :90a:) and Holding Value (field :19A::HOLD) must be specified in subsequence B1 . 
        ///		In each occurrence of subsequence B1, if one or more occurrence of subsequence B1b are present, then both fields Price (field :90a:) and Holding Value (field :19A::HOLD) must be specified in each occurrence of subsequence B1b.(Error code(s): E82). 
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequenceB1" type = "string">
        ///		Input reference of the Sequence B1 whose occurence is to be checked
        /// </param>
        /// <param name ="xPathSequenceB1b" type = "string">
        ///		Input reference of the Sequence B1b in which the occurence of elements 90a and 19A is to be checked
        /// </param>
        /// <param name ="xPathSeqB1Tag90a" type = "string">
        ///		Comma separated input references of the elements 90a of Sequence B1.
        /// </param>
        /// <param name ="xPathSeqB1bTag90a" type = "string">
        ///		Comma separated input references of the elements 90a of Sequence B1b.
        /// </param>
        /// <param name ="xPathSeqB1Tag19A" type = "string">
        ///		Input reference of the element 19A of Sequence B1.
        /// </param>
        /// <param name ="xPathSeqB1bTag19A" type = "string">
        ///		Input reference of the element 19A of Sequence B1b.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the qualifier to be checked
        /// </param>
        /// <param name ="qualifier19A" type = "string">
        ///		Input containing the value of the qualifier for element 19A.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>


        public static bool SWIFTNetworkRule282(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB1,
            string xPathSequenceB1b,
            string xPathSeqB1Tag90a,
            string xPathSeqB1bTag90a,
            string xPathSeqB1Tag19A,
            string xPathSeqB1bTag19A,
            string xPathQualifier,
            string qualifier19A,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            string xPath17B,
            string xPathSequenceB,
            string qualifierValue17B,
            string errorCode17B,
            string policyName17B,
            string conditionalRuleName17B,
            string conditionalRuleNumber17B,
            string xPath22F,
            string qualifier22F,
            string xPathDataSourceScheme,
            string xPathCode,
            string codes22F,
            string errorCode22F,
            string policyName22F,
            string conditionalRuleName22F,
            string conditionalRuleNumber22F,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule282" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;

            try
            {
                if (xDocument == null ||
                    xPathSequenceB1 == null ||
                    xPathSequenceB1.Length == 0 ||
                    xPathSequenceB1b == null ||
                    xPathSequenceB1b.Length == 0 ||
                    xPathSeqB1Tag90a == null ||
                    xPathSeqB1Tag90a.Length == 0 ||
                    xPathSeqB1bTag90a == null ||
                    xPathSeqB1bTag90a.Length == 0 ||
                    xPathSeqB1Tag19A == null ||
                    xPathSeqB1Tag19A.Length == 0 ||
                    xPathSeqB1bTag19A == null ||
                    xPathSeqB1bTag19A.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    qualifier19A == null ||
                    qualifier19A.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                //if (SWIFTNetworkRule266Test(xDocument, xPath17B, xPathSequenceB, qualifierValue17B, errorCode17B, policyName17B, ruleName, messageType, conditionalRuleName17B, conditionalRuleNumber17B, errorObject) == true)
                //{
                if (SWIFTNetworkRule267Test(xDocument, xPathSequenceB, xPathSequenceB1, xPath22F, xPathQualifier, qualifier22F, xPathDataSourceScheme, xPathCode, codes22F, errorCode22F, policyName22F, ruleName, messageType, conditionalRuleName22F, conditionalRuleNumber22F, errorObject) == true)
                {
                    XmlNode xRoot = xDocument.Document;
                    XmlNodeList xList1 = xRoot.SelectNodes(xPathSequenceB1);

                    foreach (XmlNode xNode1 in xList1)
                    {
                        //Check if the Sequence B1b is present
                        if (xNode1.SelectNodes(xPathSequenceB1b).Count == 0)
                        {
                            int lCount = 0;
                            //Store the xPaths of all the options of 90a in a string array
                            string[] xPathArray = xPathSeqB1Tag90a.Split(Constants.CHRCOMMA);
                            int lengthxPath = xPathArray.Length;

                            //Check for all the options of 90a
                            for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                            {
                                XmlNodeList xList2 = xNode1.SelectNodes(xPathArray[nCount].ToString());
                                lCount = lCount + xList2.Count;
                            }
                            bool isPresent = false;
                            XmlNodeList xList3 = xNode1.SelectNodes(xPathSeqB1Tag19A);
                            foreach (XmlNode xNode3 in xList3)
                            {
                                if (xNode3.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifier19A) == 0)
                                {
                                    isPresent = true;
                                    break;
                                }
                            }

                            if (lCount != 0 && isPresent)
                            {
                                isValid = true;
                            }
                            else
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                        else
                        {
                            XmlNodeList xListB1b = xNode1.SelectNodes(xPathSequenceB1b);
                            foreach (XmlNode xNodeB1b in xListB1b)
                            {
                                int lCount = 0;
                                //Store the xPaths of all the options of 90a in a string array
                                string[] xPathArray = xPathSeqB1bTag90a.Split(Constants.CHRCOMMA);
                                int lengthxPath = xPathArray.Length;

                                //Check for all the options of 90a
                                for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                                {
                                    XmlNodeList xList2 = xNodeB1b.SelectNodes(xPathArray[nCount].ToString());
                                    lCount = lCount + xList2.Count;
                                }

                                bool isPresent = false;
                                XmlNodeList xList3 = xNodeB1b.SelectNodes(xPathSeqB1bTag19A);
                                foreach (XmlNode xNode3 in xList3)
                                {
                                    if (xNode3.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifier19A) == 0)
                                    {
                                        isPresent = true;
                                        break;
                                    }
                                }

                                if (lCount != 0 && isPresent)
                                {
                                    isValid = true;
                                }
                                else
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                            }

                        }
                    }
                }
                //}
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule256
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 256.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B whose occurence is to be checked.
        /// </param>
        /// <param name ="xPathTag97a" type = "string">
        ///		Comma separated input references of the elements 97a of Sequence B.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element 17B of Sequence A.
        /// </param>
        /// <param name ="xPathTag17B" type = "string">
        ///		Input reference of the element 17B of Sequence B.
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the value of the qualifier for element 17B of Sequence A
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule256(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xPathTag17B,
            string xPathTag97a,
            string xPathSequence,
            string qualifierValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule256" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    xPathTag17B == null ||
                    xPathTag17B.Length == 0 ||
                    xPathTag97a == null ||
                    xPathTag97a.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Check if the Sequence B is present
                if (xRoot.SelectNodes(xPathSequence).Count != 0)
                {
                    //Select all the nodes of Tag 17B in Sequence A
                    XmlNodeList xList1 = xRoot.SelectNodes(xPath);

                    foreach (XmlNode xNode1 in xList1)
                    {
                        if (xNode1.FirstChild != null)
                        {
                            //Check if the Qualifier is 'CONS'
                            if (xNode1.FirstChild.InnerText.CompareTo(qualifierValue) == 0)
                            {
                                //Select all the nodes of Sequence B
                                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                                foreach (XmlNode xNodeSequence in xListSequence)
                                {
                                    int lCount = 0;

                                    //Select all the nodes of Tag 17B in Sequence B
                                    XmlNodeList xList2 = xNodeSequence.SelectNodes(xPathTag17B);

                                    //Store the xPaths of all the options of 97a in a string array
                                    string[] xPathArray = xPathTag97a.Split(Constants.CHRCOMMA);
                                    int lengthxPath = xPathArray.Length;

                                    //Check for all the options of 97a
                                    for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                                    {
                                        XmlNodeList xList3 = xNodeSequence.SelectNodes(xPathArray[nCount].ToString());
                                        lCount = lCount + xList3.Count;
                                    }

                                    if (xNode1.LastChild != null)
                                    {
                                        //If the flag value of Tag 17B in Sequence A is 'Y' and either 17B or 97a is missing in Sequence B, throw an error
                                        if (xNode1.LastChild.InnerText.CompareTo(Constants.ALPHAY) == 0
                                            && (xList2.Count == 0 || lCount == 0))
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isValid = false;
                                        }
                                        else
                                            //If the flag value of Tag 17B in Sequence A is 'N' and either 17B or 97a is present in Sequence B, throw an error
                                            if (xNode1.LastChild.InnerText.CompareTo(Constants.ALPHAN) == 0 && (xList2.Count != 0 || lCount != 0))
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule269
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 269
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequenceB" type = "string">
        ///		Input reference of the Sequence B.
        /// </param>
        /// <param name ="xPathSequenceB1" type = "string">
        ///		Input reference of the Sequence B1 whose occurence is to be checked
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element 17B of Sequence B.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule269(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xPathSequenceB,
            string xPathSequenceB1,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule269" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);

            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPathSequenceB1 == null ||
                    xPathSequenceB1.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Sequence B
                XmlNodeList xListSequence1 = xRoot.SelectNodes(xPathSequenceB);

                foreach (XmlNode xNodeSequence in xListSequence1)
                {
                    //Select all the nodes of Sequence B1 in Sequence B
                    XmlNodeList xListSequence2 = xNodeSequence.SelectNodes(xPathSequenceB1);

                    XmlNode xNode = xNodeSequence.SelectSingleNode(xPath);

                    if (xNode == null && xListSequence2.Count == 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                    else if (xNode != null)
                    {
                        if ((xNode.LastChild.InnerText.CompareTo(Constants.ALPHAY) == 0 && xListSequence2.Count == 0)
                            || (xNode.LastChild.InnerText.CompareTo(Constants.ALPHAN) == 0 && xListSequence2.Count != 0))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule258And259
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 258 and 259
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequenceB1" type = "string">
        ///		Input reference of the Sequence B1.
        /// </param>
        /// <param name ="xPathSequenceB1a" type = "string">
        ///		Input reference of the Sequence B1a whose occurence is to be checked
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element 93C of Sequence B1a.
        /// </param>
        /// <param name ="qualifierValue1" type = "string">
        ///		Input containing the Qualifier value for 93C Tag.
        /// </param>
        /// <param name ="qualifierValue2" type = "string">
        ///		Input containing the Qualifier value for 93C Tag.
        /// </param>
        /// <param name ="qualifierValue3" type = "string">
        ///		Input containing the Qualifier value for 93C Tag.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule258And259(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xPathSequenceB1,
            string xPathSequenceB1a,
            string qualifierValue1,
            string qualifierValue2,
            string qualifierValue3,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule258And259" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceB1 == null ||
                    xPathSequenceB1.Length == 0 ||
                    xPathSequenceB1a == null ||
                    xPathSequenceB1a.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Sequence B1
                XmlNodeList xListSequence1 = xRoot.SelectNodes(xPathSequenceB1);

                foreach (XmlNode xNodeSequence1 in xListSequence1)
                {
                    int count = 0;

                    //Select all the nodes of Sequence B1a
                    XmlNodeList xListSequence2 = xNodeSequence1.SelectNodes(xPathSequenceB1a);

                    foreach (XmlNode xNodeSequence2 in xListSequence2)
                    {
                        if (xNodeSequence2.SelectSingleNode(xPath) != null && xNodeSequence2.SelectSingleNode(xPath).FirstChild != null)
                        {
                            //Check the Qualifier value of 93C Tag
                            if (xNodeSequence2.SelectSingleNode(xPath).FirstChild.InnerText.CompareTo(qualifierValue1) == 0)
                                count++;
                        }
                    }

                    if (count != 0)
                    {
                        foreach (XmlNode xNodeSequence2 in xListSequence2)
                        {
                            if (xNodeSequence2.SelectSingleNode(xPath) != null && xNodeSequence2.SelectSingleNode(xPath).FirstChild != null)
                            {
                                //Check the Qualifier value of 93C Tag
                                if (xNodeSequence2.SelectSingleNode(xPath).FirstChild.InnerText.CompareTo(qualifierValue2) == 0 || xNodeSequence2.SelectSingleNode(xPath).FirstChild.InnerText.CompareTo(qualifierValue3) == 0)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule103
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 103
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequenceB" type = "string">
        ///		Input reference of the Sequence B.
        /// </param>
        /// <param name ="xPathSequenceB1a" type = "string">
        ///		Input reference of the Sequence B1a in which occurence of elements is to be checked
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element 94a of Sequence B.
        /// </param>
        /// <param name ="xPathTag93B" type = "string">
        ///		Input reference of the element 93B of Sequence B1a.
        /// </param>
        /// <param name ="xPathTag94a" type = "string">
        ///		Input reference of the element 94a of Sequence B1a.
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the Qualifier value for 94a Tag in Sequence B1a.
        /// </param>
        /// <param name ="qualifier_Value" type = "string">
        ///		Input containing the Qualifier value for 93B Tag in Sequence B1a.  //Added for RFC 3277
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule103(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xPathTag93B,
            string xPathTag94a,
            string xPathSequenceB,
            string xPathSequenceB1a,
            string qualifierValue,
            string qualifier_Value,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule103" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPathSequenceB1a == null ||
                    xPathSequenceB1a.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    xPathTag93B == null ||
                    xPathTag93B.Length == 0 ||
                    xPathTag94a == null ||
                    xPathTag94a.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                //var to indicate presence of 93B:AGGR :: RFC 3277
                bool isFieldPresent = false;

                //Select all the nodes of Sequence B
                XmlNodeList xListSequence1 = xRoot.SelectNodes(xPathSequenceB);

                foreach (XmlNode xNodeSequence1 in xListSequence1)
                {
                    int bcount = 0;

                    //Declare a string array to store the xPaths of Tag 94a of Sequence B
                    string[] xPathArray1 = xPath.Split(Constants.CHRCOMMA);
                    int lengthxPath1 = xPathArray1.Length;

                    for (int nCount = 0; nCount <= lengthxPath1 - 1; nCount++)
                    {
                        //Select all the nodes of each xPath
                        XmlNodeList xList1 = xNodeSequence1.SelectNodes(xPathArray1[nCount].ToString());
                        bcount = bcount + xList1.Count;
                    }

                    if (bcount != 0)
                    {
                        //Select all the nodes of Sequence B1a
                        XmlNodeList xListSequence2 = xNodeSequence1.SelectNodes(xPathSequenceB1a);

                        foreach (XmlNode xNodeSequence2 in xListSequence2)
                        {
                            //Select all the nodes of Tag 93B in sequence B1a
                            XmlNodeList xList2 = xNodeSequence2.SelectNodes(xPathTag93B);

                            //checking for occurences of 93B::AGGR :: RFC 3277
                            foreach (XmlNode xTempNode in xList2)
                            {
                                if (xTempNode.FirstChild.InnerText == qualifier_Value)
                                {
                                    isFieldPresent = true;
                                }
                            }
                            int lcount = 0;

                            //Declare a string array to store the xPaths of Tag 94a of Sequence B1a
                            string[] xPathArray2 = xPathTag94a.Split(Constants.CHRCOMMA);
                            int lengthxPath2 = xPathArray2.Length;

                            for (int nCount = 0; nCount <= lengthxPath2 - 1; nCount++)
                            {
                                //Select all the nodes of each xPath
                                XmlNodeList xList3 = xNodeSequence2.SelectNodes(xPathArray2[nCount].ToString());

                                foreach (XmlNode xNode in xList3)
                                {
                                    if (xNode.FirstChild != null)
                                    {
                                        //Check if the Tag 94a has Qualifier 'SAFE'
                                        if (xNode.FirstChild.InnerText.CompareTo(qualifierValue) == 0)
                                            lcount++;
                                    }
                                }
                            }

                            //If either 93B::AGGR Tag or 94a Tag is present in Sequence B1a, throw an error
                            //isFieldPresent indicates presence of 93B::AGGR, earlier the check was for 93B only :: RFC 3277
                            if (isFieldPresent || lcount != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }

                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule104
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 104
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B1a.
        ///	</param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of the element 93B.
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of the element 94a.
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the Qualifier value for element 94a.
        /// </param>
        /// <param name ="qualifier_Value" type = "string">
        ///		Input containing the Qualifier value for element 93B.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule104(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath1,
            string xPath2,
            string xPathSequence,
            string qualifierValue,
            string qualifier_Value,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule104" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                //boolean var indicating presence of '93B::AGGR' :: RFC 3277
                bool isFieldPresent;

                //Select all the nodes of Sequence B1a
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    //Field AGGR is not present initailly : QFE 2703
                    isFieldPresent = false;

                    //Select all the nodes of Tag 93B
                    XmlNodeList xList1 = xNodeSequence.SelectNodes(xPath1);
                    //Checking for 93B field having AGGR as qualifier :: RFC 3277
                    foreach (XmlNode xTempNode in xList1)
                    {
                        if (xTempNode.FirstChild.InnerText == qualifier_Value)
                        {
                            isFieldPresent = true;
                        }
                    }
                    //Check if Tag 93B::AGGR is present :: RFC 3277
                    if (isFieldPresent)
                    {
                        int lcount = 0;

                        //Declare a string array to store all the xpaths of Tag 94a
                        string[] xPathArray = xPath2.Split(Constants.CHRCOMMA);
                        int lengthxPath = xPathArray.Length;

                        for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                        {
                            //Select all the nodes for each xPath
                            XmlNodeList xList2 = xNodeSequence.SelectNodes(xPathArray[nCount].ToString());

                            foreach (XmlNode xNode1 in xList2)
                            {
                                if (xNode1.FirstChild != null)
                                {
                                    //Check if the qualifier is equal to 'SAFE'
                                    if (xNode1.FirstChild.InnerText.CompareTo(qualifierValue) == 0)
                                        lcount++;
                                }
                            }
                        }
                        //If Tag 94a is not present with qualifier 'SAFE', throw an error
                        if (lcount == 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule253
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 253 In sequence C, if field :22H::BUSE//SWIF or :22H::BUSE//SWIT is present, then field :20C::PREV must be present in minimum one occurrence of subsequence A1 Linkages.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath20C" type = "string">
        ///		Input reference of the Element 20C in Sequence A1.
        /// </param>
        /// <param name ="xPath22H" type = "string">
        ///		Input reference of the Element 22H in Sequence A1.
        /// </param>
        /// <param name ="qualifierList20C" type = "string">
        ///		Reference containing the list of the qualifiers for xPath20C.
        /// </param>
        /// <param name ="qualifierList22H" type = "string">
        ///		Reference containing the list of the qualifiers for xPath22H.
        /// </param>
        /// <param name ="indicatorList22H" type = "string">
        ///		Reference containing the list of the indicators for xPath22H.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Input containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule253(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath20C,
            string xPath22H,
            string qualifierList20C,
            string qualifierList22H,
            string indicatorList22H,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule253" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool blnTag20CQualifier = false;
            bool qualifierPresent = false;
            try
            {
                if (xDocument == null ||
                    xPath20C == null ||
                    xPath22H == null ||
                    xPath20C.Length == 0 ||
                    xPath22H.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList22H = xRoot.SelectNodes(xPath22H);
                foreach (XmlNode xNode22H in xList22H)
                {
                    if (xNode22H.InnerText != null && xNode22H.InnerText.Length != 0)
                    {
                        if (xNode22H.FirstChild != null && xNode22H.LastChild != null)
                        {
                            if (xNode22H.FirstChild.InnerText.CompareTo(qualifierList22H) == 0
                                && xNode22H.LastChild.InnerText.CompareTo(indicatorList22H) == 0)
                            {
                                qualifierPresent = true;
                                XmlNodeList xList20C = xRoot.SelectNodes(xPath20C);
                                foreach (XmlNode xNode20C in xList20C)
                                {
                                    if (xNode20C.InnerText.CompareTo(qualifierList20C) == 0)
                                    {
                                        blnTag20CQualifier = true;
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode22H.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
                if (blnTag20CQualifier == false && qualifierPresent == true)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule252
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 252 In subsequence D1, if field :95a::PSET is present, then field :97a::SAFE is not allowed in the same sequence.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Comma separated input references of the elements to be validated.
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Comma separated input references of the elements to be validated.
        /// </param>
        /// <param name ="qualifierList1" type = "string">
        ///		Reference containing the list of the qualifiers for xPath1.
        /// </param>
        /// <param name ="qualifierList2" type = "string">
        ///		Reference containing the list of the qualifiers for xPath2.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule252(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath1,
            string xPath2,
            string qualifierList1,
            string qualifierList2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule252" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int lengthxPath1 = 0;
            int lengthxPath2 = 0;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath1 == null ||
                    xPath2 == null ||
                    xPath1.Length == 0 ||
                    xPath2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                string[] xPathArray1 = xPath1.Split(Constants.CHRCOMMA);
                lengthxPath1 = xPathArray1.Length;

                string[] xPathArray2 = xPath2.Split(Constants.CHRCOMMA);
                lengthxPath2 = xPathArray2.Length;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        for (int nCount1 = 0; nCount1 <= lengthxPath1 - 1; nCount1++)
                        {
                            XmlNodeList xList1 = xNodeSequence.SelectNodes(xPathArray1[nCount1].ToString());
                            foreach (XmlNode xNode1 in xList1)
                            {
                                if (xNode1.InnerText.ToString().Trim().CompareTo(qualifierList1) == 0)
                                {
                                    for (int nCount2 = 0; nCount2 <= lengthxPath2 - 1; nCount2++)
                                    {
                                        XmlNodeList xList2 = xNodeSequence.SelectNodes(xPathArray2[nCount2].ToString());
                                        foreach (XmlNode xNode2 in xList2)
                                        {
                                            if (xNode2.InnerText.ToString().Trim().CompareTo(qualifierList2) == 0)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }
                                        }
                                    }
                                }
                            }
                        }


                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNodeSequence.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule273
        /// </method>
        /// <summary>
        ///		This function performs validation for conditional Rule 273
        ///		If the Settlement Amount (:19A::SETT) is present in sequence C,
        ///		it must not be present in any occurrence of subsequence D3
        ///
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of element 19A of D3 Sequence to be validated.
        /// </param>
        /// <param name ="codeList" type = "string">
        ///		Reference containing the list of the codes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the Conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule273(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule273" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);
                foreach (XmlNode xNode in xList)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        if (xNode.InnerText.CompareTo(codeList) == 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);

                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule284
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 284.The following party fields
        ///		(from three different sequences) can not appear more than once in message
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		comma separated subSeuence list e.g.//SequenceE1,//SequenceE2
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Comma separated tag name e.g 95C,95S
        /// </param>
        /// <param name ="fieldName" type = "string">
        ///		Generic field name
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the first list of the qualifiers.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing message number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing name of the conditional rule
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing number of the conditional rule
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule284(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath,
            string fieldName,
            string qualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule284" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValidQualifier = true;
            try
            {
                if (null == xPath) throw new ArgumentNullException("xPath");
                if (null == xPathSequence) throw new ArgumentNullException("xPathSequence");
                if (null == qualifierList) throw new ArgumentNullException("qualifierList");

                //Variables used

                int lengthXpath = 0;

                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);
                string[] xPathSeqArray = xPathSequence.Split(Constants.CHRCOMMA);

                string qualifierListTemp = qualifierList + Constants.COMMA;
                qualifierList = qualifierList + Constants.COMMA;

                ArrayList xPathArrayTemp = new ArrayList();
                lengthXpath = xPathArray.Length;
                ArrayList arrayQualifier = new ArrayList();

                //creating required xPaths)
                for (int j = 0; j <= xPathSeqArray.Length - 1; j++)
                {
                    for (int i = 0; i <= xPathArray.Length - 1; i++)
                    {
                        string tempHoldValue = Constants.DOUBLESLASH + fieldName + Constants.UNDERSCORE + xPathSeqArray[j].Substring(10) + Constants.UNDERSCORE + xPathArray[i] + Constants.SLASH + Constants.QUALIFIER;
                        xPathArrayTemp.Add(tempHoldValue);
                    }
                }

                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //Check for Number of occurences of the field in the input instance
                XmlNode xRoot = xDocument.Document;

                for (int nCount = 0; nCount <= xPathArrayTemp.Count - 1; nCount++)
                {
                    XmlNodeList xList = xRoot.SelectNodes(xPathArrayTemp[nCount].ToString());
                    if (xList.Count != 0)
                    {
                        foreach (XmlNode xNode in xList)
                        {
                            arrayQualifier.Add(xNode.InnerText);
                        }

                    }
                }


                //--Check for NonRepetitive Qualifier.--

                string strQualifier;
                if (arrayQualifier.Count != 0)
                {
                    for (int i = 0; i <= arrayQualifier.Count - 1; i++)
                    {
                        strQualifier = arrayQualifier[i].ToString().ToString();
                        if (qualifierList.IndexOf(strQualifier) == -1 && qualifierListTemp.IndexOf(strQualifier) != -1)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                conditionalRuleName, conditionalRuleNumber);
                            isValidQualifier = false;
                        }
                        strQualifier = strQualifier + Constants.COMMA;
                        qualifierList = qualifierList.Replace(strQualifier, Constants.BLANK);
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValidQualifier;
        }

        /// <method>
        /// 	SWIFTSRG2001NetworkRule114and115
        /// </method>
        /// <summary>
        /// 	This function performs Conditional Rule C4 Validation which ensures that Field 23
        /// 	must be present if the repetitive sequence of B or the error code D14 is raised
        /// 	(AND)
        /// 	This function performs Conditional Rule C5 Validation which ensures that Field 35B
        /// 	must be present if the repetitive sequence of C or the error code D15 is raised
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPath" type = "string">
        /// 	Input containing the xpath of Tag 23 (c4) (OR) Tag 35B(c5),
        /// 	repetitive tag of Sequence.
        /// </param>
        /// <param name="xPathMandatory" type = "string">
        /// 	Input containing the xpath of Tag 35B(sequence identifier for Sequence B) (OR)
        /// 	Tag 23 (sequence identifier for Sequence C)
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Inutput containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule114And115(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPath,
        //    string xPathMandatory,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPath == null ||
        //        xPath.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    XmlNode xRoot = xDocument.Document;
        //    bool isValid = true;
        //    int nCountSeqRepetition = 0;

        //    //Check if xPath node is present in the schema
        //    XmlNodeList xList = xRoot.SelectNodes(xPath);
        //    if(xList.Count != 0)
        //    {
        //        XmlNodeList xListMandatory = xRoot.SelectNodes(xPathMandatory);
        //        foreach(XmlNode xNode in xListMandatory)
        //        {
        //            if(xNode.InnerText != null && xNode.InnerText.Length != 0)
        //            {
        //                nCountSeqRepetition++;
        //            }
        //            else
        //            {
        //                errorObject.AddError(errorCode, policyName, ruleName,
        //                    xNode.ParentNode.Name, Constants.NOCONTENT);
        //                isValid = false;
        //            }
        //        }

        //        if (nCountSeqRepetition != xList.Count)
        //        {
        //            errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //            isValid = false;
        //        }

        //    }

        //    return isValid;
        //}

        /// <method>
        /// 	SWIFTNetworkRule32
        /// </method>
        /// <summary>
        /// 	This function performs Conditional Rule C32 Validation which ensures that Field 23
        /// 	and Field 60B both must be present if the repetitive sub-sequence B1 is raised
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPath" type = "string">
        /// 	Input containing the xpath of Tag 60B,Tag 23 in comma separated value
        /// </param>
        /// <param name="xPathSequence" type = "string">
        /// 	Input containing the xpathSequence data to identify repetitive sequences //SequenceB/SubSequenceB1
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Input containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Input containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule32(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xPathSequence,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule32" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                string[] arrxPath = xPath.Split(Constants.CHRCOMMA);

                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                int nCountSeqRepetition = 0;
                nCountSeqRepetition = xListSequence.Count;
                foreach (XmlNode xNode in xListSequence)
                {
                    XmlNodeList xList60B = xNode.SelectNodes(Convert.ToString((Constants.XPATH + arrxPath[0]), CultureInfo.InvariantCulture));

                    XmlNodeList xList23 = xNode.SelectNodes(Convert.ToString((Constants.XPATH + arrxPath[1]), CultureInfo.InvariantCulture));

                    if (!(xList60B.Count == 1 && xList23.Count == 1))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        /// 	SWIFTSRG2001NetworkRule116
        /// </method>
        /// <summary>
        ///		For each occurrence of sequence B, if field 32H is present, the first subfield, ie, [N],
        ///		must be present if and only if the first subfield, ie, [N], of field 35H is present (Error
        ///		code(s): D16).
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPathSequence" type = "string">
        /// 	Input containing the xpath //Sequence B
        /// </param>
        /// <param name="xPath32H" type = "string">
        /// 	Input containing the xPath of 32H
        /// </param>
        /// <param name="xPath35H" type = "string">
        /// 	Input containing the xPath of 35H
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Input containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Input containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule116(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence,
        //    string xPath32H,
        //    string xPath35H,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPathSequence == null ||
        //        xPathSequence.Length == 0 ||
        //        xPath32H == null ||
        //        xPath32H.Length == 0 ||
        //        xPath35H == null ||
        //        xPath35H.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    bool isValid = true;
        //    bool isError = false;
        //    XmlNode xRoot = xDocument.Document;
        //    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

        //    //Loop through SequenceB is present in the schema

        //    foreach(XmlNode xNodeSequence in xListSequence)
        //    {
        //        XmlNode xNode32H = xNodeSequence.SelectSingleNode(xPath32H);
        //        XmlNode xNode35H = xNodeSequence.SelectSingleNode(xPath35H);

        //        //Check if Field32H is present in the schema
        //        if(xNode32H != null && xNode32H.InnerText.Length != 0)
        //        {
        //            //Check if Field32H starts with Negative value
        //            if(xNode32H.InnerText.StartsWith(Constants.ALPHAN) == true)
        //            {
        //                //Check if Field35H is present in the schema and Check if Field32H starts with Negative value
        //                if(xNode35H != null && xNode35H.InnerText.Length != 0 && !(xNode35H.InnerText.StartsWith(Constants.ALPHAN) == true))
        //                {
        //                    isError = true;
        //                }

        //            }
        //            else
        //            {
        //                //Check if Field32H starts with Negative value
        //                if(xNode35H != null && xNode35H.InnerText.Length != 0 && xNode35H.InnerText.StartsWith(Constants.ALPHAN) == true)
        //                {
        //                    isError = true;
        //                }
        //            }
        //        }
        //    }

        //    if(isError)
        //    {
        //        errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //        isValid = false;
        //    }

        //    return isValid;

        //}

        /// <method>
        /// 	SWIFTSRG2001NetworkRule56
        /// </method>
        /// <summary>
        /// 	C3 Fields 60A and 62A must either both be present or both be absent in each occurrence of
        /// 	the outermost repetitive sequence (Error code(s): C56).
        /// 	C4 Fields 60B and 62B must either both be present or both be absent in each occurrence of
        /// 	the innermost repetitive sequence (Error code(s): C56).
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPathSequenceB" type = "string">
        /// 	Input containing the xpath of Sequence B
        /// </param>
        /// <param name="xPathSequenceB83a" type = "string">
        /// 	Input containing the xpath of 83A,83C,83D in comma separated values
        /// </param>
        /// <param name="xPath60A" type = "string">
        /// 	Input containing the xpath of Field 60A
        /// </param>
        /// <param name="xPath62A" type = "string">
        /// 	Input containing the xpath of Field 62A
        /// </param>
        /// <param name="xPath60B" type = "string">
        /// 	Input containing the xpath of Field 60B
        /// </param>
        /// <param name="xPath62B" type = "string">
        /// 	Input containing the xpath of Field 62B
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the the multiple Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Input containing conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Input containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule56(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequenceB,
        //    string xPathSequenceB83a,
        //    string xPath60A,
        //    string xPath62A,
        //    string xPath60B,
        //    string xPath62B,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPathSequenceB == null ||
        //        xPathSequenceB.Length == 0 ||
        //        xPathSequenceB83a == null ||
        //        xPathSequenceB83a.Length == 0 ||
        //        xPath60A == null ||
        //        xPath60A.Length == 0 ||
        //        xPath62A == null ||
        //        xPath62A.Length == 0 ||
        //        xPath60B == null ||
        //        xPath60B.Length == 0 ||
        //        xPath62B == null ||
        //        xPath62B.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    else
        //    {
        //        if (null == conditionalRuleName) throw new ArgumentNullException("conditionalRuleName");
        //        if (null == xPathSequenceB83a) throw new ArgumentNullException("xPathSequenceB83a");

        //        bool isValid = true;
        //        int nCount60A = 0;
        //        int nCount62A = 0;
        //        int nCount60B = 0;
        //        int nCount62B = 0;

        //        //Multiple Conditional Rules C3,C4
        //        string [] xConditionalRuleName = conditionalRuleName.Split(Constants.COMMA.ToCharArray());
        //        string [] xPathSequenceB83aList = xPathSequenceB83a.Split(Constants.COMMA.ToCharArray());

        //        //Select the root node
        //        XmlNode xRoot = xDocument.Document;
        //        //Select Nodes Sequence B
        //        XmlNodeList xListSequenceB = xRoot.SelectNodes(xPathSequenceB);

        //        //The sequence B has been refered as outersequence in the function
        //        foreach (XmlNode xNodeB in xListSequenceB)
        //        {
        //            //Check if Field 60A exists
        //            XmlNode xNode60A = xNodeB.SelectSingleNode(xPath60A);
        //            if(xNode60A != null && xNode60A.InnerText !=null && xNode60A.InnerText.Length !=0)
        //                nCount60A++;

        //            //Check if Field 62A exists
        //            XmlNode xNode62A = xNodeB.SelectSingleNode(xPath62A);
        //            if(xNode62A != null && xNode62A.InnerText !=null && xNode62A.InnerText.Length !=0)
        //                nCount62A++;

        //            if(((nCount60A != 0)&&(nCount62A == 0)) || ((nCount60A == 0)&&(nCount62A != 0)))
        //            {
        //                errorObject.AddError(errorCode,policyName,ruleName,messageType,xConditionalRuleName[0],conditionalRuleNumber);
        //                isValid = false;
        //            }
        //            //Re-Initialize the 60A,62A Field Count variables
        //            nCount60A =0;
        //            nCount62A =0;

        //            //Check for 83A Field in sequenceB

        //            foreach(string xPathB83a in xPathSequenceB83aList)
        //            {
        //                XmlNodeList xListSequenceB83a = xNodeB.SelectNodes(xPathB83a);
        //                if(xListSequenceB83a.Count!=0)
        //                {
        //                    foreach(XmlNode xNodeSequenceB83a in xListSequenceB83a)
        //                    {
        //                        if(xNodeSequenceB83a!= null)
        //                        {
        //                            if(xNodeSequenceB83a.InnerText != null && xNodeSequenceB83a.InnerText.Length != 0 && xNodeSequenceB83a.NextSibling.Name.CompareTo( xPath60B.Substring(2))== 0)
        //                                nCount60B++; //Increase the count if 60B is found
        //                        }
        //                    }
        //                }
        //            }
        //            //Finally Check for 62B field in the sequence B
        //            XmlNodeList xList62B = xNodeB.SelectNodes(xPath62B);
        //            if(xList62B.Count!=0)
        //            {
        //                foreach(XmlNode xNode62B in xList62B)
        //                {
        //                    if(xNode62B.InnerText != null && xNode62B.InnerText.Length != 0)
        //                        nCount62B++;
        //                }
        //                if(nCount62B != nCount60B)
        //                {
        //                    errorObject.AddError(errorCode,policyName,ruleName,messageType,xConditionalRuleName[1],conditionalRuleNumber);
        //                    isValid = false;
        //                }
        //            }
        //            else
        //            {
        //                if(nCount60B !=0)
        //                {
        //                    errorObject.AddError(errorCode,policyName,ruleName,messageType,xConditionalRuleName[1],conditionalRuleNumber);
        //                    isValid = false;
        //                }

        //            }
        //            //Re-Initialize the 60B,62B Field Count variables
        //            nCount60B =0;
        //            nCount62B =0;

        //        }//end of outer sequence
        //        return isValid;
        //    }
        //}


        /// <method>
        /// 	SWIFTSRG2001NetworkRule65
        /// </method>
        /// <summary>
        /// Fields 60B and 62B may only be present if field 83a is also present in the same
        /// repetitive sequence of fields 83a through 62B (Error code(s): C65).
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPathSequenceB" type = "string">
        /// 	Input containing the xpath of Sequence B
        /// </param>
        /// <param name="xPathSequenceB83a" type = "string">
        /// 	Input containing the xpath of Tag 83A,83C,83D in comma separated list
        /// </param>
        /// <param name="xPath60B" type = "string">
        /// 	Input containing the xpath of Tag 60B
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Input containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Input containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule65(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequenceB,
        //    string xPathSequenceB83a,
        //    string xPath60B,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPathSequenceB == null ||
        //        xPathSequenceB.Length == 0 ||
        //        xPathSequenceB83a == null ||
        //        xPathSequenceB83a.Length == 0 ||
        //        xPath60B == null ||
        //        xPath60B.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    else
        //    {
        //        bool isValid = true;
        //        bool is83aFound = false;
        //        string [] xPathSequenceB83aList = xPathSequenceB83a.Split(Constants.COMMA.ToCharArray());

        //        //Select the root node
        //        XmlNode xRoot = xDocument.Document;
        //        //Select Nodes Sequence B
        //        XmlNodeList xListSequenceB = xRoot.SelectNodes(xPathSequenceB);

        //        //The sequence B has been refered as outersequence in the function
        //        foreach (XmlNode xNodeB in xListSequenceB)
        //        {
        //            XmlNodeList xList60B = xNodeB.SelectNodes(xPath60B);
        //            foreach(XmlNode xNode60B in xList60B)
        //            {
        //                if(xNode60B != null)
        //                {
        //                    if(xNode60B.InnerText != null && xNode60B.InnerText.Length != 0)
        //                    {
        //                        foreach(string xPath in xPathSequenceB83aList)
        //                        {
        //                            if(xNode60B.PreviousSibling.Name.CompareTo(xPath.Substring(2)) == 0)
        //                                is83aFound = true;
        //                        }

        //                        if(!(is83aFound))
        //                        {
        //                            errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                            isValid = false;
        //                        }
        //                        else
        //                        {
        //                            is83aFound = false;
        //                        }
        //                    }
        //                    else
        //                    {
        //                        errorObject.AddError(errorCode, policyName, ruleName,xNode60B.ParentNode.Name, Constants.NOCONTENT);
        //                        isValid = false;
        //                    }
        //                }
        //            }
        //        }
        //        return isValid;
        //    }
        //}




        /// <method>
        ///		SWIFTNetworkRule65
        /// </method>
        /// <summary>
        ///		If the message is a cancellation request status (:23G::CAST), then, in every occurrence of sequence A2 Status, a cancellation processing status must be reported (:25D::CPRC//...).
        ///		If the message is an instruction status (:23G::INST) then, in every occurrence of sequence A2 Status, an instruction processing status (:25D::IPRC//...) or a corporate action event stage (:25D::ESTA//...) must be reported. 
        ///		If the message is corporate action event processing status (:23G::EVST), then, in every occurrence of sequence A2 Status, an event status (:25D::EPRC//...) or a corporate action event stage (:25D::ESTA//...) must be reported (Error code(s): C65).
        ///	</summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence A.
        /// </param>
        /// <param name ="xPathSubSequence" type = "string">
        ///		Input reference of the Sequence A2.
        /// </param>
        /// <param name ="xPath23G" type = "string">
        ///		Input reference of the Element 23G in Sequence A.
        /// </param>
        /// <param name ="xPath25D" type = "string">
        ///		Input reference of the Element 25D in Sequence A2.
        /// </param>
        /// <param name ="xPathFunction" type = "string">
        ///		Input reference of the function in tag 23G.
        /// </param>
        /// <param name ="function" type = "string">
        ///		Reference containing the value of the Type for xPathFunction.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="qualifier" type = "string">
        ///		Reference containing the value of the Type for xPathQualifier.
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="xPathCode" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="code" type = "string">
        ///		Reference containing the value of the Type for xPathCode.
        ///	</param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule65(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPath23G,
            string xPath25D,
            string xPathFunction,
            string function,
            string xPathQualifier,
            string qualifier,
            string xPathDataSourceScheme,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule65" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);

            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSubSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence.Length == 0 ||
                    xPath23G == null ||
                    xPath23G.Length == 0 ||
                    xPath25D == null ||
                    xPath25D.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathFunction == null ||
                    xPathFunction.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Sequence A
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    //Select the node of the Tag 23G in Sequence A
                    XmlNode xNode23G = xNodeSequence.SelectSingleNode(xPath23G);

                    if (xNode23G != null && xNode23G.SelectSingleNode(xPathFunction) != null)
                    {
                        string functionValue = xNode23G.SelectSingleNode(xPathFunction).InnerText;
                        if (function.IndexOf(functionValue) != -1 && functionValue != Constants.BLANK)
                        {
                            XmlNodeList xListSubSequence = xRoot.SelectNodes(xPathSubSequence);
                            foreach (XmlNode xNodeSubSequence in xListSubSequence)
                            {

                                XmlNode xNode25D = xNodeSubSequence.SelectSingleNode(xPath25D);
                                string qualifierValue = xNode25D.SelectSingleNode(xPathQualifier).InnerText.ToString(CultureInfo.InvariantCulture);
                                if (xNode25D != null && xNode25D.SelectSingleNode(xPathQualifier) != null)
                                {
                                    //string[] qualifierCodes = qualifier.Split(Constants.CHRCOMMA);
                                    if (qualifier.IndexOf(qualifierValue) == -1)
                                    {

                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;

                                    }


                                }
                                else
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }
        /// <method>
        ///    SWIFTNetworkRule267_MT535
        /// </method>
        /// <summary>
        ///		if field :22F::STTY//ACCT is present, then at least one occurrence of subsequence B1 is required.		
        ///	</summary>
        ///	xPathSeqB,
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSeqB1" type = "string">
        ///		Input reference of the Sequence B1.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the Element 23F in Sequence A.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="qualifier22F" type = "string">
        ///		Reference containing the value of the Type for xPathQualifier.
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="xPathCode" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="codes" type = "string">
        ///		Reference containing the value of the Type for xPathCode.
        ///	</param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        /// for MT535
        public static bool SWIFTNetworkRule267_MT535(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath17B,
            string qualifierValue17B,
            string xPathSeqB,
            string xPathSeqB1,
            string xPath22F,
            string xPathQualifier,
            string qualifier22F,
            string xPathDataSourceScheme,
            string xPathCode,
            string codes,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule267_MT535" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isPresent = false;
            try
            {
                if (xDocument == null ||
                    xPath17B == null ||
                    qualifierValue17B == null ||
                    qualifierValue17B.Length == 0 ||
                    xPathSeqB == null ||
                    xPathSeqB1 == null ||
                    xPath22F == null ||
                    xPathQualifier == null ||
                    xPathDataSourceScheme == null ||
                    xPathCode == null ||
                    xPathSeqB.Length == 0 ||
                    xPathSeqB1.Length == 0 ||
                    xPath22F.Length == 0 ||
                    xPathQualifier.Length == 0 ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathCode.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                bool isACTIY = false;

                isACTIY = SWIFTNetworkRule266Test(xDocument, xPath17B, xPathSeqB, qualifierValue17B);

                //Select all the nodes of Tag 17B in Sequence A
                //XmlNodeList xList = xRoot.SelectNodes(xPath17B);

                //				foreach (XmlNode xNode in xList)
                //				{
                //					if (xNode.FirstChild != null)
                //					{
                //						//Check if the Qualifier value is 'ACTI'
                //						if (xNode.FirstChild.InnerText.CompareTo(qualifierValue17B) == 0)
                //						{
                //							if (xNode.LastChild != null)
                //							{
                //								//If the Flag is not 'Y' , Set the Flag to check whether validation needs to be 
                //								// persued further.
                //								if (xNode.LastChild.InnerText.CompareTo(Constants.ALPHAY) == 0)
                //								{
                //									isACTIY =true;
                //									break;
                //								}
                //
                //							} 
                //						}
                //					}
                //				}

                if (isACTIY)
                {
                    //to check the existence of Tag 97A/97B of Sequence A
                    XmlNodeList xList22F = xRoot.SelectNodes(xPath22F);

                    foreach (XmlNode xNode22F in xList22F)
                    {
                        if (xNode22F.SelectSingleNode(xPathQualifier) != null)
                        {
                            if (xNode22F.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifier22F) == 0)
                            {
                                if (xNode22F.SelectSingleNode(xPathDataSourceScheme) == null)
                                {
                                    if (xNode22F.SelectSingleNode(xPathCode) != null)
                                    {
                                        string xNode22FCode = xNode22F.SelectSingleNode(xPathCode).InnerText;
                                        if ((codes.IndexOf(xNode22FCode) != -1) && (xNode22FCode != Constants.BLANK))
                                        {
                                            XmlNodeList xListSeqB = xRoot.SelectNodes(xPathSeqB);
                                            foreach (XmlNode xNodeSeqB in xListSeqB)
                                            {
                                                if (xNodeSeqB.SelectSingleNode(xPathSeqB1) != null)
                                                {
                                                    isPresent = true;
                                                    break;
                                                }

                                            }
                                            if (isPresent == true)
                                            {
                                                isValid = true;
                                            }
                                            else
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

            }

            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }
        /// <method>
        /// 	SWIFTSRG2001NetworkRule28
        /// </method>
        /// <summary>
        /// If neither sequence B nor sequence C is present, field 20 in the non-repetitive sequence
        ///must be present (Error code(s): C28).
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPath20" type = "string">
        /// 	Input containing the xpath of Tag 20
        /// 	repetitive tag of Sequence.
        /// </param>
        /// <param name="xPathSequenceB" type = "string">
        /// 	Input containing the xpath of Sequence B
        /// 	repetitive tag of Sequence.
        /// </param>
        /// <param name="xPathSequenceC" type = "string">
        /// 	Input containing the xpath of Sequence C
        /// 	repetitive tag of Sequence.
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Input containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Input containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule28(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPath20,
        //    string xPathSequenceB,
        //    string xPathSequenceC,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{

        //    if(xDocument == null ||
        //        xPath20 == null ||
        //        xPath20.Length == 0 ||
        //        xPathSequenceB == null ||
        //        xPathSequenceB.Length == 0 ||
        //        xPathSequenceC == null ||
        //        xPathSequenceC.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    XmlNode xRoot = xDocument.Document;
        //    bool isValid = true;
        //    XmlNodeList xList20 = xRoot.SelectNodes(xPath20);
        //    XmlNodeList xListxPathSequenceB = xRoot.SelectNodes(xPathSequenceB);
        //    XmlNodeList xListxPathSequenceC = xRoot.SelectNodes(xPathSequenceC);
        //    if (xListxPathSequenceB.Count == 0 && xListxPathSequenceC.Count == 0)
        //    {
        //        if(xList20.Count == 0)
        //        {
        //            errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //            isValid = false;
        //        }
        //    }
        //    return isValid;

        //}

        /// <method>
        /// 	IsValidNumberOfRepetitiveParts
        /// </method>
        /// <summary>
        ///		This field specifies the number of times sequence B is present in the message, ie, the number of
        /// 	times field 35B is present.
        ///		If sequence B is not used, this field must contain the numeric value of zero,
        ///		ie, this field must contain 0.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the XML Document Instance
        ///	</param>
        /// <param name="xPath">
        ///		Input containing the xPath of Number of Repititive parts
        ///	</param>
        /// <param name="xPathSequenceB">
        ///		Input containing the xPath of Sequence B
        ///	</param>
        /// <param name="errorCode">
        ///		Input containing the Error code
        ///	</param>
        /// <param name="policyName">
        ///		Input containing the Policy name
        ///	</param>
        /// <param name="ruleName">
        ///		Input containing the Rule Name
        ///	</param>
        /// <param name="errorObject">
        ///		Input containing the error object
        ///	</param>
        /// <returns type="boolean">
        ///		True if validation succeeded, false otherwise.
        ///	</returns>

        //public static bool IsValidNumberOfRepetitiveParts(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPath,
        //    string xPathSequenceB,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPath == null ||
        //        xPath.Length == 0 ||
        //        xPathSequenceB == null ||
        //        xPathSequenceB.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    XmlNode xRoot = xDocument.Document;
        //    bool isValid = true;
        //    int nSequenceBCount = 0;
        //    XmlNodeList xList = xRoot.SelectNodes(xPath);
        //    if(xList.Count != 0)
        //    {
        //        XmlNodeList xListSequenceB = xRoot.SelectNodes(xPathSequenceB);

        //        nSequenceBCount = xListSequenceB.Count;

        //        if(xList.Item(0) != null && xList.Item(0).FirstChild != null)
        //        {
        //            if (Convert.ToInt32(xList.Item(0).FirstChild.InnerText, CultureInfo.InvariantCulture) != nSequenceBCount)
        //            {
        //                errorObject.AddError(errorCode, policyName, ruleName,xList.Item(0).InnerText, Constants.NOCONTENT);
        //                isValid = false;
        //            }
        //        }
        //    }
        //    else
        //    {
        //        errorObject.AddError(errorCode, policyName, ruleName, xPath, Constants.NOCONTENT);
        //        isValid = false;
        //    }
        //    return isValid;
        //}


        /// <method>
        /// 	IsValidStatementPeriod
        /// </method>
        /// <summary>
        ///		Date 2 must not appear in this message (Error code(s): C37)
        ///		Messages MT 571,573,577
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the XML Document Instance.
        ///	</param>
        /// <param name="xPath">
        ///		Input containing the path of statement period.
        ///	</param>
        /// <param name="elementName">
        ///		Input containing the element name.
        ///	</param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        ///	</param>
        /// <param name="policyName">
        ///		Input containing the policy name
        ///	</param>
        /// <param name="ruleName">
        ///		Input containing the rule name
        ///	</param>
        /// <param name="errorObject">
        ///		Input containing the error object
        ///	</param>
        /// <returns type="boolean">
        ///		True if validation succeeded, false otherwise.
        ///	</returns>
        //public static bool IsValidStatementPeriod(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPath,
        //    string elementName,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPath == null ||
        //        xPath.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    XmlNode xRoot = xDocument.Document;
        //    bool isValid = true;
        //    XmlNodeList xList = xRoot.SelectNodes(xPath);
        //    if(xList.Count != 0)
        //    {
        //        errorObject.AddError(errorCode,policyName,ruleName,xList.Item(0).Name,xList.Item(0).InnerText);
        //        isValid = false;
        //    }

        //    return isValid;
        //}


        /// <method>
        /// 	IsValidNonZeroQuantity
        /// </method>
        /// <summary>
        /// 	When Sign is present, Quantity must not be zero (Error code(s): T14).
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the XML Document Instance
        ///	</param>
        /// <param name="xPath">
        ///		Input containing the xPath of Quantity tag
        ///	</param>
        /// <param name="flagCurrencyCode">
        ///		Input containing the Flag(0/1)depending on currency code peresent or absent
        ///	</param>
        /// <param name="errorCode">
        ///		Input containing the error code
        ///	</param>
        /// <param name="policyName">
        ///		Input containing the policy name
        ///	</param>
        /// <param name="ruleName">
        ///		Input containing the rule name
        ///	</param>
        /// <param name="errorObject">
        ///		Input containing the error object
        ///	</param>
        /// <returns type ="boolean">
        ///		True if validation succeeded, false otherwise.
        ///	</returns>

        //public static bool IsValidNonZeroQuantity(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPath,
        //    string flagCurrencyCode,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPath == null ||
        //        xPath.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    XmlNode xRoot = xDocument.Document;
        //    bool isValid = true;
        //    XmlNodeList xList = xRoot.SelectNodes(xPath);

        //    foreach(XmlNode xNode in xList)
        //    {
        //        if(xNode.InnerText != null && xNode.InnerText.Length != 0)
        //        {
        //            if (Convert.ToInt32(flagCurrencyCode, CultureInfo.InvariantCulture) == 0)
        //            {
        //                if(xNode.FirstChild != null)
        //                {
        //                    if(xNode.FirstChild.InnerText.StartsWith(Constants.ALPHAN) == true )
        //                    {
        //                        //Only Sign and Quantity is present [N]?([0-9]+\,[0-9]{1,13})
        //                        if (Convert.ToDecimal(xNode.FirstChild.InnerText.Substring(1), CultureInfo.InvariantCulture) == 0)
        //                        {
        //                            errorObject.AddError(errorCode,policyName,ruleName,xNode.FirstChild.Name,xNode.FirstChild.InnerText);
        //                            isValid = false;
        //                        }
        //                    }
        //                }
        //            }
        //            else if (Convert.ToInt32(flagCurrencyCode, CultureInfo.InvariantCulture) == 1)
        //            {
        //                if(xNode.FirstChild != null)
        //                {
        //                    if(xNode.FirstChild.InnerText.StartsWith(Constants.ALPHAN) == true )
        //                    {
        //                        //Only Sign, type and Quantity is present [N]?(BON|CER|CPN|FMT|MSC|OPC|OPS|PRC|PRS|RTE|RTS|SHS|UNT|WTS)([0-9]+\,[0-9]{1,13})
        //                        if (Convert.ToDecimal(xNode.FirstChild.InnerText.Substring(4), CultureInfo.InvariantCulture) == 0)
        //                        {
        //                            errorObject.AddError(errorCode,policyName,ruleName,xNode.FirstChild.Name,xNode.FirstChild.InnerText);
        //                            isValid = false;
        //                        }
        //                    }
        //                }
        //            }
        //        }
        //    }

        //    return isValid;
        //}

        /// <method>
        /// 	SWIFTSRG2001NetworkRule111
        /// </method>
        /// <summary>
        /// Field 23 may only be present when field 12 consists of 573
        /// Applicable to message 570 only
        /// </summary>
        /// <param name="xDocument">Input containing the XML Document Instance</param>
        /// <param name="xPath12">Input containing the xpath of field 12</param>
        /// <param name="xPath23">Input containing comma separated values of Sequence B and Sequence C Tag 23</param>
        /// <param name="MTNumberCode">Input containing valid MTNumberCode for field 12</param>
        /// <param name="errorCode">Input containing the error object</param>
        /// <param name="policyName">Input containing the policy name</param>
        /// <param name="ruleName">Input containing the rule name</param>
        /// <param name="messageType">Input containing the message type</param>
        /// <param name="conditionalRuleName">Input containing the conditional rule name</param>
        /// <param name="conditionalRuleNumber">Input containing the conditional rule number</param>
        /// <param name="errorObject">Input containing the error object</param>
        /// <returns type="boolean">True if validation succeeded, false otherwise</returns>

        //public static bool SWIFTSRG2001NetworkRule111(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPath12,
        //    string xPath23,
        //    string MTNumberCode,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPath12 == null ||
        //        xPath12.Length == 0 ||
        //        xPath23 == null ||
        //        xPath23.Length == 0 ||
        //        MTNumberCode == null ||
        //        MTNumberCode.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    XmlNode xRoot = xDocument.Document;
        //    bool isValid = true;

        //    char[] chrArray = Constants.COMMA.ToCharArray();


        //    // Split string based on ",", Sequence B and Sequence C both contains Tag 23
        //    string [] arrxPath23 = xPath23.Split(chrArray);

        //    //Check if Tag 12 in Sequence A Present
        //    XmlNodeList xList12 = xRoot.SelectNodes(xPath12);
        //    if(xList12.Count == 0)
        //    {
        //        errorObject.AddError(errorCode, policyName, ruleName,xPath12, Constants.NOCONTENT);
        //        isValid = false;
        //    }
        //    else
        //    {
        //        int count = 0;
        //        XmlNodeList [] xList23 = new XmlNodeList[arrxPath23.Length];
        //        foreach (string xPath in arrxPath23)
        //        {
        //            xList23[count] = xRoot.SelectNodes(xPath);
        //            if(isValid == true)
        //            {
        //                if(xList23[count].Count > 0)
        //                {
        //                    if(xList12.Item(0) != null)
        //                    {
        //                        //Only a single Tag 12 is present, MTNumber '573' is passed as function parameter
        //                        if(xList12.Item(0).InnerText.CompareTo(MTNumberCode) != 0)
        //                        {
        //                            errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                            isValid = false;
        //                        }
        //                    }
        //                }
        //            }
        //            count++;
        //        }
        //    }

        //    return isValid;
        //}


        ///
        /// <method>
        ///		IsValidCode
        /// </method>
        /// <summary>
        ///		This method performs validation for fields where validation is,if Qualifier is a specified value,
        ///		QuantityTypeCode must contain one of the codes in the string array(Error code 'Not Defined').
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated (QuantityOfFinancialInstrument_36B).
        /// </param>
        /// <param name ="xPathCode" type = "string">
        ///		Input reference of the field element (QuantityTypeCode) which should not be present to be validated.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the field element (Qualifier) to be validated.
        /// </param>
        /// <param name ="qualifier" type = "string">
        ///		Reference containing the list of the codes in qualifier.
        /// </param>
        /// <param name ="codeList" type = "string">
        ///		Reference containing the list of the codes for QuantityTypeCode.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidCode(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathCode,
            string xPathQualifier,
            string qualifier,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCode" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                string code = string.Empty;
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTag = xRoot.SelectNodes(xPathTag);

                foreach (XmlNode xNode in xListTag)
                {
                    if (xNode.SelectSingleNode(xPathQualifier) != null)
                    {
                        if (xNode.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifier) == 0)
                        {
                            if (xNode.SelectSingleNode(xPathCode) != null)
                            {
                                code = xNode.SelectSingleNode(xPathCode).InnerText;
                            }

                            //Check for the presence of the code value in the codelist. If not present report error
                            if ((codeList.IndexOf(code) == -1) || (code == Constants.BLANK))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNode.Name, code);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule171
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 171.
        ///		If field :22F::DBNM//VEND is present in sequence D, then one occurrence of
        ///		sequence E must contain field :95a::VEND
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath95List" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name="qualifierDBNM">
        /// 	The qualifier value DBNM.
        /// </param>
        /// <param name="valueVEND">
        /// 	The value VEND.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule171(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath22F,
            string xPath95List,
            string qualifierDBNM,
            string valueVEND,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule171" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isPresent = true;
            bool flag = false;
            int lengthxPath = 0;
            try
            {
                if (xDocument == null ||
                    xPath22F == null ||
                    xPath22F.Length == 0 ||
                    xPath95List == null ||
                    xPath95List.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                string[] xPath95Array = xPath95List.Split(Constants.CHRCOMMA);

                lengthxPath = xPath95Array.Length;

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xNodeList22F = xRoot.SelectNodes(xPath22F);

                foreach (XmlNode xNode22F in xNodeList22F)
                {
                    if (xNode22F.FirstChild != null && xNode22F.LastChild != null)
                    {
                        if (xNode22F.FirstChild.InnerText != null && xNode22F.LastChild.InnerText != null)
                        {
                            if (xNode22F.FirstChild.InnerText.CompareTo(qualifierDBNM) == 0 && (xNode22F.LastChild.InnerText.CompareTo(valueVEND) == 0) && !(xNode22F.FirstChild.NextSibling.HasChildNodes))
                            {
                                if (!flag)
                                {
                                    isPresent = false;
                                }

                                for (int nCount = 0; (nCount <= lengthxPath - 1 && !isPresent); nCount++)
                                {
                                    XmlNodeList xList = xRoot.SelectNodes(xPath95Array[nCount].ToString());

                                    if (xList.Count != 0)
                                    {
                                        foreach (XmlNode xNode in xList)
                                        {
                                            if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                                            {
                                                if (xNode.InnerText.CompareTo(valueVEND) == 0)
                                                {
                                                    isPresent = true;
                                                    flag = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, xNode22F.Name, Constants.NOCONTENT);
                            isValid = false;
                        }
                    }
                }
                if (!isPresent)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        ///<method>
        /// SWIFTNetworkRule293
        ///</method>
        /// <summary>
        /// 	In each occurrence of sequence B (if present), if subsequence B1a1 Securities Settlement
        /// 	Parties is present, then field :95a::REAG must be present in one and only one occurrence
        /// 	of subsequence B1a1 within the same occurrence of sequence B.
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathOne">
        /// 	xPath
        /// </param>
        /// <param name="qualifierOne">
        /// 	Qualifier value
        /// </param>
        /// <param name="xPathSubSequence">
        /// 	xPath of Sub-Sequence
        /// </param>
        /// <param name="xPathTwo">
        /// 	xPath
        /// </param>
        /// <param name="fieldNameTwo">
        /// 	Field Name
        /// </param>
        /// <param name="qualifierTwo">
        /// 	Qualifier value
        /// </param>
        /// <param name="errorCode">
        /// 	Error code
        /// </param>
        /// <param name="policyName">
        /// 	The Policy name
        /// </param>
        /// <param name="ruleName">
        /// 	The rule name
        /// </param>
        /// <param name="messageType">
        /// 	Message type
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	The conditional Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	The conditional rule number
        /// </param>
        /// <param name="errorObject">
        /// 	Error Object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool SWIFTNetworkRule293(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathOne,
            string qualifierOne,
            string xPathSubSequence,
            string xPathTwo,
            string fieldNameTwo,
            string qualifierTwo,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule293" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValidqualifier = true;
            try
            {
                if (null == errorObject) throw new ArgumentNullException("errorObject");
                if (null == xDocument) throw new ArgumentNullException("xDocument");
                if (null == xDocument.Document) throw new ArgumentNullException("xDocument.Document");
                if (null == xPathSubSequence) throw new ArgumentNullException("xPathSubSequence");
                if (null == xPathTwo) throw new ArgumentNullException("xPathTwo");

                //Variables used

                ArrayList xPathArrayTempTwo = new ArrayList();

                //creating required xPaths for second sequence
                string[] xPathSeqArray = xPathSubSequence.Split(Constants.CHRCOMMA);
                string[] xPathArray = xPathTwo.Split(Constants.CHRCOMMA);
                for (int j = 0; j <= xPathSeqArray.Length - 1; j++)
                {
                    for (int i = 0; i <= xPathArray.Length - 1; i++)
                    {
                        string tempHoldValue = @Constants.DOUBLESLASH + fieldNameTwo + Constants.UNDERSCORE + xPathSeqArray[j].Substring(10) + Constants.UNDERSCORE + xPathArray[i] + Constants.SLASH + Constants.QUALIFIER;
                        xPathArrayTempTwo.Add(tempHoldValue);
                    }
                }


                bool qualifierOneExists = false;
                bool qualifierTwoExists = false;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListOne = xRoot.SelectNodes(xPathOne);
                if (xListOne.Count != 0)
                {
                    foreach (XmlNode xNode in xListOne)
                    {
                        if (xNode.InnerText.CompareTo(qualifierOne) == 0)
                        {
                            qualifierOneExists = true;
                        }
                    }
                }

                if (qualifierOneExists == false)
                {
                    //Loop to read all tags for second pathlist
                    for (int nCountS = 0; nCountS <= xPathArrayTempTwo.Count - 1; nCountS++)
                    {
                        XmlNodeList xListTwo = xRoot.SelectNodes(xPathArrayTempTwo[nCountS].ToString());
                        if (xListTwo.Count != 0)
                        {
                            foreach (XmlNode xNode in xListTwo)
                            {
                                if (xNode.InnerText.CompareTo(qualifierTwo) == 0)
                                {
                                    qualifierTwoExists = true;
                                }
                            }
                        }
                    }
                }

                if ((qualifierOneExists == false) && (qualifierTwoExists == false))
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType,
                        conditionalRuleName, conditionalRuleNumber);
                    isValidqualifier = false;
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValidqualifier;
        }

        /// <method>
        ///		SWIFTNetworkRule262
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 171.
        ///		If an Exchange Rate (field :92B::EXCH) is present, the corresponding Resulting Amount (field :19A::RESU) must be
        ///		present in the same subsequence. If the Exchange Rate is not present, the Resulting Amount is not allowed (Error
        ///		code(s): E62).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath92B" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath19A" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence to be validated.
        /// </param>
        /// <param name ="qualifierValue92B" type = "string">
        ///		Input containing the qualifier value of tag 92B.
        /// </param>
        /// <param name ="qualifierValue19A" type = "string">
        ///		Input containing the qualifier value of tag 19A.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule262(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath92B,
            string xPath19A,
            string xPathSequence,
            string qualifierValue92B,
            string qualifierValue19A,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule262" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;

            try
            {
                if (xDocument == null ||
                    xPath92B == null ||
                    xPath92B.Length == 0 ||
                    xPath19A == null ||
                    xPath19A.Length == 0 ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    qualifierValue19A == null ||
                    qualifierValue92B == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    bool is19APresent = false;
                    bool is92BPresent = false;

                    XmlNodeList xNode19AList = xNodeSequence.SelectNodes(xPath19A);

                    foreach (XmlNode xNode in xNode19AList)
                    {
                        if (xNode.FirstChild != null)
                        {
                            if (xNode.FirstChild.InnerText.CompareTo(qualifierValue19A) == 0)
                            {
                                is19APresent = true;
                                break;
                            }
                        }
                    }

                    XmlNode xNode92B = xNodeSequence.SelectSingleNode(xPath92B);

                    if (xNode92B != null)
                    {
                        if (xNode92B.InnerText.CompareTo(qualifierValue92B) == 0)
                        {
                            is92BPresent = true;
                        }
                    }

                    if (is19APresent ^ is92BPresent)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule283
        /// </method>
        /// <summary>
        ///		If the alleged instruction is against payment (:22H::PAYM//APMT in sequence B)
        ///		then it is mandatory to specify a
        ///		settlement amount: one occurrence of subsequence E3 Amounts must contain amount field
        ///		:19A::SETT (Error code(s):E83).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath19A" type = "string">
        ///		Input reference of the Element 20C in Sequence E3.
        /// </param>
        /// <param name ="xPath22H" type = "string">
        ///		Input reference of the Element 22H in Sequence B.
        /// </param>
        /// <param name ="qualifierList19A" type = "string">
        ///		Reference containing the list of the qualifiers for xPath19A.
        /// </param>
        /// <param name ="qualifierList22H" type = "string">
        ///		Reference containing the list of the qualifiers for xPath22H.
        /// </param>
        /// <param name ="indicatorList22H" type = "string">
        ///		Reference containing the list of the indicators for xPath22H.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule283(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath19A,
            string xPath22H,
            string qualifierList19A,
            string qualifierList22H,
            string indicatorList22H,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule283" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool blnTag19AQualifier = false;
            bool qualifierPresent = false;
            try
            {
                if (xDocument == null ||
                    xPath19A == null ||
                    xPath22H == null ||
                    xPath19A.Length == 0 ||
                    xPath22H.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList22H = xRoot.SelectNodes(xPath22H);
                foreach (XmlNode xNode22H in xList22H)
                {
                    if (xNode22H.InnerText != null && xNode22H.InnerText.Length != 0)
                    {
                        if (xNode22H.FirstChild != null && xNode22H.LastChild != null)
                        {
                            if (xNode22H.FirstChild.InnerText.CompareTo(qualifierList22H) == 0 &&
                                xNode22H.LastChild.InnerText.CompareTo(indicatorList22H) == 0)
                            {
                                qualifierPresent = true;
                                XmlNodeList xList19A = xRoot.SelectNodes(xPath19A);
                                foreach (XmlNode xNode19A in xList19A)
                                {
                                    if (xNode19A.InnerText.CompareTo(qualifierList19A) == 0)
                                    {
                                        blnTag19AQualifier = true;
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode22H.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
                if (blnTag19AQualifier == false && qualifierPresent == true)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule285
        /// </method>
        /// <summary>
        ///	If the alleged instruction is a Delivery (:22H::REDE//DELI in sequence B) then it is mandatory to specify a delivering
        ///	agent: one occurrence of subsequence E1 Settlement Parties must contain party field :95a::DEAG (Error code(s): E85).
        ///
        ///	If the alleged instruction is a Receipt (:22H::REDE//RECE in sequence B) then it is mandatory to specify a receiving
        /// agent: one occurrence of subsequence E1 Settlement Parties must contain party field :95a::REAG (Error code(s): E85).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath95a" type = "string">
        ///		Comma separated input references of the elements to be validated for tag 95a.
        /// </param>
        /// <param name ="xPath22H" type = "string">
        ///		nput reference of the Element 22H in Sequence B.
        /// </param>
        /// <param name ="qualifierList22H" type = "string">
        ///		Reference containing the list of the qualifiers for xPath22H.
        /// </param>
        /// <param name ="qualifierList95a" type = "string">
        ///		Reference containing the list of the qualifiers for xPath95a.
        /// </param>
        /// <param name ="indicatorList22H" type = "string">
        ///		Reference containing the list of the indicators.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule285(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath95a,
            string xPath22H,
            string qualifierList22H,
            string qualifierList95a,
            string indicatorList22H,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule285" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath95a == null ||
                    xPath22H == null ||
                    xPath95a.Length == 0 ||
                    xPath22H.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                isValid = CheckValidTagParty(xRoot, xPath95a, xPath22H, qualifierList22H, qualifierList95a,
                                            indicatorList22H, errorCode, policyName, ruleName, messageType,
                                            conditionalRuleName, conditionalRuleNumber, errorObject);
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        /// 	SWIFTSRG2001NetworkRule63
        /// </method>
        /// <summary>
        /// 	If field 34E is present, the amount must equal the net sum of the amounts of all
        /// 	occurrences of field 32H in the message (Error code(s): C63).
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPath34E" type = "string">
        /// 	Input containing the xpath of Tag 34E
        /// 	repetitive tag of Sequence.
        /// </param>
        /// <param name="xPath32H" type = "string">
        /// 	Input containing the xpath of Tag 32H
        /// 	repetitive tag of Sequence.
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Input containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Input containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule63(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPath34E,
        //    string xPath32H,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPath34E == null ||
        //        xPath34E.Length == 0 ||
        //        xPath32H == null ||
        //        xPath32H.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    XmlNode xRoot = xDocument.Document;
        //    bool isValid = true;
        //    string sign = null;

        //    //Check if xPath node is present in the schema
        //    XmlNodeList xList34E = xRoot.SelectNodes(xPath34E);
        //    if (xList34E.Count != 0)
        //    {
        //        //Check for the presence of Tag 32H
        //        decimal signAmount32HTotal=0 ;
        //        XmlNodeList xList32H = xRoot.SelectNodes(xPath32H);
        //        decimal signAmount34E = 0;
        //        if(xList34E.Item(0).FirstChild != null)
        //        {
        //            if(xList34E.Item(0).FirstChild.InnerText.StartsWith(Constants.ALPHAN) == true)
        //            {
        //                sign = Constants.SIGNNEGATIVE;
        //                signAmount34E = Convert.ToDecimal((sign + xList34E.Item(0).FirstChild.InnerText.Substring(4)),CultureInfo.InvariantCulture);
        //            }
        //            else
        //            {
        //                //Default if there is no sign with the amount
        //                sign = Constants.SIGNPOSITIVE;
        //                signAmount34E = Convert.ToDecimal((sign + xList34E.Item(0).FirstChild.InnerText.Substring(3)), CultureInfo.InvariantCulture);
        //            }
        //        }
        //        if(xList32H.Count != 0)
        //        {
        //            foreach(XmlNode xNode in xList32H)
        //            {
        //                if(xNode.FirstChild != null)
        //                {
        //                    if(xNode.FirstChild.InnerText != null && xNode.FirstChild.InnerText.Length != 0)
        //                    {
        //                        if(xNode.FirstChild.InnerText.StartsWith(Constants.ALPHAN) == true)
        //                        {
        //                            sign = Constants.SIGNNEGATIVE;
        //                            signAmount32HTotal = signAmount32HTotal + Convert.ToDecimal((sign + xNode.LastChild.InnerText.Substring(4)), CultureInfo.InvariantCulture);
        //                        }
        //                        else
        //                        {
        //                            sign = Constants.SIGNPOSITIVE;
        //                            signAmount32HTotal = signAmount32HTotal + Convert.ToDecimal((sign + xNode.LastChild.InnerText.Substring(3)), CultureInfo.InvariantCulture);
        //                        }
        //                    }
        //                    else
        //                    {
        //                        errorObject.AddError(errorCode, policyName, ruleName,xNode.ParentNode.Name, Constants.NOCONTENT);
        //                        isValid = false;
        //                    }
        //                }

        //            }
        //            if (Convert.ToDecimal(signAmount34E, CultureInfo.InvariantCulture) != Convert.ToDecimal(signAmount32HTotal, CultureInfo.InvariantCulture))
        //            {
        //                errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                isValid = false;
        //            }
        //        }
        //        else
        //        {
        //            if (Convert.ToDecimal(signAmount34E, CultureInfo.InvariantCulture) != 0)
        //                errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //            isValid = false;

        //        }
        //    }
        //    return isValid;
        //}


        /// <method>
        /// 	SWIFTSRG2001NetworkRule64
        /// </method>
        /// <summary>
        /// 	If field 34E is present, the currency code in all occurrences of field 32H must be the
        /// 	same as the currency code in field 34E (Error code(s): C64).
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPath34E" type = "string">
        /// 	Input containing the xpath of Tag 34E
        /// 	repetitive tag of Sequence.
        /// </param>
        /// <param name="xPath32H" type = "string">
        /// 	Input containing the xpath of Tag 32H
        /// 	repetitive tag of Sequence.
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Input containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Input containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule64(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPath34E,
        //    string xPath32H,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPath34E == null ||
        //        xPath34E.Length == 0 ||
        //        xPath32H == null ||
        //        xPath32H.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    XmlNode xRoot = xDocument.Document;
        //    bool isValid = true;
        //    string currencycode34E = null;
        //    string currencycode32H =null;
        //    //Check if xPath node is present in the schema
        //    XmlNodeList xList34E = xRoot.SelectNodes(xPath34E);

        //    if (xList34E.Count != 0)
        //    {
        //        if(xList34E.Item(0).FirstChild != null)
        //        {
        //            if(xList34E.Item(0).FirstChild.InnerText !=null || xList34E.Item(0).FirstChild.InnerText.Length != 0)
        //            {
        //                if(xList34E.Item(0).FirstChild.InnerText.StartsWith(Constants.ALPHAN) == true)
        //                {
        //                    currencycode34E =xList34E.Item(0).FirstChild.InnerText.Substring(1,3);
        //                }
        //                else
        //                {
        //                    currencycode34E =xList34E.Item(0).FirstChild.InnerText.Substring(0,3);
        //                }
        //            }
        //        }
        //        //Check for the presence of Tag 32H
        //        XmlNodeList xList32H = xRoot.SelectNodes(xPath32H);
        //        if(xList32H.Count != 0)
        //        {
        //            foreach(XmlNode xNode in xList32H)
        //            {
        //                if(isValid == true)
        //                {
        //                    if(xNode.FirstChild != null)
        //                    {
        //                        if(xNode.FirstChild.InnerText != null && xNode.FirstChild.InnerText.Length != 0)
        //                        {
        //                            if(xNode.FirstChild.InnerText.StartsWith(Constants.ALPHAN) == true)
        //                            {
        //                                currencycode32H = xNode.FirstChild.InnerText.Substring(1,3);
        //                            }
        //                            else
        //                            {
        //                                currencycode32H = xNode.FirstChild.InnerText.Substring(0,3);
        //                            }
        //                            if( currencycode34E.CompareTo(currencycode32H) != 0)
        //                            {
        //                                errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                                isValid = false;
        //                            }
        //                        }
        //                    }
        //                }
        //            }
        //        }
        //    }
        //    return isValid;

        //}
        ///<method>
        ///		SWIFTNetworkRule214
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 171.
        ///		If field :22F::REPT//CALL is present in sequence D, then sequence A
        ///		 must contain field :23G::CANC
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath23G" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="qualifierFXCX" type = "string">
        ///		Input containing the qualifier FXCX.
        /// </param>
        /// <param name ="qualifierCANC" type = "string">
        ///		Input containing the qualifier CANC.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule214(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath22F,
            string xPath23G,
            string qualifierFXCX,
            string qualifierCANC,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule214" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPath22F == null ||
                    xPath22F.Length == 0 ||
                    xPath23G == null ||
                    xPath23G.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                // Concatenate the qualifier and indicator into the given xPath
                //	e.g.: "//SequenceD/Indicator_D_22F[Qualifier='CAOP' and Indicator='SPLI' and not(child::DataSourceScheme)]"
                string xPathCondTag = xPath22F + Constants.OPENSQUAREBRACKET + Constants.QUALIFIER + Constants.EQUAL + Constants.SINGLEQUOTE + qualifierFXCX + Constants.SINGLEQUOTE + Constants.SPACE + Constants.CLOSESQUAREBRACKET;

                XmlNodeList xNodeList22F = xRoot.SelectNodes(xPathCondTag);

                if (xNodeList22F.Count != 0)
                {
                    if (xRoot.SelectSingleNode(xPath23G) != null && xRoot.SelectSingleNode(xPath23G).FirstChild != null)
                    {
                        if (xRoot.SelectSingleNode(xPath23G).FirstChild.InnerText.CompareTo(qualifierCANC) != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;

                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule214
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 171.
        ///		If field :22F::REPT//CALL is present in sequence D, then sequence A
        ///		 must contain field :23G::CANC
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath23G" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="qualifierREPT" type = "string">
        ///		Input containing the qualifier REPT.
        /// </param>
        /// <param name ="valueCALL" type = "string">
        ///		Input containing the value CALL.
        /// </param>
        /// <param name ="qualifierCANC" type = "string">
        ///		Input containing the qualifier CANC.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule214(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath22F,
            string xPath23G,
            string qualifierREPT,
            string valueCALL,
            string qualifierCANC,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule214" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath22F == null ||
                    xPath22F.Length == 0 ||
                    xPath23G == null ||
                    xPath23G.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                // Concatenate the qualifier and indicator into the given xPath
                //	e.g.: "//SequenceD/Indicator_D_22F[Qualifier='CAOP' and Indicator='SPLI' and not(child::DataSourceScheme)]"
                string xPathCondTag = xPath22F + Constants.OPENSQUAREBRACKET + Constants.QUALIFIER + Constants.EQUAL + Constants.SINGLEQUOTE + qualifierREPT + Constants.SINGLEQUOTE + Constants.SPACE + Constants.AND + Constants.SPACE + Constants.INDICATOR + Constants.EQUAL + Constants.SINGLEQUOTE + valueCALL + "' and not(descendant::" + Constants.DATASOURCESCHEME + ")]";

                XmlNodeList xNodeList22F = xRoot.SelectNodes(xPathCondTag);

                if (xNodeList22F.Count != 0)
                {
                    if (xRoot.SelectSingleNode(xPath23G) != null && xRoot.SelectSingleNode(xPath23G).FirstChild != null)
                    {
                        if (xRoot.SelectSingleNode(xPath23G).FirstChild.InnerText.CompareTo(qualifierCANC) != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule270
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 270.
        ///		If field :22F::DBNM is present in sequence E, then one occurrence of
        ///		sequence E1 must contain field :95a::VEND
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath95List" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="qualifierDBNM" type = "string">
        ///		Input containing the qualifier DBNM.
        /// </param>
        /// <param name ="valueSELL" type = "string">
        ///		Input containing the value SELL.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule270(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath22F,
            string xPath95List,
            string qualifierDBNM,
            string valueSELL,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule270" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isPresent = true;
            bool flag = false;
            int lengthxPath = 0;
            try
            {
                if (xDocument == null ||
                    xPath22F == null ||
                    xPath22F.Length == 0 ||
                    xPath95List == null ||
                    xPath95List.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                string[] xPath95Array = xPath95List.Split(Constants.CHRCOMMA);

                lengthxPath = xPath95Array.Length;

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xNodeList22F = xRoot.SelectNodes(xPath22F);

                foreach (XmlNode xNode22F in xNodeList22F)
                {
                    if (xNode22F.FirstChild != null)
                    {
                        if (xNode22F.FirstChild.InnerText != null)
                        {
                            if (xNode22F.FirstChild.InnerText.CompareTo(qualifierDBNM) == 0)
                            {
                                if (!flag)
                                {
                                    isPresent = false;
                                }

                                for (int nCount = 0; (nCount <= lengthxPath - 1 && !isPresent); nCount++)
                                {
                                    XmlNodeList xList = xRoot.SelectNodes(xPath95Array[nCount].ToString());

                                    if (xList.Count != 0)
                                    {
                                        foreach (XmlNode xNode in xList)
                                        {
                                            if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                                            {
                                                if (xNode.InnerText.CompareTo(valueSELL) == 0)
                                                {
                                                    isPresent = true;
                                                    flag = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }

                            }
                        }
                        else
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, xNode22F.Name, Constants.NOCONTENT);
                            isValid = false;
                        }
                    }
                }
                if (!isPresent)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule290
        /// </method>
        /// <summary>
        ///		This function performs validation for conditional Rule 290 In sequence A, if the total of linked settlement instructions (field :99B::TOSE) is present, then the current settlement
        /// instruction number (field :99B::SETT) must be present
        ///
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of element 99B of A Sequence to be validated.
        /// </param>
        /// <param name ="codeList1" type = "string">
        ///		Reference containing the list of the codes.
        /// </param>
        /// <param name ="codeList2" type = "string">
        ///		Reference containing the list of the codes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the Conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule290(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string codeList1,
            string codeList2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule290" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isBln1present = false;
            bool isBln2present = false;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);
                foreach (XmlNode xNode in xList)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        if (xNode.InnerText.CompareTo(codeList1) == 0)
                        {
                            isBln1present = true;

                        }
                        if (xNode.InnerText.CompareTo(codeList2) == 0)
                        {
                            isBln2present = true;
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
                if (isBln1present == true && isBln2present == false)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule291
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 291.
        ///		If field :22F::RDBNM is not present in sequenceE, then one occurence of sequence E1
        ///		 must contain field :95a::DEAG
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath95List" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="qualifierDBNM" type = "string">
        ///		Input containing the qualifier DBNM.
        /// </param>
        /// <param name ="qualifierDEAG" type = "string">
        ///		Input containing the qualifier DEAG.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule291(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath22F,
            string xPath95List,
            string qualifierDBNM,
            string qualifierDEAG,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule291" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isPresent = true;
            try
            {

                if (xDocument == null ||
                    xPath22F == null ||
                    xPath22F.Length == 0 ||
                    xPath95List == null ||
                    xPath95List.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                string[] xPath95Array = xPath95List.Split(Constants.CHRCOMMA);
                int lengthxPath = xPath95Array.Length;

                XmlNode xRoot = xDocument.Document;
                // Concatenate the qualifier and indicator into the given xPath
                //	e.g.: "//SequenceD/Indicator_D_22F[Qualifier='CAOP' and Indicator='SPLI']"
                string xPathCondTag = xPath22F + Constants.OPENSQUAREBRACKET + Constants.QUALIFIER + Constants.EQUAL + Constants.SINGLEQUOTE + qualifierDBNM + Constants.SINGLEQUOTE + Constants.SPACE + Constants.CLOSESQUAREBRACKET;

                XmlNodeList xNodeList22F = xRoot.SelectNodes(xPathCondTag);

                if (xNodeList22F.Count == 0)
                {
                    isPresent = false;
                    for (int nCount = 0; (nCount <= lengthxPath - 1 && !isPresent); nCount++)
                    {
                        XmlNodeList xList = xRoot.SelectNodes(xPath95Array[nCount].ToString());

                        if (xList.Count != 0)
                        {
                            foreach (XmlNode xNode in xList)
                            {
                                if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                                {
                                    if (xNode.InnerText.CompareTo(qualifierDEAG) == 0)
                                    {
                                        isPresent = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (isPresent == false)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule299
        /// </method>
        /// <summary>
        ///		This function performs validation for conditional Rule 290 In sequence A, if the total of linked settlement instructions (field :99B::TORE,TODE) is present, then the current settlement
        /// instruction number (field :99B::TOSE) must be present
        ///
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of element 99B of A Sequence to be validated.
        /// </param>
        /// <param name ="codeList1" type = "string">
        ///		Reference containing the list of the codes.
        /// </param>
        /// <param name ="codeList2" type = "string">
        ///		Reference containing the list of the codes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the Conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule299(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string codeList1,
            string codeList2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule299" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool bln1present = false;
            bool bln2present = false;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                if (null == codeList1) throw new ArgumentNullException("codeList1");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                string[] qualifierArray = codeList1.Split(Constants.CHRCOMMA);
                int arraylen = qualifierArray.Length;
                int i = 0;

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        for (i = 0; i <= arraylen - 1; i++)
                        {
                            if (xNode.InnerText.CompareTo(qualifierArray[i]) == 0)
                            {
                                bln1present = true;

                            }
                        }

                        if (xNode.InnerText.CompareTo(codeList2) == 0)
                        {
                            bln2present = true;
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
                if (bln1present == true && bln2present == false)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule160
        /// </method>
        /// <summary>
        ///		If an exchange rate is given in field 36, the original ordered amount in the original currency must
        ///     be given in field 33B,
        ///		and vice-versa (Error code(s): D60).
        ///     If field 33B is presentand 'amount'in field 36B is not equal to zero, then field 36 must be present, 
        ///     otherwise field 36 is not allowed.(Error Code(s) : D60).
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path of the sequence
        /// </param>
        /// <param name="xPathSequenceBField33B">
        ///		Reference path of the Field 33B in sequenceB
        /// </param>
        /// <param name="xPathSequenceBField32BAmount">
        ///		Reference path of the Amount in Field 33B in sequenceB
        /// </param>
        /// <param name="xPathSequenceBField36">
        ///		Reference path of the Field 36 in sequenceB
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Conditional rule name
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		Conditional rule number
        /// </param>
        /// <param name="errorObject">
        ///		Error object
        /// </param>
        /// <returns>
        ///		bool
        ///</returns>


        public static bool SWIFTNetworkRule160(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathSequenceBField33B,
            string xPathSequenceBField32BAmount,
            string xPathSequenceBField36,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule160" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                string Field32BValue = string.Empty;

                XmlNodeList xListTag = xRoot.SelectNodes(xPathSequenceB);
                foreach (XmlNode xNode in xListTag)
                {
                    //check if the node has an Field 32B tag
                    Field32BValue = xNode.SelectSingleNode(xPathSequenceBField32BAmount).InnerText.Replace(Constants.COMMA, decimalSeparator);
                    XmlNode xNode33BField = xNode.SelectSingleNode(xPathSequenceBField33B);
                    XmlNode xNode36Field = xNode.SelectSingleNode(xPathSequenceBField36);

                    //Field 33B is present.
                    if (xNode33BField != null)
                    {

                        // Amount in 32B field is zero.
                        if ((Convert.ToDouble(Field32BValue, CultureInfo.InvariantCulture) == 0) && xNode36Field != null)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        }
                        // Amount in 32B field is not zero.
                        if ((Convert.ToDouble(Field32BValue, CultureInfo.InvariantCulture) != 0) && xNode36Field == null)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        }
                    }
                    //Field 33B is not present.
                    else if (xNode33BField == null && xNode36Field != null)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);

                    }


                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }



        /// <method>
        ///		SWIFTNetworkRule254
        /// </method>
        /// <summary>
        ///		 (Error code(s): D54).
        ///     .
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path of the sequence
        /// </param>
        /// <param name="xPathSequenceBField32BAmount">
        ///		Reference path of the Field 33B in sequenceB
        /// </param>
        /// <param name="xPathSequenceBField23E">
        ///		Reference path of the Amount in Field 33B in sequenceB
        /// </param>
        /// </param>
        /// <param name="xPathSequenceBField33B">
        ///		Reference path of the Amount in Field 33B in sequenceB
        /// </param>
        /// <param name="xPathSequenceBField21F">
        ///		Reference path of the Field 36 in sequenceB
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Conditional rule name
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		Conditional rule number
        /// </param>
        /// <param name="errorObject">
        ///		Error object
        /// </param>
        /// <returns>
        ///		bool
        ///</returns>


        public static bool SWIFTNetworkRule254(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathSequenceBField32BAmount,
            string xPathSequenceBField23E,
            string xPathSequenceBField33B,
            string xPathSequenceBField21F,
            string EQUICodeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule254" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                string Field32BValue = string.Empty;
                string Field32BAmountValue = string.Empty;

                // string Field23EValue=string.Empty;

                XmlNodeList xListTag = xRoot.SelectNodes(xPathSequenceB);
                foreach (XmlNode xNode in xListTag)
                {
                    //check if the node has an Field 32B tag
                    Field32BValue = xNode.SelectSingleNode(xPathSequenceBField32BAmount).InnerText.Replace(Constants.COMMA, decimalSeparator);
                    Field32BAmountValue = Field32BValue.Substring(3);
                    //, Field32BValue.Length-3);
                    XmlNode xNode33BField = xNode.SelectSingleNode(xPathSequenceBField33B);
                    XmlNode xNode21FField = xNode.SelectSingleNode(xPathSequenceBField21F);
                    XmlNode xNode23EField = xNode.SelectSingleNode(xPathSequenceBField23E);

                    //Field 33B is present.
                    if (Convert.ToDouble(Field32BAmountValue, CultureInfo.InvariantCulture) == 0)
                    {

                        if (xNode23EField != null)
                        {
                            string InstructionCode = xNode23EField.InnerText.ToString();
                            string InstructionCodeValue = InstructionCode.Substring(0, 4);
                            if ((InstructionCodeValue.Equals(EQUICodeList) && xNode33BField == null) ||
                                ((!(InstructionCodeValue.Equals(EQUICodeList))) && (xNode33BField != null)))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            }

                            if ((!(InstructionCodeValue.Equals(EQUICodeList)) && (xNode21FField != null)))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            }

                        }
                        else if ((xNode33BField != null) || (xNode21FField != null))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        }

                    }



                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	SWIFTNetworkRule161
        /// </method>
        /// <summary>
        ///		Field 50a (option F, G or H), must be present in either sequence A
        ///		(index 5) or in each occurrence of sequence B (index 15), but
        ///		must never be present in both sequences, nor be absent from
        ///		both sequences.
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequenceB" type = "string">
        ///		Input reference of the SequenceB.
        ///	</param>
        /// <param name="xPathNonRepetitiveFieldSequenceA" type = "string">
        ///		Input reference of the elements in SequenceA.
        /// </param>
        /// <param name="xPathNonRepetitiveFieldSequenceB" type = "string">
        ///		Input reference of the elements in SequenceB.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule161(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathNonRepetitiveFieldSequenceA,
            string xPathNonRepetitiveFieldSequenceB,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule161" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceB == null ||
                    xPathNonRepetitiveFieldSequenceA == null ||
                    xPathNonRepetitiveFieldSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPathNonRepetitiveFieldSequenceA.Length == 0 ||
                    xPathNonRepetitiveFieldSequenceB.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                bool isNodeA = false;
                bool isNodeB = false;
                XmlNode xRoot = xDocument.Document;

                // If multiple parameters passed Collect list of parameters
                // in sequence A
                string[] arrNonRepetitiveFieldSequenceA =
                    xPathNonRepetitiveFieldSequenceA.Split
                    (Constants.CHRCOMMA);

                // If multiple parameters passed Collect list of parameters
                // in sequence B
                XmlNodeList xListB = xRoot.SelectNodes(xPathSequenceB);
                string[] arrNonRepetitiveFieldSequenceB =
                    xPathNonRepetitiveFieldSequenceB.Split
                    (Constants.CHRCOMMA);

                // Checking for sequence A
                foreach (string NonRepetitiveField in
                    arrNonRepetitiveFieldSequenceA)
                {
                    XmlNode xNode_A = xRoot.SelectSingleNode(NonRepetitiveField);
                    if (xNode_A != null)
                    {
                        isNodeA = true;
                        break;
                    }
                }
                // Checking for sequence B
                foreach (XmlNode xNodeB in xListB)
                {
                    isNodeB = false;
                    foreach (string NonRepetitiveField in
                        arrNonRepetitiveFieldSequenceB)
                    {
                        XmlNode xNode_B = xNodeB.SelectSingleNode
                            (NonRepetitiveField);
                        if (xNode_B != null)
                        {
                            isNodeB = true;
                            break;
                        }

                    }
                    if ((isNodeA && isNodeB) ||
                        (!isNodeA && !isNodeB))
                    {
                        errorObject.AddError(errorCode, policyName,
                            ruleName, messageType, conditionalRuleName,
                            conditionalRuleNumber);
                        isValid = false;
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule162
        /// </method>
        /// <summary>
        ///		Field 50a (option C or L), may be present in either sequence
        ///		A (index 4), or in one or more occurrences of sequence B
        ///		(index 14), but must not be present in both sequences A and
        ///		B (Error code(s): D62).
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequenceB" type = "string">
        ///		Input reference of the SequenceB.
        ///	</param>
        /// <param name="xPathNonRepetitiveFieldSequenceA" type = "string">
        ///		Input reference of the elements in SequenceA.
        /// </param>
        /// <param name="xPathNonRepetitiveFieldSequenceB" type = "string">
        ///		Input reference of the elements in SequenceB.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will
        ///		be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule162(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathNonRepetitiveFieldSequenceA,
            string xPathNonRepetitiveFieldSequenceB,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule162" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceB == null ||
                    xPathNonRepetitiveFieldSequenceA == null ||
                    xPathNonRepetitiveFieldSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPathNonRepetitiveFieldSequenceA.Length == 0 ||
                    xPathNonRepetitiveFieldSequenceB.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                bool isNodeA = false;
                bool isNodeB = false;
                XmlNode xRoot = xDocument.Document;

                // If multiple parameters passed Collect list of parameters
                // in sequence A
                string[] arrNonRepetitiveFieldSequenceA =
                    xPathNonRepetitiveFieldSequenceA.Split
                    (Constants.CHRCOMMA);

                // If multiple parameters passed Collect list of parameters
                // in sequence B
                XmlNodeList xListB = xRoot.SelectNodes(xPathSequenceB);
                string[] arrNonRepetitiveFieldSequenceB =
                    xPathNonRepetitiveFieldSequenceB.Split
                    (Constants.CHRCOMMA);

                // Checking for sequence A
                foreach (string NonRepetitiveField in
                    arrNonRepetitiveFieldSequenceA)
                {
                    XmlNode xNode_A = xRoot.SelectSingleNode(NonRepetitiveField);
                    if (xNode_A != null)
                    {
                        isNodeA = true;
                        break;
                    }
                }
                // Checking for sequence B
                foreach (XmlNode xNodeB in xListB)
                {
                    isNodeB = false;
                    XmlNode xNode_B;
                    foreach (string NonRepetitiveField in
                        arrNonRepetitiveFieldSequenceB)
                    {
                        xNode_B = xNodeB.SelectSingleNode(NonRepetitiveField);

                        if (xNode_B != null)
                        {
                            isNodeB = true;
                            break;
                        }
                    }
                    // If present in both the sequences, then throw an error
                    if (isNodeA && isNodeB)
                    {
                        errorObject.AddError(errorCode, policyName,
                            ruleName, messageType, conditionalRuleName,
                            conditionalRuleNumber);
                        isValid = false;
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule164
        /// </method>
        /// <summary>
        ///		Field 52a may be present in either sequence A or in one or more occurrences of sequence B, but must not be present in
        ///		both sequences (Error code(s): D64).
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path the document
        /// </param>
        /// <param name="xPathSequenceA">
        ///		Reference path to sequenceA
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path to sequenceB
        /// </param>
        /// <param name="xPathSequenceAField52A">
        ///		Reference path to field 52A of sequence A
        /// </param>
        /// <param name="xPathSequenceAField52C">
        ///		Reference path to field 52C of sequence A
        /// </param>
        /// <param name="xPathSequenceBField52A">
        ///		Reference path to field 52A of sequence B
        /// </param>
        /// <param name="xPathSequenceBField52C">
        ///		Reference path to field 52C of sequence B
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule164(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceA,
            string xPathSequenceB,
            string xPathSequenceAField52A,
            string xPathSequenceAField52C,
            string xPathSequenceBField52A,
            string xPathSequenceBField52C,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule164" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTagSeqA = xRoot.SelectNodes(xPathSequenceA);
                bool isPresent = false;

                foreach (XmlNode xNode in xListTagSeqA)
                {
                    //check if the node has an Field 21R
                    XmlNode xNodeFieldSeqA52A = xNode.SelectSingleNode(xPathSequenceAField52A);
                    XmlNode xNodeFieldSeqA52C = xNode.SelectSingleNode(xPathSequenceAField52C);

                    //Check if Field 21R is not null
                    if (xNodeFieldSeqA52A != null || xNodeFieldSeqA52C != null)
                    {
                        isPresent = true;
                        //Exit for loop
                        break;
                    }
                }
                if (isPresent == true)
                {
                    XmlNodeList xListTagSeqB = xRoot.SelectNodes(xPathSequenceB);
                    foreach (XmlNode xNode in xListTagSeqB)
                    {
                        //check if the node has an Field 32B tag
                        XmlNode xNodeFieldSeqB52A = xNode.SelectSingleNode(xPathSequenceBField52A);
                        XmlNode xNodeFieldSeqB52C = xNode.SelectSingleNode(xPathSequenceBField52C);

                        //Check if Field 32B is not null
                        if (xNodeFieldSeqB52A == null && xNodeFieldSeqB52C == null)
                        {
                            isValid = true;
                        }
                        else
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule165
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 165, In each occurence of Sequence B:
        ///		IF field 56a is present then field 57a must be present
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the desired Sequence say sequence B, for e.g. //SequenceB
        ///	</param>
        /// <param name ="xPathFieldsExist" type = "string">
        ///		Input reference of the desired element say 56a, for e.g., ./Intermediary_B_56A,./Intermediary_B_56D
        /// </param>
        /// <param name ="xPathFieldsMustPresent" type = "string">
        ///		Input reference of the desired element say 57a, for e.g.,
        ///		./AccountWithInstitution_B_57A,./AccountWithInstitution_B_57C,./AccountWithInstitution_B_57D
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule165(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathFieldsExist,
            string xPathFieldsMustPresent,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule165" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathFieldsExist == null ||
                    xPathFieldsExist.Length == 0 ||
                    xPathFieldsMustPresent == null ||
                    xPathFieldsMustPresent.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Declare a string array to store all the xpaths for the desired tag and its corresponding required Tag
                string[] xPathArrayFieldsExist = xPathFieldsExist.Split(Constants.CHRCOMMA);
                string[] xPathArrayFieldsMustPresent = xPathFieldsMustPresent.Split(Constants.CHRCOMMA);

                //Select all the nodes of the desired Sequence say Sequence B
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                //	Counters required to store the values of occurrences of Sequence, desired field and 'must be present' field
                int xListFieldExistsCount = 0;
                int xListFieldMustPresentCount = 0;
                string xPathExistingField;

                foreach (XmlNode xNode in xListSequence)
                {
                    xListFieldExistsCount = 0;
                    xListFieldMustPresentCount = 0;

                    for (int i = 0; i < xPathArrayFieldsExist.Length; i++)
                    {
                        xPathExistingField = xPathArrayFieldsExist[i];
                        XmlNodeList xListFieldExists = xNode.SelectNodes(xPathExistingField);
                        xListFieldExistsCount += xListFieldExists.Count;
                    }
                    for (int i = 0; i < xPathArrayFieldsMustPresent.Length; i++)
                    {
                        xPathExistingField = xPathArrayFieldsMustPresent[i];
                        XmlNodeList xListFieldExists = xNode.SelectNodes(xPathExistingField);
                        xListFieldMustPresentCount += xListFieldExists.Count;
                    }
                    if (xListFieldExistsCount != 0 &&
                        (xListFieldExistsCount != xListFieldMustPresentCount))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule198
        /// </method>
        /// <summary>
        ///		If field 21R is present in sequence A, then in each occurrence of sequence B, the currency code in fields 32B must be
        ///		the same (Error code(s): D98).
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPathSequenceA">
        ///		Reference path to the sequenceA
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path to the sequenceB
        /// </param>
        /// <param name="xPathSequenceAField21R">
        ///		Reference path to field 21R in sequenceA
        /// </param>
        /// <param name="xPathSequenceBField32BAmount">
        ///		Reference path to field 32B in SequenceB
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule198(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceA,
            string xPathSequenceB,
            string xPathSequenceAField21R,
            string xPathSequenceBField32BAmount,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule198" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTagSeqA = xRoot.SelectNodes(xPathSequenceA);
                bool isPresent = false;
                string Field32BValue = string.Empty;

                foreach (XmlNode xNode in xListTagSeqA)
                {
                    //check if the node has an Field 21R
                    XmlNode xNodeField = xNode.SelectSingleNode(xPathSequenceAField21R);

                    //Check if Field 21R is not null
                    if (xNodeField != null)
                    {
                        isPresent = true;
                        //Exit for loop
                        break;
                    }
                }
                if (isPresent == true)
                {
                    XmlNodeList xListTagSeqB = xRoot.SelectNodes(xPathSequenceB);
                    foreach (XmlNode xNode in xListTagSeqB)
                    {
                        //check if the node has an Field 32B tag
                        XmlNode xNodeField = xNode.SelectSingleNode(xPathSequenceBField32BAmount);

                        if (xNodeField != null)
                        {
                            if (Field32BValue.CompareTo(Constants.BLANK) == 0)
                            {
                                Field32BValue = xNodeField.InnerText;
                            }

                            //Check if Field 32B is not null
                            if (xNodeField.InnerText.CompareTo(Field32BValue) != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;

                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule199
        /// </method>
        /// <summary>
        ///		In each occurrence of sequence B, if amount in field 32B is equal to zero, then fields 21F, 33B and 36 are not allowed
        ///		(Error code(s): D99).
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path to sequenceB
        /// </param>
        /// <param name="xPathSequenceBField32BAmount">
        ///		Reference path to field 32B in sequenceB
        /// </param>
        /// <param name="xPathSequenceBField21F">
        ///		Reference path to field 21F in sequenceB
        /// </param>
        /// <param name="xPathSequenceBField33B">
        ///		Reference path to field 33B in sequenceB
        /// </param>
        /// <param name="xPathSequenceBField36">
        ///		Reference path to field 36 in sequenceB
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule199(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathSequenceBField32BAmount,
            string xPathSequenceBField21F,
            string xPathSequenceBField33B,
            string xPathSequenceBField36,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule199" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                string Field32BValue = string.Empty;

                XmlNodeList xListTag = xRoot.SelectNodes(xPathSequenceB);
                foreach (XmlNode xNode in xListTag)
                {
                    //check if the node has an Field 32B tag
                    Field32BValue = xNode.SelectSingleNode(xPathSequenceBField32BAmount).InnerText.Replace(Constants.COMMA, decimalSeparator);
                    XmlNode xNode21FField = xNode.SelectSingleNode(xPathSequenceBField21F);
                    XmlNode xNode33BField = xNode.SelectSingleNode(xPathSequenceBField33B);
                    XmlNode xNode36Field = xNode.SelectSingleNode(xPathSequenceBField36);

                    if (Convert.ToDouble(Field32BValue, CultureInfo.InvariantCulture) == 0)
                    {
                        if (xNode21FField != null || xNode33BField != null || xNode36Field != null)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        }
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule154
        /// </method>
        /// <summary>
        ///		If an exchange rate is given in field 36, the corresponding forex deal must be referenced in field 21F (Error code(s):
        ///		D54).
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path to SequenceB
        /// </param>
        /// <param name="xPathSequenceBField36">
        ///		Reference Path to the tag 36 in sequence B
        /// </param>
        /// <param name="xPathSequenceBField21F">
        ///		Reference Path to the tag 21F in sequence B
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Conditional rule name
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		Conditional rule number
        /// </param>
        /// <param name="errorObject">
        ///		Error object
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule154(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathSequenceBField36,
            string xPathSequenceBField21F,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule154" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListTag = xRoot.SelectNodes(xPathSequenceB);
                foreach (XmlNode xNode in xListTag)
                {
                    //check if the node has an Field 32B tag
                    XmlNode xNode36Field = xNode.SelectSingleNode(xPathSequenceBField36);
                    XmlNode xNode21FField = xNode.SelectSingleNode(xPathSequenceBField21F);

                    if (xNode36Field != null && xNode21FField == null)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule168
        /// </method>
        /// <summary>
        ///		If field 33B is present in sequence B, its currency code must be different from the currency code in field 32B in the
        ///		same occurrence of sequence B (Error code(s): D68).
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path to the sequenceB
        /// </param>
        /// <param name="xPathSequenceAField33B">
        ///		Reference path to field 33B in sequenceB
        /// </param>
        /// <param name="xPathSequenceBField32B">
        ///		Reference path to field 32B in sequenceB
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule168(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathSequenceAField33B,
            string xPathSequenceBField32B,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule168" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTag = xRoot.SelectNodes(xPathSequenceB);

                foreach (XmlNode xNode in xListTag)
                {
                    //check if the node has an Field 21R
                    XmlNode xNodeField33B = xNode.SelectSingleNode(xPathSequenceAField33B);
                    XmlNode xNodeField32B = xNode.SelectSingleNode(xPathSequenceBField32B);

                    //Check if Field 21R is not null
                    if (xNodeField33B != null)
                    {
                        if (xNodeField32B != null)
                        {
                            if (xNodeField32B.InnerText.Substring(0, 3).CompareTo(xNodeField33B.InnerText.Substring(0, 3)) == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		IsValidMaxSequence
        /// </method>
        /// <summary>
        ///		This function performs validation to ensure that the maximum and minimum occurrence
        ///		for the Sequence is within specified limits.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="nCountMinRepetition" type ="int">
        ///		Input Count for Minimum number of Repeatition
        /// </param>
        /// <param name ="nCountMaxRepetition" type ="int">
        ///		Input Count for Maximum number of Repetition
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the Conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidMaxSequence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            int nCountMinRepetition,
            int nCountMaxRepetition,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidMaxSequence" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int nCount = 0;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);
                nCount = xList.Count;
                if (nCount > nCountMaxRepetition || nCount < nCountMinRepetition)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule267
        /// </method>
        /// <summary>
        ///The Safekeeping Account (field :97a::SAFE) must be present in sequence A General
        ///Information, or in all occurrences of subsequence B2c Trading Parties, but not in both.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathList" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xpathSubSeq" type = "string">
        ///		Input reference of the SubSequence to be checked.
        /// </param>
        /// <param name ="xpathSubFieldList" type = "string">
        ///		Input reference of the sub field to be checked.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing message number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing name of the conditional rule
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing number of the conditional rule
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        /// Used for MT576
        public static bool SWIFTNetworkRule267(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathList,
            string xpathSubSeq,
            string xpathSubFieldList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule267" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int lengthxPath1 = 0;
            int count = 0;
            try
            {
                if (xDocument == null ||
                    xPathList == null ||
                    xPathList.Length == 0 ||
                    xpathSubSeq == null ||
                    xpathSubSeq.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    xpathSubFieldList == null ||
                    xpathSubFieldList.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                string[] xPathArray1 = xPathList.Split(Constants.CHRCOMMA);
                lengthxPath1 = xPathArray1.Length;
                XmlNodeList xList1;

                for (int nCount = 0; nCount <= lengthxPath1 - 1; nCount++)
                {
                    //Select all the occurences of the field having xPath present in the array
                    xList1 = xRoot.SelectNodes(xPathArray1[nCount].ToString());

                    if (xList1.Count != 0)
                    {
                        count++;
                    }
                }

                if (count != 0)
                {
                    XmlNodeList xListSequence = xRoot.SelectNodes(xpathSubSeq);
                    XmlNodeList xList2;
                    foreach (XmlNode xNodeSequence in xListSequence)
                    {
                        string[] xPathArray2 = xpathSubFieldList.Split(Constants.CHRCOMMA);
                        int lengthxPath2 = xPathArray2.Length;
                        count = 0;
                        for (int nCount = 0; nCount <= lengthxPath2 - 1; nCount++)
                        {
                            //Select all the occurences of the field having xPath present in the array
                            xList2 = xNodeSequence.SelectNodes(xPathArray2[nCount].ToString());
                            if (xList2.Count != 0)
                            {
                                count++;
                            }
                        }
                        if (count != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
                else
                {
                    XmlNodeList xListSequence = xRoot.SelectNodes(xpathSubSeq);
                    if (xListSequence.Count == 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                    else
                    {
                        XmlNodeList xList3;
                        foreach (XmlNode xNodeSequence in xListSequence)
                        {
                            string[] xPathArray2 = xpathSubFieldList.Split(Constants.CHRCOMMA);
                            int lengthxPath2 = xPathArray2.Length;
                            count = 0;

                            for (int nCount = 0; nCount <= lengthxPath2 - 1; nCount++)
                            {
                                //Select all the occurences of the field having xPath present in the array
                                xList3 = xNodeSequence.SelectNodes(xPathArray2[nCount].ToString());
                                if (xList3.Count != 0)
                                {
                                    count++;
                                }
                            }

                            if (count == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                                break;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		IsValidCode
        /// </method>
        /// <summary>
        ///		This method performs validation for fields where validation is,if Qualifier is a specified value and
        ///		if Data Source Scheme is not present,
        ///		indicator must contain one of the codes in the string array(Error code 'Not Defined').
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence to be validated.
        /// </param>
        /// <param name ="xPathTag1" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathTag2" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathField" type = "string">
        ///		Input reference of the field element which should not be present to be validated.
        /// </param>
        /// <param name ="xPathCode" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="qualifier" type = "string">
        ///		Input containing the qualifier.
        /// </param>
        /// <param name ="codeList" type = "string">
        ///		Reference containing the list of the codes.
        /// </param>
        /// <param name ="valueQualifier" type = "string">
        ///		Input containing the qualifier value of the other tag.
        /// </param>
        /// <param name ="valueCode" type = "string">
        ///		Input containing the code value of the other tag.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidCode(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag1,
            string xPathTag2,
            string xPathField,
            string xPathCode,
            string xPathQualifier,
            string qualifier,
            string codeList,
            string valueQualifier,
            string valueCode,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCode" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {

                string code = string.Empty;
                if (xDocument == null ||
                    xPathTag1 == null ||
                    xPathTag1.Length == 0 ||
                    xPathTag2 == null ||
                    xPathTag2.Length == 0 ||
                    xPathField == null ||
                    xPathField.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        XmlNodeList xListTag = xNodeSequence.SelectNodes(xPathTag1);

                        foreach (XmlNode xNode in xListTag)
                        {
                            if (xNode.SelectSingleNode(xPathQualifier) != null)
                            {
                                if (xNode.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifier) == 0)
                                {
                                    //check if the node has an DataSourceScheme tag
                                    XmlNode xNodeField = xNode.SelectSingleNode(xPathField);

                                    //Since the DataSourceScheme is not present, check for validity of code
                                    if (xNodeField == null)
                                    {
                                        XmlNodeList xListTag2 = xNodeSequence.SelectNodes(xPathTag2);

                                        foreach (XmlNode xNodeTagTemp in xListTag2)
                                        {
                                            if (xNodeTagTemp.SelectSingleNode(xPathQualifier).InnerText != null)
                                            {
                                                if (xNodeTagTemp.SelectSingleNode(xPathQualifier).InnerText.CompareTo(valueQualifier) == 0)
                                                {
                                                    if (xNodeTagTemp.SelectSingleNode(xPathCode) != null)
                                                    {
                                                        if (xNodeTagTemp.SelectSingleNode(xPathCode).InnerText.CompareTo(valueCode) == 0)
                                                        {
                                                            if (xNode.SelectSingleNode(xPathCode) != null)
                                                            {
                                                                code = xNode.SelectSingleNode(xPathCode).InnerText;
                                                            }
                                                            //Check for the presence of the code value in the codelist. If not present report error
                                                            if ((codeList.IndexOf(code) == -1) || (code == Constants.BLANK))
                                                            {
                                                                errorObject.AddError(errorCode, policyName, ruleName,
                                                                    xNode.Name, code);
                                                                isValid = false;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }


        /// <method>
        ///		SWIFTNetworkRule193
        /// </method>
        /// <summary>
        ///		If field 23 contains the code CHQB, the Account Number must not be present in field 59a.
        ///		In all other cases, it is mandatory (Error code(s): D93).
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to document.
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path to Sequence B
        /// </param>
        /// <param name="xPathSequenceAField23">
        ///		Reference path to Field 23 in SequenceA
        /// </param>
        /// <param name="xPathList59aAccount">
        ///		Reference path to element accoutnt in Field 59A in Sequence.
        /// </param>
        /// <param name="conditionalCode">
        ///		CHQB code for Field 23
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule193(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathSequenceAField23,
            string xPathList59aAccount,
            string conditionalCode,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule193" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                if (null == xPathList59aAccount) throw new ArgumentNullException("xPathList59aAccount");

                string[] arrSequenceBField59a = xPathList59aAccount.Split(Constants.CHRCOMMA);


                bool IsSeqA23conditionalCode = false;

                bool isField59aAccount = false;

                XmlNode xRoot = xDocument.Document;

                //parsing the sequence A
                XmlNodeList xListTagSeqAField23 = xRoot.SelectNodes(xPathSequenceAField23);
                foreach (XmlNode xNode in xListTagSeqAField23)
                {
                    if (xNode.InnerText.ToString().CompareTo(conditionalCode) == 0)
                    {
                        IsSeqA23conditionalCode = true;
                        //Exit for loop
                        break;
                    }
                }


                //Parsing the sequenceB
                XmlNodeList xListTagSeqB = xRoot.SelectNodes(xPathSequenceB);
                foreach (XmlNode xNode in xListTagSeqB)
                {

                    isField59aAccount = false;

                    for (int countBField59a = 0; countBField59a < arrSequenceBField59a.Length; countBField59a++)
                    {
                        //check if the sequenceB has an field 59a
                        XmlNode xNodeField59aAccount = xNode.SelectSingleNode(arrSequenceBField59a[countBField59a]);

                        //Check if field 59a is not null
                        if (xNodeField59aAccount != null)
                            isField59aAccount = true;

                    }

                    if (IsSeqA23conditionalCode == false && isField59aAccount == false)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName,
                            conditionalRuleNumber);
                        isValid = false;

                    }
                }

                if (IsSeqA23conditionalCode == true && isField59aAccount == true)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName,
                        conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule179
        /// </method>
        /// <summary>
        ///		If field 71G is present in an occurrence of sequence B, then field 71G is mandatory
        ///		in the sequence C (Error code(s):D79).
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path to SequenceB
        /// </param>
        /// <param name="xPathSequenceC">
        ///		Reference path to sequenceC
        /// </param>
        /// <param name="xPathSequenceBField71G">
        ///		Reference path to field 71G in sequenceB
        /// </param>
        /// <param name="xPathSequenceCField71G">
        ///		Reference path to field 71G in SequenceC
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule179(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathSequenceC,
            string xPathSequenceBField71G,
            string xPathSequenceCField71G,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule179" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                bool isPresentSequenceB71G = false;

                XmlNode xRoot = xDocument.Document;

                //Parsing the sequenceB
                XmlNodeList xListTagSeqB = xRoot.SelectNodes(xPathSequenceB);
                foreach (XmlNode xNode in xListTagSeqB)
                {
                    //Checking for node 59A and 59
                    XmlNode xNodeSequenceBField71G = xNode.SelectSingleNode(xPathSequenceBField71G);

                    if (xNodeSequenceBField71G != null)
                    {
                        isPresentSequenceB71G = true;
                        //End the loop
                        break;
                    }
                }

                //Parsing the sequenceC
                XmlNodeList xListTagSeqC = xRoot.SelectNodes(xPathSequenceC);
                foreach (XmlNode xNode in xListTagSeqC)
                {
                    //Checking for node 59A and 59
                    XmlNode xNodeSequenceCField71G = xNode.SelectSingleNode(xPathSequenceCField71G);

                    if (isPresentSequenceB71G == true && xNodeSequenceCField71G == null)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule151
        ///	</method>
        /// <summary>
        ///		If either field 71F (at least one occurrence) or field 71G are present in an occurrence of
        ///		sequence B, then field 33B is mandatory in the same occurrence of sequence B (Error code(s): D51).
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path to SequenceB
        /// </param>
        /// <param name="xPathSequenceBField71F">
        ///		Reference path to field 71F in sequence B
        /// </param>
        /// <param name="xPathSequenceBField71G">
        ///		Reference path to field 71G in sequence B
        /// </param>
        /// <param name="xPathSequenceBField33B">
        ///		Reference path to field 33B in sequence B
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule151(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathSequenceBField71F,
            string xPathSequenceBField71G,
            string xPathSequenceBField33B,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule151" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Parsing the sequenceB
                XmlNodeList xListTagSeqB = xRoot.SelectNodes(xPathSequenceB);
                foreach (XmlNode xNode in xListTagSeqB)
                {
                    //Checking for node 59A and 59
                    XmlNode xNodeSequenceBField71F = xNode.SelectSingleNode(xPathSequenceBField71F);
                    XmlNode xNodeSequenceBField71G = xNode.SelectSingleNode(xPathSequenceBField71G);
                    XmlNode xNodeSequenceBField33B = xNode.SelectSingleNode(xPathSequenceBField33B);

                    if (xNodeSequenceBField71F != null && xNodeSequenceBField71G != null)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }

                    if (xNodeSequenceBField71F != null && xNodeSequenceBField71G == null && xNodeSequenceBField33B == null)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                    if (xNodeSequenceBField71F == null && xNodeSequenceBField71G != null && xNodeSequenceBField33B == null)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule122
        /// </method>
        /// <summary>
        ///		Field 36 (sequence A or sequence B) must be present in the message if there is any sequence B
        ///		which contains a field 33B with a currency code different from the currency code in field 32B;
        ///		in all other cases field 36 is not allowed in the message.When a field 36 (sequence A or sequence B)
        ///		is required, EITHER field 36 must be present in sequence A and not in any sequence B, OR it must be present
        ///		in every sequence B which contains fields 32B and 33B with different currency codes and must not be
        ///		present in sequence A or any other sequence B (Error code(s): D22).
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPathSequenceA">
        ///		Reference path to sequenceA
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path to sequenceB
        /// </param>
        /// <param name="xPathSequenceAField36">
        ///		Reference path to Field 36 in SequenceA
        /// </param>
        /// <param name="xPathSequenceBField33B">
        ///		Reference path to Field 33B in SequenceB
        /// </param>
        /// <param name="xPathSequenceBField36">
        ///		Reference path to Field 36 in SequenceB
        /// </param>
        /// <param name="xPathSequenceBField33BCurrency">
        ///		Reference path to currency element in Field 33B in SequenceB
        /// </param>
        /// <param name="xPathSequenceBField32BCurrency">
        ///		Reference path to currency element in Field 32B in SequenceB
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns></returns>

        public static bool SWIFTNetworkRule122(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceA,
            string xPathSequenceB,
            string xPathSequenceAField36,
            string xPathSequenceBField33B,
            string xPathSequenceBField36,
            string xPathSequenceBField33BCurrency,
            string xPathSequenceBField32BCurrency,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule122" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                bool isSeqA36Present = false;
                bool is33BPresent = false;
                bool isCurrencyCodeDifferent = false;
                bool isSeqB36Present = false;

                XmlNode xRoot = xDocument.Document;

                //parsing the sequence A
                XmlNodeList xListTagSeqA = xRoot.SelectNodes(xPathSequenceA);
                foreach (XmlNode xNode in xListTagSeqA)
                {
                    //checking for node 36
                    XmlNode xNodeFieldSeqAField36 = xNode.SelectSingleNode(xPathSequenceAField36);

                    if (xNodeFieldSeqAField36 != null)
                    {
                        isSeqA36Present = true;
                        //Exit for loop
                        break;
                    }

                    else
                    {
                        isSeqA36Present = false;
                        //Exit for loop
                        break;
                    }
                }

                //Condition1: if 36 is present in sequenceA then 33B must be present in SequenceB
                if (isSeqA36Present == true)
                {
                    //Parsing the sequenceB
                    XmlNodeList xListTagSeqB = xRoot.SelectNodes(xPathSequenceB);

                    foreach (XmlNode xNode in xListTagSeqB)
                    {
                        //Checking for node 33B and 36
                        XmlNode xNodeSequenceBField33B = xNode.SelectSingleNode(xPathSequenceBField33B);
                        XmlNode xNodeSequenceBField36 = xNode.SelectSingleNode(xPathSequenceBField36);

                        XmlNode xNodeSequenceBField33BCurrency = xNode.SelectSingleNode(xPathSequenceBField33BCurrency);
                        XmlNode xNodeSequenceBField32BCurrency = xNode.SelectSingleNode(xPathSequenceBField32BCurrency);

                        //If Field 33B is present in any one of the SequenceB occurrences
                        //we are good. Preventing the check happening in any other
                        //SequenceB nodes to preserve the "is33BPresent==true" flag.
                        if (!is33BPresent)
                        {
                            if (xNodeSequenceBField33B != null)
                                is33BPresent = true;
                            else
                                is33BPresent = false;
                        }

                        //Condition2: if 36 is present in sequenceA then 36 must not be present in SequenceB
                        if (xNodeSequenceBField36 != null)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }

                        //Condition3: The currency code in 33B and 32B must not be same in any one occurrence of
                        //SequenceB. So if its already true, need not check again
                        if (!isCurrencyCodeDifferent)
                        {
                            if (xNodeSequenceBField33BCurrency != null && xNodeSequenceBField32BCurrency != null &&
                                (xNodeSequenceBField33BCurrency.InnerText.CompareTo(xNodeSequenceBField32BCurrency.InnerText) != 0))
                                isCurrencyCodeDifferent = true;
                            else
                                isCurrencyCodeDifferent = false;
                        }

                        // The condition is that 33B must be present in minimum of
                        // one SequenceB and the currency code must also be different between
                        // 32B and 33B in any one SequenceB occurrence.
                        /*if(!(is33BPresent) || !(isCurrencyCodeDifferent))
                        {
                            errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
                            isValid=false;
                        }*/
                    }

                    if (!(is33BPresent) || !(isCurrencyCodeDifferent))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
                else
                {
                    //Parsing the sequenceB
                    XmlNodeList xListTagSeqB = xRoot.SelectNodes(xPathSequenceB);
                    foreach (XmlNode xNode in xListTagSeqB)
                    {
                        //Checking for node 33B and 36
                        XmlNode xNodeSequenceBField33B = xNode.SelectSingleNode(xPathSequenceBField33B);
                        XmlNode xNodeSequenceBField36 = xNode.SelectSingleNode(xPathSequenceBField36);

                        XmlNode xNodeSequenceBField33BCurrency = xNode.SelectSingleNode(xPathSequenceBField33BCurrency);
                        XmlNode xNodeSequenceBField32BCurrency = xNode.SelectSingleNode(xPathSequenceBField32BCurrency);

                        if (xNodeSequenceBField33B != null)
                            is33BPresent = true;
                        else
                            is33BPresent = false;

                        if (xNodeSequenceBField36 != null)
                            isSeqB36Present = true;
                        else
                            isSeqB36Present = false;


                        //Condition4: if 36 is present in sequenceA and 33B in sequenceB and cuurency is same in 33B and 32B then
                        //36 in sequenceB should not be there. If they are not equal 36 in sequenceB is mandatory.
                        if (is33BPresent)
                        {
                            if (xNodeSequenceBField33BCurrency != null && xNodeSequenceBField32BCurrency != null &&
                                ((xNodeSequenceBField33BCurrency.InnerText.CompareTo(xNodeSequenceBField32BCurrency.InnerText) == 0
                                && isSeqB36Present) ||
                                (xNodeSequenceBField33BCurrency.InnerText.CompareTo(xNodeSequenceBField32BCurrency.InnerText) != 0
                                && !(isSeqB36Present))))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }

                        }

                        //Condition4: if 36 is not present in sequenceA and 33B not present in sequenceB then 36 in sequenceB should not be there
                        if (!(is33BPresent) && isSeqB36Present)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }


        /// <method>
        ///		SWIFTNetworkRule120
        /// </method>
        /// <summary>
        ///		Field 71A must be present either in sequence A or in each occurrence of sequence B,
        ///		but it must never be present in both sequences, nor be absent from both sequences (Error code(s): D20).
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPathSequenceA">
        ///		Reference path to SequenceA
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path to SequenceB
        /// </param>
        /// <param name="xPathSequenceAField71A">
        ///		Reference path to field 71A in SequenceA
        /// </param>
        /// <param name="xPathSequenceBField71A">
        ///		Reference path to field 71A in SequenceB
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule120(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceA,
            string xPathSequenceB,
            string xPathSequenceAField71A,
            string xPathSequenceBField71A,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule120" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTagSeqA = xRoot.SelectNodes(xPathSequenceA);
                bool isPresent = false;

                foreach (XmlNode xNode in xListTagSeqA)
                {
                    //check if the sequenceA has an field 71A
                    XmlNode xNodeFieldSeqAField71A = xNode.SelectSingleNode(xPathSequenceAField71A);

                    //Check if field 71A is not null
                    if (xNodeFieldSeqAField71A != null)
                    {
                        isPresent = true;
                        //Exit for loop
                        break;
                    }
                    else
                    {
                        isPresent = false;
                        //Exit for loop
                        break;
                    }
                }

                if (isPresent == true)
                {
                    XmlNodeList xListTagSeqB = xRoot.SelectNodes(xPathSequenceB);
                    foreach (XmlNode xNode in xListTagSeqB)
                    {
                        //check if the sequenceB has Field 71A
                        XmlNode xNodeFieldSeqBField71A = xNode.SelectSingleNode(xPathSequenceBField71A);

                        //Check if field 71A is not null
                        if (xNodeFieldSeqBField71A != null)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
                else
                {
                    XmlNodeList xListTagSeqB = xRoot.SelectNodes(xPathSequenceB);
                    foreach (XmlNode xNode in xListTagSeqB)
                    {
                        //check if the sequenceB has Field 71A
                        XmlNode xNodeFieldSeqBField71A = xNode.SelectSingleNode(xPathSequenceBField71A);

                        //Check if field 71A is null
                        if (xNodeFieldSeqBField71A == null)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }



        /// <method>
        ///		SWIFTNetworkRule107
        /// </method>
        /// <summary>
        ///		If subfield 1 of field 77H contains "ISDA", then (Date) and (Version) are mandatory(Error code(s): D07).
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPath">
        ///		Reference path to Field 77H
        /// </param>
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>

        public static bool SWIFTNetworkRule107(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule107" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                XmlNode xNode = xRoot.SelectSingleNode(xPath);

                if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                {
                    if (xNode.ChildNodes.Count != 2)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                    else
                    {
                        if (xNode.ChildNodes.Count == 2)
                        {
                            XmlNode node = xNode.ChildNodes[0];
                            if (node.ChildNodes.Count != 2)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }



        /// <method>
        ///		SWIFTNetworkRule117
        /// </method>
        /// <summary>
        ///		Field 50a must be present either in sequence A or in each occurrence of sequence B,
        ///		but it must never be present in both sequences, nor be absent from both sequences (Error code(s): D17).
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPathSequence">
        ///		Reference path to ssequencea
        /// </param>
        /// <param name="xPathSequenceAField50a">
        ///		Reference path to Field 50A in sequenceA
        /// </param>
        /// <param name="xPathSequenceBField50a">
        ///		Reference path to Field 50A in sequenceB
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule117(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSequenceAField50a,
            string xPathSequenceBField50a,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule117" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                if (null == xPathSequence) throw new ArgumentNullException("xPathSequence");
                if (null == xPathSequenceAField50a) throw new ArgumentNullException("xPathSequenceAField50a");
                if (null == xPathSequenceBField50a) throw new ArgumentNullException("xPathSequenceBField50a");

                //Split the Sequence xPaths
                string[] arrSequence = xPathSequence.Split(Constants.CHRCOMMA);
                string xPathSequenceA = string.Empty;
                string xPathSequenceB = string.Empty;

                if (arrSequence[0] != null)
                {
                    xPathSequenceA = arrSequence[0];
                }
                if (arrSequence[1] != null)
                {
                    xPathSequenceB = arrSequence[1];
                }

                // If multiple parameters passed Collect list of parameters
                // in sequence A
                string[] arrSequenceAField50a = xPathSequenceAField50a.Split(Constants.CHRCOMMA);


                // If multiple parameters passed Collect list of parameters
                // in sequence B
                string[] arrSequenceBField50a = xPathSequenceBField50a.Split(Constants.CHRCOMMA);

                bool isPresent = false;
                bool isSeqBField50a = false;

                //Parsing the sequenceA
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTagSeqA = xRoot.SelectNodes(xPathSequenceA);
                foreach (XmlNode xNode in xListTagSeqA)
                {
                    for (int countAField50a = 0; countAField50a < arrSequenceAField50a.Length; countAField50a++)
                    {
                        //check if the sequenceA has an field 50a
                        XmlNode xNodeFieldSeqAField50a = xNode.SelectSingleNode(arrSequenceAField50a[countAField50a]);

                        //Check if field 50a is not null
                        if (xNodeFieldSeqAField50a != null)
                        {
                            isPresent = true;
                            //Exit for loop
                            break;
                        }
                    }
                }

                XmlNodeList xListTagSeqB = xRoot.SelectNodes(xPathSequenceB);
                foreach (XmlNode xNode in xListTagSeqB)
                {
                    isSeqBField50a = false;

                    for (int countBField50a = 0; countBField50a < arrSequenceBField50a.Length; countBField50a++)
                    {
                        //check if the sequenceB has an field 50a
                        XmlNode xNodeFieldSeqBField50a = xNode.SelectSingleNode(arrSequenceBField50a[countBField50a]);

                        //Check if field 50a is not null
                        if (xNodeFieldSeqBField50a != null)
                            isSeqBField50a = true;

                    }

                    if ((isPresent == false && isSeqBField50a == false) || (isPresent == true && isSeqBField50a == true))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;

                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }


        /// <method>
        ///		SWIFTNetworkRule119
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 119.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xHeaderDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the header xml data of the instance to be validated.
        /// </param>
        /// <param name ="xPathSendersBIC" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathReceiversBIC1" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathReceiversBIC2" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathField57A" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathField59a" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="countryCodeList" type = "string">
        ///		Input containing the list of country codes.
        /// </param>
        /// <param name ="enableIBANValidation" type = "bool">
        ///		Input defining whether or not to enable IBAN Validation
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule119(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            Microsoft.RuleEngine.TypedXmlDocument xHeaderDocument,
            string xPathSendersBIC,
            string xPathReceiversBIC1,
            string xPathReceiversBIC2,
            string xPathField57A,
            string xPathField59a,
            string countryCodeList,
            bool enableIBANValidation,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule119" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isNode57APresent = false;
            try
            {
                if (xDocument == null ||
                    xPathSendersBIC == null ||
                    xPathSendersBIC.Length == 0 ||
                    xPathField57A == null ||
                    xPathField57A.Length == 0 ||
                    xPathField59a == null ||
                    xPathField59a.Length == 0 ||
                    countryCodeList == null ||
                    countryCodeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                if (xPathReceiversBIC1 == null && xPathReceiversBIC2 == null)
                {
                    return false;
                }
                if (null == xHeaderDocument) throw new ArgumentNullException("xHeaderDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNode xHeaderRoot = xHeaderDocument.Document;

                XmlNode xNodeSenderBIC = xHeaderRoot.SelectSingleNode(xPathSendersBIC);

                // The senders BIC is either in the "Input Application Header" or the "Output Application Header"
                // depending on whether the msg is going to SWIFt or coming from SWIFT. Hence find the correct
                // ReceiverBIC node.
                XmlNode xNodeReceiverBIC = xHeaderRoot.SelectSingleNode(xPathReceiversBIC1);
                if (xNodeReceiverBIC == null)
                {
                    xNodeReceiverBIC = xHeaderRoot.SelectSingleNode(xPathReceiversBIC2);
                    if (xNodeReceiverBIC == null)
                    {
                        return false;
                    }
                }

                // Check if field 57A is present or not.
                XmlNode xNode57A = xRoot.SelectSingleNode(xPathField57A);
                if (null != xNode57A)
                {
                    isNode57APresent = true;
                }

                if (xNodeSenderBIC != null && xNodeReceiverBIC != null)
                {
                    string senderCountry = xNodeSenderBIC.InnerText.Substring(4, 2);
                    string receiverCountry = xNodeReceiverBIC.InnerText.Substring(4, 2);

                    //If Senders BIC and Receivers BIC are part of the list of country codes, and 57A is not
                    // present, then IBAN is mandatory in the account field of 59a.
                    if ((countryCodeList.IndexOf(senderCountry) > 0) && (countryCodeList.IndexOf(receiverCountry) > 0))
                    {
                        // If 57A is present, check that the country code of field 57A equals
                        // one of the listed country codes..
                        if (isNode57APresent)
                        {
                            string countryCode57A = xNode57A.SelectSingleNode(@"./BankIdentifierCode/CountryCode").InnerText;
                            if (countryCodeList.IndexOf(countryCode57A) < 0)
                            {
                                return false;
                            }
                        }

                        return SWIFTNetworkRule119_Core(xRoot, xPathField59a,
                                errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber, errorObject);
                    }

                    //For all other cases - i.e. for any other combination of Sender BIC+ Receiver BIC+ 
                    // Field 57A + Field 59a - IBAN will be validated based on
                    // the BRE knob - the 10th Parameter in SWIFT_NetworkRule119_Policy.xml's
                    // "Action" method call. Setting it to "True" will enable validation if the
                    // Account field is present in Field 59a
                    else
                    {
                        if (enableIBANValidation)
                        {
                            return SWIFTNetworkRule119_Core(xRoot, xPathField59a,
                                    errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber, errorObject);
                        }
                    }

                }

                return true;

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        private static bool SWIFTNetworkRule119_Core(
                XmlNode xRoot,
                string xPathField59a,
                string errorCode,
                string policyName,
                string ruleName,
                string messageType,
                string conditionalRuleName,
                string conditionalRuleNumber,
                ErrorCollection errorObject)
        {
            //Retrieve the Field 59a, which supports 3 formats: option none, A, or F
            XmlNode xNode59a = xRoot.SelectSingleNode(xPathField59a);

            //Since Field 59a is Mandatory field return error is 59a is not present.
            // [waynek 9/24/15] this check is odd because Field 59a is unconditionally
            //	mandatory and enforced a priori by the schema; this error can never be
            //  hit and even if it did get hit, the error would be somewhat incorrect
            //  (this network rule should enforce the *subfield*, not the field itself)
            if (null == xNode59a)
            {
                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                return false;
            }

            // Get the IBAN Account Number
            string IBANAccountNumber = null;
            XmlNode xIBANAccntNode = xNode59a.SelectSingleNode("./Account/Account");
            if (null != xIBANAccntNode)
            {
                IBANAccountNumber = xIBANAccntNode.InnerText;
            }

            // We do not log any error here because the Account Number is
            // an optional subfield within Field 59a.
            if (null == IBANAccountNumber || IBANAccountNumber.Length == 0)
            {
                return false;
            }

            // The Account Data might have multiple "/" as the character is a
            // valid X Charset data. We spli the string on "/" and pick the last
            // part which will always be the account number.
            string[] IBANAccountArray = IBANAccountNumber.Split(Constants.CHRSLASH);
            string IBANAccount = IBANAccountArray[IBANAccountArray.Length - 1];

            // Validate IBAN - Note that the knob provided will not be used for 
            // the two cases where IBAN Validation is Mandatory.					 
            bool isValidIBAN = A4SWIFTIBANValidator(IBANAccount);
            if (isValidIBAN)
            {
                return true;
            }
            else
            {
                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                return false;
            }
        }


        /// <method>
        ///		SWIFTNetworkRule2
        /// </method>
        /// <summary>
        ///		The currency code in the specified fields must be the same for all occurrences of these
        ///		fields in the message	(Error code(s): C02).
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPath">
        ///		Reference path to the Currency code
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule2(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule2" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            int lengthxPath = 0;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                if (null == xPath) throw new ArgumentNullException("xPath");

                string currencyCode = string.Empty;

                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);

                lengthxPath = xPathArray.Length;

                XmlNode xRoot = xDocument.Document;

                for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                {
                    XmlNodeList xList = xRoot.SelectNodes(xPathArray[nCount].ToString());
                    if (xList.Count != 0)
                    {
                        if (currencyCode.CompareTo(Constants.BLANK) == 0)
                        {
                            currencyCode = xList.Item(0).Value.ToString().Trim();
                        }

                        foreach (XmlNode xNode in xList)
                        {
                            if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                            {
                                if (xNode.InnerText.CompareTo(currencyCode) != 0)
                                {
                                    isValid = false;
                                }
                            }
                            else
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNode.ParentNode.ParentNode.Name, Constants.NOCONTENT);
                                isValid = false;
                                return isValid;
                            }
                        }
                    }
                }
                if (isValid == false)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		IsValidCode
        /// </method>
        /// <summary>
        ///		This method performs validation for fields where validation is, if Data Source Scheme is specified value
        ///		and qualifier has specified value,
        ///		indicator must contain one of the codes in the string array(Error code 'Not Defined').
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the Qualifier field.
        /// </param>
        /// <param name ="Qualifier" type = "string">
        ///		Value of the Qualifier
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Reference path for DataSourceScheme
        /// </param>
        /// <param name ="DataSourceScheme" type = "string">
        ///		Value of DataSourceScheme
        /// </param>
        /// <param name ="xPathCode" type = "string">
        ///		Reference path for Indicator
        /// </param>
        /// <param name ="codeList" type = "string">
        ///		Values expected for indicator
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidCode(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathQualifier,
            string Qualifier,
            string xPathDataSourceScheme,
            string DataSourceScheme,
            string xPathCode,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCode" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {

                string code = string.Empty;
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathCode == null ||
                    xPathCode.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTag = xRoot.SelectNodes(xPathTag);

                foreach (XmlNode xNode in xListTag)
                {
                    //check if the node has an DataSourceScheme tag
                    XmlNode xNodeField = xNode.SelectSingleNode(xPathDataSourceScheme);

                    //Check if DataSourceScheme is not null
                    if (xNodeField != null)
                    {
                        if (xNode.SelectSingleNode(xPathQualifier).InnerText.CompareTo(Qualifier) == 0 && xNode.SelectSingleNode(xPathDataSourceScheme).InnerText.CompareTo(DataSourceScheme) == 0)
                        {

                            code = xNode.SelectSingleNode(xPathCode).InnerText;
                            //Check for the presence of the code value in the codelist. If not present report error
                            if ((codeList.IndexOf(code) == -1) || (code == Constants.BLANK))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNode.Name, code);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;

        }

        /// <method>
        /// SWIFTNetworkRule178
        /// </method>
        /// <summary>
        /// 	This function performs Conditional Rule D78 Validation(for messages MT416) which ensures that ,
        /// 	field 23E must be present in either SequenceA or
        /// 	every occurrence of the repetitive sequence B
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPathSequence" type = "string">
        /// 	Input containing the xpath of SequenceB
        /// </param>
        /// <param name="xPathTagSequenceA" type = "string">
        /// 	Input containing the xpath of Tag 23E of SequenceA.
        /// </param>
        /// <param name="xPathTagSequenceB" type = "string">
        /// 	Input containing the xpath of Tag 23E of SequenceB.
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Inutput containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule178(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTagSequenceA,
            string xPathTagSequenceB,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule178" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTagSequenceA == null ||
                    xPathTagSequenceB == null ||
                    xPathTagSequenceA.Length == 0 ||
                    xPathTagSequenceB.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                int countSeqBRepetition = 0;
                int countTag23ERep = 0;

                XmlNode xRoot = xDocument.Document;


                if (xRoot.SelectSingleNode(xPathTagSequenceA) != null)
                {
                    XmlNodeList xListSequence = xRoot.SelectNodes(xPathTagSequenceB);
                    if (xListSequence.Count != 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }


                else
                {
                    XmlNodeList xListSequenceB = xRoot.SelectNodes(xPathSequence);
                    countSeqBRepetition = xListSequenceB.Count;

                    XmlNodeList xListTag = xRoot.SelectNodes(xPathTagSequenceB);
                    countTag23ERep = countTag23ERep + xListTag.Count;

                    if (countTag23ERep != countSeqBRepetition)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        /// 	SWIFTNetworkRule183
        /// </method>
        /// <summary>
        /// 	This function performs Conditional Rule D83 Validation(for messages MT416) which ensures that ,
        /// 	field 71F and 77F independently must be present in either SequenceA or Sequence B
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPathTagSequenceA" type = "string">
        /// 	Input containing the xpath of Tag of SequenceA.
        /// </param>
        /// <param name="xPathTagSequenceB" type = "string">
        /// 	Input containing the xpath of Tag of SequenceB.
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Inutput containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule183(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTagSequenceA,
            string xPathTagSequenceB,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule183" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTagSequenceA == null ||
                    xPathTagSequenceB == null ||
                    xPathTagSequenceA.Length == 0 ||
                    xPathTagSequenceB.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                if (xRoot.SelectSingleNode(xPathTagSequenceA) != null)
                {
                    XmlNodeList xListTag = xRoot.SelectNodes(xPathTagSequenceB);
                    if (xListTag.Count != 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule54
        /// </method>
        /// <summary>
        /// At least one of fields 36 or 37 (A-F) must be present in each sequence B within the message
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path to the sequenceB
        /// </param>
        /// <param name="xPath1">
        ///		Reference path to field 36 in sequenceB
        /// </param>
        /// <param name="xPath2">
        ///		Reference path to field 37a in sequenceB
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        ///	<param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule54(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPath1,
            string xPath2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule54" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                bool isPresent = false;

                string[] xPathArray = xPath2.Split(Constants.CHRCOMMA);
                int lengthxPath = xPathArray.Length;

                XmlNodeList xListSeq = xRoot.SelectNodes(xPathSequenceB);

                foreach (XmlNode xNode in xListSeq)
                {
                    if (xNode.SelectSingleNode(xPath1) == null)
                    {
                        for (int i = 0; i <= lengthxPath - 1; i++)
                        {
                            if (xNode.SelectSingleNode(xPathArray[i]) != null)
                            {
                                isPresent = true;
                            }
                        }
                    }
                    else
                    {
                        isPresent = true;
                    }

                }

                if (isPresent == false)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule55
        /// </method>
        /// <summary>
        /// In any sequence B, the currency code in fields 33B and 34a must be the same
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference path to the sequenceB
        /// </param>
        /// <param name="xPath1">
        ///		Reference path to field 33B in sequenceB
        /// </param>
        /// <param name="xPath2">
        ///		Reference path to field 34a in sequenceB
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        ///	<param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule55(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPath1,
            string xPath2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule55" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                string currencyCode1 = null;
                string currencyCode2 = null;

                string[] xPathArray = xPath2.Split(Constants.CHRCOMMA);
                int lengthxPath = xPathArray.Length;

                XmlNodeList xListSeq = xRoot.SelectNodes(xPathSequenceB);

                foreach (XmlNode xNode in xListSeq)
                {

                    if (xNode.SelectSingleNode(xPath1) != null)
                    {
                        if (xNode.SelectSingleNode(xPath1).FirstChild != null)
                        {
                            if (xNode.SelectSingleNode(xPath1).FirstChild.InnerText != null)
                            {
                                currencyCode1 = xNode.SelectSingleNode(xPath1).FirstChild.InnerText;
                            }
                        }
                    }

                    for (int i = 0; i < lengthxPath - 1; i++)
                    {
                        if (xNode.SelectSingleNode(xPathArray[i]) != null)
                        {
                            if (xNode.SelectSingleNode(xPathArray[i]).InnerText != null)
                            {
                                currencyCode2 = xNode.SelectSingleNode(xPathArray[i]).InnerText.Substring(6, 3);
                            }
                        }
                    }
                }

                if (currencyCode1 != null && currencyCode2 != null)
                {
                    if (currencyCode1.CompareTo(currencyCode2) != 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule294
        ///	</method>
        /// <summary>
        ///		This method performs validation for SequenceB2 (xPathSequence) that should not be repeated.
        ///		Field 93a (xPath93a) should not be present in SubSequence B2
        ///		Subsequence E1 and SubSequence E2 (xPathSequenceNotAllowed) must not be present.(Error code(s): E94)
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the element to be validated (SequenceB2).
        /// </param>
        /// <param name="xPath93a">
        ///		Input reference of the element (./Balance_B2_93B,./Balance_B2_93C) to be validated.
        /// </param>
        /// <param name ="xPathSequenceE1" type = "string">
        ///		Input reference of the element (SequenceE1).
        /// </param>
        /// <param name="xPath36B">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathSequenceE2" type = "string">
        ///		Input reference of the element (SequenceE2).
        /// </param>
        /// <param name="xPath19b">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        ///		For e.g. SWIFT_NetworkRule294_Policy
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the Rule name.
        ///		For e.g. Validate_MT564
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT564
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Input containing Conditional Rule Name
        ///		For e.g. C2
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input containing Conditional Rule Number
        /// 	For e.g. Rule 294
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule294(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath93a,
            string xPathSequenceE1,
            string xPath36B,
            string xPathSequenceE2,
            string xPath19b,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule294" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPath93a) throw new ArgumentNullException("xPath93a");

                bool isPresent = true;
                string[] xPathArray = xPath93a.Split(Constants.CHRCOMMA);

                int lengthxPath = 0;

                lengthxPath = xPathArray.Length;

                if (xDocument == null ||
                    xPathSequence == null ||

                    xPathSequence.Length == 0 ||

                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                XmlNodeList xListSequenceE1 = xRoot.SelectNodes(xPathSequenceE1);
                XmlNodeList xListSequenceE2 = xRoot.SelectNodes(xPathSequenceE2);

                if (xListSequence != null)
                {
                    int countSequence = xListSequence.Count;
                    //If xPathSequence Count occurs more than once then raise an error
                    if (xListSequence.Count > 1)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isPresent = false;
                    }

                    //If 93a occurs then raise an error
                    XmlNode xNodeSequence = xListSequence[0];
                    for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                    {
                        XmlNodeList xList = xNodeSequence.SelectNodes(xPathArray[nCount].ToString());
                        if (xList.Count != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isPresent = false;
                        }
                    }
                }

                if (xListSequenceE1 != null)
                {

                    for (int nCount = 0; nCount <= xListSequenceE1.Count - 1; nCount++)
                    {
                        XmlNode xNodeSequenceE1 = xListSequenceE1[nCount];
                        XmlNodeList xList = xNodeSequenceE1.SelectNodes(xPath36B.ToString());
                        if (xList.Count != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isPresent = false;
                        }
                    }
                }

                if (xListSequenceE2 != null)
                {

                    for (int nCount = 0; nCount <= xListSequenceE2.Count - 1; nCount++)
                    {
                        XmlNode xNodeSequenceE2 = xListSequenceE2[nCount];
                        XmlNodeList xList = xNodeSequenceE2.SelectNodes(xPath19b.ToString());
                        if (xList.Count != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isPresent = false;
                        }
                    }
                }


                if (isPresent == false)
                {
                    isValid = false;
                }


                return isValid;
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        /// <method>
        ///		SWIFTNetworkRule211
        ///	</method>
        /// <summary>
        ///		If the message is an additional business process (:23G::ADDB) then sequence D Corporate Action Details is mandatory, and in sequence D, field :22F::ADDB is mandatory, only one occurrence is allowed, and it must either contain code CLAI (Claim or Compensation), TAXR (Tax Refund) or REVR (Notification or Reversal)(Error code(s): E11). 
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B.
        /// </param>
        /// <param name ="xPathTag23G" type = "string">
        ///		Input reference of the Element 22G in Sequence A.
        /// </param>
        /// <param name ="xPathFunction" type = "string">
        ///		Input reference of the function in tag 23G.
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the Element 22F in Sequence D.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="qualifier22F" type = "string">
        ///		Reference containing the value of the Type for xPathQualifier.
        /// </param> 
        /// <param name ="xPathCode" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="code" type = "string">
        ///		Reference containing the value of the Type for xPathCode.
        ///	</param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule211(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag23G,
            string xPathFunction,
            string xPathDataSourceScheme,
            string xPath22F,
            string xPathQualifier,
            string qualifier22F,
            string xPathCode,
            string codes,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule211" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath22F == null ||
                    xPathSequence == null ||
                    xPathQualifier == null ||
                    xPathCode == null ||
                    xPath22F.Length == 0 ||
                    xPathSequence.Length == 0 ||
                    xPathQualifier.Length == 0 ||
                    xPathCode.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPathSequence);
                XmlNode xNodeTag23G = xRoot.SelectSingleNode(xPathTag23G);

                if (xNodeTag23G.SelectSingleNode(xPathFunction).InnerText.CompareTo(qualifier22F) == 0)
                {

                    int xListCount = xList.Count;
                    if (xListCount == 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                    else
                    {
                        foreach (XmlNode xNode in xList)
                        {
                            XmlNodeList xTagList = xNode.SelectNodes(xPath22F);
                            int count = 0;
                            foreach (XmlNode xTagNode in xTagList)
                            {
                                if (xTagNode.SelectSingleNode(xPathQualifier) != null)
                                {
                                    if (xTagNode.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifier22F) == 0)
                                    {
                                        count++;

                                        if (xTagNode.SelectSingleNode(xPathDataSourceScheme) == null)
                                        {
                                            if (xTagNode.SelectSingleNode(xPathCode) != null)
                                            {
                                                string xNode22FCode = xTagNode.SelectSingleNode(xPathCode).InnerText;
                                                //Check for the presence of the code value in the indicator value. If not present report error

                                                if ((codes.IndexOf(xNode22FCode) == -1) || (xNode22FCode == Constants.BLANK))
                                                {
                                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                    isValid = false;

                                                }
                                            }

                                        }
                                    }
                                }
                            }

                            if (count > 1)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;

                            }
                        }

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule202
        /// </method>
        /// <summary>
        ///		This method performs validation for field function.
        ///		when sequence C (xPathSequenceC) is present, field :36a::QINT (xPathSequenceCField36a) is mandatory;
        ///		in each occurrence of subsequence E1 (xPathSequenceE1), field : 36B: :ENTL (xPathSequenceE1Field36B) is mandatory;
        ///		in each occurrence of subsequence E2 (xPathSequenceE2), field :19A::ENTL (xPathSequenceE2Field19AQualifier) is mandatory (Error code(s): E02).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequenceC">
        ///		Input reference of the element to be validated (SequenceC).
        /// </param>
        /// <param name="xPathSequenceCField36a">
        ///		Input reference of the element to be validated (./QuantityOfFinancialInstrument_C_36B,./QuantityOfFinancialInstrument_C_36E).
        /// </param>
        /// <param name="xPathSequenceE1">
        ///		Input reference of the element to be validated (SequenceE1).
        /// </param>
        /// <param name="xPathSequenceE1Field36B">
        ///		Input reference of the element to be validated (./QuantityOfFinancialInstrument_E1_36B).
        /// </param>
        /// <param name="xPathSequenceE2">
        ///		Input reference of the element to be validated (SequenceE2).
        /// </param>
        /// <param name="xPathSequenceE2Field19AQualifier">
        ///		Input reference of the element to be validated (./Amount_E2_19A/Qualifier).
        /// </param>
        /// <param name="qualifierValueSeqE2Field19A">
        ///		Input containing the qualifier value for field element(./Amount_E2_19A/Qualifier).
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        ///		For e.g. SWIFT_NetworkRule202_Policy
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the Rule name.
        ///		For e.g. Validate_MT564
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT564
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Input containing Conditional Rule Name
        ///		For e.g. C3
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input containing Conditional Rule Number
        /// 	For e.g. Rule 202
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule202(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceC,
            string xPathSequenceCField36a,
            string xPathSequenceE1,
            string xPathSequenceE1Field36B,
            string xPathSequenceE2,
            string xPathSequenceE2Field19AQualifier,
            string qualifierValueSeqE2Field19A,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule202" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            if (null == xPathSequenceCField36a) throw new ArgumentNullException("xPathSequenceCField36a");

            bool isValid = true;
            bool isPresent = true;

            string[] xPathArray = xPathSequenceCField36a.Split(Constants.CHRCOMMA);

            int lengthxPathC = 0;
            lengthxPathC = xPathArray.Length;
            try
            {
                if (xDocument == null ||
                    xPathSequenceC == null ||
                    xPathSequenceCField36a == null ||
                    xPathSequenceE1 == null ||
                    xPathSequenceE1Field36B == null ||
                    xPathSequenceE2 == null ||
                    xPathSequenceE2Field19AQualifier == null ||
                    qualifierValueSeqE2Field19A == null ||
                    xPathSequenceC.Length == 0 ||
                    xPathSequenceCField36a.Length == 0 ||
                    xPathSequenceE1.Length == 0 ||
                    xPathSequenceE1Field36B.Length == 0 ||
                    xPathSequenceE2.Length == 0 ||
                    xPathSequenceE2Field19AQualifier.Length == 0 ||
                    qualifierValueSeqE2Field19A.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequenceC = xRoot.SelectNodes(xPathSequenceC);
                int countSequence = xListSequenceC.Count;

                //If Seq C is present and QINT qualifier not exist for tag 36a then raise an error.
                if (xListSequenceC.Count != 0)
                {
                    bool isField36aPresent = false;
                    XmlNode xNodeSequenceC = xListSequenceC[0];
                    for (int nCount = 0; nCount <= lengthxPathC - 1; nCount++)
                    {
                        XmlNodeList xList = xNodeSequenceC.SelectNodes(xPathArray[nCount].ToString());
                        if (xList.Count != 0)
                        {
                            isField36aPresent = true;
                            break;
                        }
                    }
                    if (isField36aPresent == false)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isPresent = false;
                    }
                }

                /* THIS CONDITION IS INVALID PER SRG 2005. Commenting it hence.
                //In each occurrence of E1, if :36B::ENTL is not present then raise an error
                XmlNodeList xListSequenceE1 = xRoot.SelectNodes(xPathSequenceE1);
                foreach(XmlNode xNodeSequenceE1 in xListSequenceE1)
                {
                    XmlNodeList xNode36BList = xNodeSequenceE1.SelectNodes(xPathSequenceE1Field36B);
                    if (xNode36BList.Count == 0)
                    {
                        errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
                        isPresent = false;
                    }
                }

                //In each occurrence of E2, if :19A::ENTL is not present then raise an error
                XmlNodeList xListSequenceE2 = xRoot.SelectNodes(xPathSequenceE2);
                foreach(XmlNode xNodeSequenceE2 in xListSequenceE2)
                {
                    XmlNodeList xNode19AList = xNodeSequenceE2.SelectNodes(xPathSequenceE2Field19AQualifier);
                    bool bIsReqd19AFound = false;
                    foreach(XmlNode xNode in xNode19AList)
                    {
                        if(xNode.FirstChild != null)
                        {
                            if(xNode.FirstChild.InnerText.CompareTo(qualifierValueSeqE2Field19A) == 0)
                            {
                                bIsReqd19AFound = true;
                                break;
                            }
                        }
                    }

                    if(!bIsReqd19AFound)
                    {
                        errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
                        isPresent = false;
                    }
                }
                */

                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        public static bool SWIFTNetworkRule224(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceD,
            string xPathSequenceE1,
            string xPathSequenceE2,
            string xPathSequenceDField98a,
            string qualifierValueSeqDField98a,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule224" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;

            string[] xPathArray = xPathSequenceDField98a.Split(Constants.CHRCOMMA);

            int lengthxPathD = 0;
            lengthxPathD = xPathArray.Length;
            try
            {
                if (xDocument == null ||
                    xPathSequenceD == null ||
                    xPathSequenceDField98a == null ||
                    qualifierValueSeqDField98a == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequenceD = xRoot.SelectNodes(xPathSequenceD);

                if (xListSequenceD.Count != 0)
                {
                    bool isField98aPresent = false;
                    XmlNode xNodeSequenceD = xListSequenceD[0];
                    for (int nCount = 0; nCount <= lengthxPathD - 1; nCount++)
                    {
                        XmlNodeList xList = xNodeSequenceD.SelectNodes(xPathArray[nCount].ToString());
                        foreach (XmlNode xNode in xList)
                        {
                            if (xNode.InnerText.CompareTo(qualifierValueSeqDField98a) == 0)
                            {
                                isField98aPresent = true;
                                break;
                            }

                        }
                    }
                    if (isField98aPresent == true)
                    {
                        XmlNodeList xListSequenceE1 = xRoot.SelectNodes(xPathSequenceE1);
                        XmlNodeList xListSequenceE2 = xRoot.SelectNodes(xPathSequenceE2);

                        //If Seq 98a::PAYD is present and sequence E1 and E2 is also present then raise an error.
                        if (xListSequenceE1.Count != 0 || xListSequenceE2.Count != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }

                    }
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }
        /// <method>
        ///		SWIFTNetworkRule204
        /// </method>
        /// <summary>
        ///		This method performs validation for field 93a (xPathSequenceField93aQualifier) having qualifier value (qualifierValue) not present in any occurrence of SubSequence (xPathSequenceB2)
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequenceB2" type = "string">
        ///		Input reference of the element to be validated (SequenceB2).
        /// </param>
        /// <param name="xPathSequenceField93aQualifier">
        ///		Input reference of the field element (Qualifier) to be validated.
        /// </param>
        /// <param name="qualifierValue">
        ///		Reference containing the qualifier value.
        ///		For e.g. UNBA
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        ///		For e.g. SWIFT_NetworkRule204_Policy
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the Rule name.
        ///		For e.g. Validate_MT564
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT564
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Input containing Conditional Rule Name
        ///		For e.g. C6
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input containing Conditional Rule Number
        /// 	For e.g. Rule 204
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule204(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB2,
            string xPathSequenceField93aQualifier,
            string qualifierValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule204" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            if (null == xPathSequenceField93aQualifier) throw new ArgumentNullException("xPathSequenceField93aQualifier");

            bool isValid = true;
            bool isPresent = true;

            string[] xPathArray = xPathSequenceField93aQualifier.Split(Constants.CHRCOMMA);

            int lengthxPath = 0;
            lengthxPath = xPathArray.Length;
            try
            {
                if (xDocument == null ||
                    xPathSequenceB2 == null ||
                    xPathSequenceField93aQualifier == null ||
                    xPathSequenceB2.Length == 0 ||
                    xPathSequenceField93aQualifier.Length == 0 ||
                    qualifierValue == null ||
                    qualifierValue.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequenceB2 = xRoot.SelectNodes(xPathSequenceB2);

                //If :93a:UNBA is present in any occurrence of Seq B2 then raise an error

                foreach (XmlNode xNodeSequenceB2 in xListSequenceB2)
                {
                    for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                    {
                        XmlNodeList xNode93aList = xNodeSequenceB2.SelectNodes(xPathArray[nCount].ToString());

                        foreach (XmlNode xNode in xNode93aList)
                        {
                            if (xNode.FirstChild != null)
                            {
                                if (xNode.FirstChild.InnerText.CompareTo(qualifierValue) == 0)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isPresent = false;
                                }
                            }
                        }
                    }
                }
                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule205
        /// </method>
        /// <summary>
        ///		This method performs validation for field (xPathTag22F) having qualifier(xPathQualifier) value (qualifierValue), Indicator (xPathIndicator) value (indicatorValue) and DataSourceScheme (xPathDataSourceScheme) not present
        ///		If Sequence E (xPathSequenceE)is present, then in every occurrence of sequence E, field 13A (xPathField13A) must be present.(Error code(s): E05)
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag22F" type = "string">
        ///		Input reference of the element to be validated (Indicator_22F).
        /// </param>
        /// <param name="xPathDataSourceScheme">
        ///		Input reference of the field element (DataSourceScheme) which should not be present to be validated.
        /// </param>
        /// <param name="xPathIndicator">
        ///		Input reference of the field element (Indicator) to be validated.
        /// </param>
        /// <param name="xPathQualifier">
        ///		Input reference of the field element (Qualifier) to be validated.
        /// </param>
        /// <param name="qualifierValue">
        ///		Reference containing the qualifier value.
        ///		For e.g. CAMV
        /// </param>
        /// <param name="indicatorValue">
        ///		Reference containing the Indicator value for which Sequence C is not allowed.
        ///		For e.g. CHOS, VOLU
        /// </param>
        /// <param name="xPathSequenceE">
        ///		Input reference of the element to be validated (Sequence E).
        /// </param>
        /// <param name ="xPathField13A" type = "string">
        ///		Input reference of the element to be validated (./NumberIdentification_E_13A).
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        ///		For e.g. SWIFT_NetworkRule205_Policy
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the Rule name.
        ///		For e.g. Validate_MT564
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT564
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Input containing Conditional Rule Name
        ///		For e.g. C8
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input containing Conditional Rule Number
        /// 	For e.g. Rule 205
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule205(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag22F,
            string xPathDataSourceScheme,
            string xPathIndicator,
            string xPathQualifier,
            string qualifierValue,
            string indicatorValue,
            string xPathSequenceE,
            string xPathField13A,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule205" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isPresent = true;
            string code = string.Empty;
            try
            {
                if (xDocument == null ||
                    xPathTag22F == null ||
                    xPathDataSourceScheme == null ||
                    xPathIndicator == null ||
                    xPathQualifier == null ||
                    qualifierValue == null ||
                    indicatorValue == null ||
                    xPathSequenceE == null ||
                    xPathField13A == null ||
                    xPathTag22F.Length == 0 ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathIndicator.Length == 0 ||
                    xPathQualifier.Length == 0 ||
                    qualifierValue.Length == 0 ||
                    indicatorValue.Length == 0 ||
                    xPathSequenceE.Length == 0 ||
                    xPathField13A.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTag = xRoot.SelectNodes(xPathTag22F);

                foreach (XmlNode xNode in xListTag)
                {
                    if (xNode.SelectSingleNode(xPathQualifier) != null)
                    {
                        if (xNode.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifierValue) == 0)
                        {
                            //check if the node has an DataSourceScheme tag
                            XmlNode xNodeField = xNode.SelectSingleNode(xPathDataSourceScheme);

                            //Since the DataSourceScheme is not present, check for validity of code
                            if (xNodeField == null)
                            {
                                if (xNode.SelectSingleNode(xPathIndicator) != null)
                                {
                                    code = xNode.SelectSingleNode(xPathIndicator).InnerText;
                                    //Check for the presence of the code value in the indicator value. If not present report error
                                }
                                if ((indicatorValue.IndexOf(code) == -1) || (code == Constants.BLANK))
                                {
                                    return isValid;
                                }
                                else
                                {
                                    XmlNodeList xListSequenceE = xRoot.SelectNodes(xPathSequenceE);

                                    //If :13A:CAON is not present in every occurrence of Seq E then raise an error

                                    foreach (XmlNode xNodeSequenceE in xListSequenceE)
                                    {
                                        XmlNodeList xNode13AList = xNodeSequenceE.SelectNodes(xPathField13A);
                                        if (xNode13AList.Count == 0)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isPresent = false;
                                        }

                                    }
                                }
                            }
                        }
                    }
                }

                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule206_SRG2006
        /// </method>
        /// <summary>
        /// If field :22F::CAEV//RHDI is present in sequence A, then field :22F::RHDI must be present in 
        /// sequence D or in at least one occurrence of sequence E, but not in both D and E. 
        /// (Error code(s): E06).
        /// </summary>
        /// <param name="xDocument">
        ///		Input Reference to XML document
        /// </param>
        /// <param name="xPathSequenceA">
        ///		Input Reference to Sequence A
        /// </param>
        /// <param name="xPathIndicatorA22F">
        ///		Input xPath of Indicator field of the SequenceA
        /// </param>
        /// <param name="xPathQualifierA22F">
        ///		Input xPath of Qualifier of the field
        /// </param>
        /// <param name="xPathQualifierValueA22F">
        ///		Qualifier codelist of the field A 22F
        /// </param>
        /// <param name="xPathIndicator">
        ///		Input xPath of Indicator of the field
        /// </param>
        /// <param name="xPathIndicatorValue">
        ///		Indicator codelist of the field A 22F
        /// </param>
        /// <param name="xPathDataSourceScheme">
        ///		Input xPath of DataSourceScheme
        /// </param>
        /// <param name="xPathSequenceD">
        ///		Input Reference to Sequence D
        /// </param>
        /// <param name="xPathSequenceE">
        ///		Input Reference to Sequence E
        /// </param>
        /// <param name="xPathIndicatorD22F">
        ///		Input xPath of Indicator field D 22F
        /// </param>
        /// <param name="xPathQualifierD22F">
        ///		Input xPath of Qualifier of the field D 22F
        /// </param>
        /// <param name="xPathQualifierValueD22F">
        ///		Qualifier codelist of the field D 22F
        /// </param>
        /// <param name="xPathIndicatorE22F">
        ///		Input xPath of Indicator field E 22F
        /// </param>
        /// <param name="xPathQualifierE22F">
        ///		Input xPath of Qualifier of the field E 22F
        /// </param>
        /// <param name="xPathQualifierValueE22F">
        ///		Qualifier codelist of the field E 22F
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        /// 	The Message Type that callls the function
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	ConditionalRule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	ConditionalRule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule206_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceA,
            string xPathIndicatorA22F,
            string xPathQualifierA22F,
            string xPathQualifierValueA22F,
            string xPathIndicator,
            string xPathIndicatorValue,
            string xPathDataSourceScheme,
            string xPathSequenceD,
            string xPathSequenceE,
            string xPathIndicatorD22F,
            string xPathQualifierD22F,
            string xPathQualifierValueD22F,
            string xPathIndicatorE22F,
            string xPathQualifierE22F,
            string xPathQualifierValueE22F,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule206_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;

            // requiresRuleValidation is used to check whether the rule should be validated or not.
            bool requiresRuleValidation = false;

            #region "Check for null parameters"
            try
            {
                if (xDocument == null ||
                    xPathSequenceA == null ||
                    xPathSequenceA.Length == 0 ||
                    xPathIndicatorA22F == null ||
                    xPathIndicatorA22F.Length == 0 ||
                    xPathQualifierA22F == null ||
                    xPathQualifierA22F.Length == 0 ||
                    xPathQualifierValueA22F == null ||
                    xPathQualifierValueA22F.Length == 0 ||
                    xPathIndicator == null ||
                    xPathIndicator.Length == 0 ||
                    xPathIndicatorValue == null ||
                    xPathIndicatorValue.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathSequenceD == null ||
                    xPathSequenceD.Length == 0 ||
                    xPathSequenceE == null ||
                    xPathSequenceE.Length == 0 ||
                    xPathIndicatorD22F == null ||
                    xPathIndicatorD22F.Length == 0 ||
                    xPathQualifierD22F == null ||
                    xPathQualifierD22F.Length == 0 ||
                    xPathQualifierValueD22F == null ||
                    xPathQualifierValueD22F.Length == 0 ||
                    xPathIndicatorE22F == null ||
                    xPathIndicatorE22F.Length == 0 ||
                    xPathQualifierE22F == null ||
                    xPathQualifierE22F.Length == 0 ||
                    xPathQualifierValueE22F == null ||
                    xPathQualifierValueE22F.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
            #endregion "Check for null parameters"

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;

                // getting the nodes for the SequenceA
                XmlNodeList xListTag = xRoot.SelectNodes(xPathSequenceA);
                foreach (XmlNode xNode in xListTag)
                {
                    // Geting the nodes for the field 22F
                    XmlNodeList xListFields = xNode.SelectNodes(xPathIndicatorA22F);
                    foreach (XmlNode xList in xListFields)
                    {
                        // Getting the values of he Qualifier, Indicator and the DataSourceScheme
                        XmlNode xNodeQualifierA22F = xList.SelectSingleNode(xPathQualifierA22F);
                        XmlNode xNodeindicatorA22F = xList.SelectSingleNode(xPathIndicator);
                        XmlNode xNodeDataSourceSchemeA22F = xList.SelectSingleNode(xPathDataSourceScheme);

                        // Checking for the field DATA as per the rule
                        if (xNodeQualifierA22F != null && xNodeQualifierA22F.InnerText.CompareTo(xPathQualifierValueA22F) == 0
                            && xNodeindicatorA22F != null && xNodeindicatorA22F.InnerText.CompareTo(xPathIndicatorValue) == 0
                            && xNodeDataSourceSchemeA22F == null)
                        {
                            // If the Data in the field is found to be same then the rule need to be validated
                            requiresRuleValidation = true;
                            break;
                        }
                        requiresRuleValidation = false;
                    }

                    if (requiresRuleValidation)
                    {
                        break;
                    }
                }

                // Checking the conditions for the validation of the rule
                if (requiresRuleValidation)
                {
                    //Condition 1
                    // Checking the Sequence D's existence and the Data in the field 22F

                    // nodeFound is used to check whether the next level velidation should be done or not.
                    bool nodeFound = false;

                    XmlNodeList xListD = xRoot.SelectNodes(xPathSequenceD);
                    if (xListD != null && xListD.Count > 0)
                    {
                        foreach (XmlNode xNodeD in xListD)
                        {
                            XmlNodeList xListFields = xNodeD.SelectNodes(xPathIndicatorD22F);
                            foreach (XmlNode xList in xListFields)
                            {
                                XmlNode xNodeQualifierD22F = xList.SelectSingleNode(xPathQualifierD22F);
                                // Comparing the value of the field.
                                if (xNodeQualifierD22F != null &&
                                    xNodeQualifierD22F.InnerText.CompareTo(xPathQualifierValueD22F) == 0)
                                {
                                    // Setting the nodeFound = true is the value is found in Sequence D's field 22F
                                    nodeFound = true;
                                    break;
                                }
                            }
                            if (nodeFound)
                            {
                                break;
                            }
                        }
                    }

                    XmlNodeList xListE = xRoot.SelectNodes(xPathSequenceE);

                    //Condition 2
                    // Checking the field and the Data in the Sequence E and field 22F
                    if (nodeFound)
                    {
                        // Checking that there should not be 22F field in Sequence E with the Data as per the rule

                        if (xListE != null && xListE.Count > 0)
                        {
                            foreach (XmlNode xNodeE in xListE)
                            {
                                XmlNodeList xListFields = xNodeE.SelectNodes(xPathIndicatorE22F);
                                foreach (XmlNode xList in xListFields)
                                {
                                    XmlNode xNodeQualifierE22F = xList.SelectSingleNode(xPathQualifierE22F);
                                    if (xNodeQualifierE22F != null &&
                                        xNodeQualifierE22F.InnerText.CompareTo(xPathQualifierValueE22F) == 0)
                                    {
                                        // Setting isValid = false if the field is found to contain the value
                                        isValid = false;
                                        break;
                                    }
                                }
                                if (!isValid)
                                {
                                    // No need to move further once the field is found with the data.
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        // Checking that the Sequence E should exist and that the field 22F should contain the 
                        // data mentioned in the rule

                        if (xListE == null || xListE.Count == 0)
                        {
                            // Setting isValid = false if Sequence E is not found
                            isValid = false;
                        }
                        else
                        {
                            foreach (XmlNode xNodeE in xListE)
                            {
                                XmlNodeList xListFields = xNodeE.SelectNodes(xPathIndicatorE22F);
                                foreach (XmlNode xList in xListFields)
                                {
                                    XmlNode xNodeQualifierE22F = xList.SelectSingleNode(xPathQualifierE22F);
                                    if (xNodeQualifierE22F != null &&
                                        xNodeQualifierE22F.InnerText.CompareTo(xPathQualifierValueE22F) == 0)
                                    {
                                        // Setting isValid = true if the field is found to contain the value
                                        isValid = true;
                                        break;
                                    }
                                    else
                                    {
                                        isValid = false;
                                    }
                                }
                                if (isValid)
                                {
                                    // Breaking from the loop if isValid is true
                                    break;
                                }
                            }
                        }
                    }
                }
                if (!isValid)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule206_SRG2006
        /// </method>
        /// <summary>
        /// If field :22F::CAEV//RHDI is present in sequence A, then Sequence C is Mandatory and 
        /// field :22F::RHDI must be present in sequence C (Error code(s): E06).
        /// </summary>
        /// <param name="xDocument">
        ///		Input Reference to XML document
        /// </param>
        /// <param name="xPathSequenceA">
        ///		Input Reference to Sequence A
        /// </param>
        /// <param name="xPathIndicatorA22F">
        ///		Input xPath of Indicator field of the SequenceA
        /// </param>
        /// <param name="xPathQualifierA22F">
        ///		Input xPath of Qualifier of the field
        /// </param>
        /// <param name="xPathQualifierValueA22F">
        ///		Qualifier codelist of the field A 22F
        /// </param>
        /// <param name="xPathIndicator">
        ///		Input xPath of Indicator of the field
        /// </param>
        /// <param name="xPathIndicatorValue">
        ///		Indicator codelist of the field A 22F
        /// </param>
        /// <param name="xPathDataSourceScheme">
        ///		Input xPath of DataSourceScheme
        /// </param>
        /// <param name="xPathSequenceC">
        ///		Input Reference to Sequence C
        /// </param>
        /// <param name="xPathIndicatorC22F">
        ///		Input xPath of Indicator field C 22F
        /// </param>
        /// <param name="xPathQualifierC22F">
        ///		Input xPath of Qualifier of the field C 22F
        /// </param>
        /// <param name="xPathQualifierValueC22F">
        ///		Qualifier codelist of the field C 22F
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        /// 	The Message Type that callls the function
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	ConditionalRule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	ConditionalRule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule206_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceA,
            string xPathIndicatorA22F,
            string xPathQualifierA22F,
            string xPathQualifierValueA22F,
            string xPathIndicator,
            string xPathIndicatorValue,
            string xPathDataSourceScheme,
            string xPathSequenceC,
            string xPathIndicatorC22F,
            string xPathQualifierC22F,
            string xPathQualifierValueC22F,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule206_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;

            // requiresRuleValidation is used to check whether the rule should be validated or not.
            bool requiresRuleValidation = false;

            #region "Check for null parameters"
            try
            {
                if (xDocument == null ||
                    xPathSequenceA == null ||
                    xPathSequenceA.Length == 0 ||
                    xPathIndicatorA22F == null ||
                    xPathIndicatorA22F.Length == 0 ||
                    xPathQualifierA22F == null ||
                    xPathQualifierA22F.Length == 0 ||
                    xPathQualifierValueA22F == null ||
                    xPathQualifierValueA22F.Length == 0 ||
                    xPathIndicator == null ||
                    xPathIndicator.Length == 0 ||
                    xPathIndicatorValue == null ||
                    xPathIndicatorValue.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathSequenceC == null ||
                    xPathSequenceC.Length == 0 ||
                    xPathIndicatorC22F == null ||
                    xPathIndicatorC22F.Length == 0 ||
                    xPathQualifierC22F == null ||
                    xPathQualifierC22F.Length == 0 ||
                    xPathQualifierValueC22F == null ||
                    xPathQualifierValueC22F.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
            #endregion "Check for null parameters"

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;

                // getting the nodes for the SequenceA
                XmlNodeList xListTag = xRoot.SelectNodes(xPathSequenceA);
                foreach (XmlNode xNode in xListTag)
                {
                    // Geting the nodes for the field 22F
                    XmlNodeList xListFields = xNode.SelectNodes(xPathIndicatorA22F);
                    foreach (XmlNode xList in xListFields)
                    {
                        // Getting the values of he Qualifier, Indicator and the DataSourceScheme
                        XmlNode xNodeQualifierA22F = xList.SelectSingleNode(xPathQualifierA22F);
                        XmlNode xNodeindicatorA22F = xList.SelectSingleNode(xPathIndicator);
                        XmlNode xNodeDataSourceSchemeA22F = xList.SelectSingleNode(xPathDataSourceScheme);

                        // Checking for the field DATA as per the rule
                        if (xNodeQualifierA22F != null && xNodeQualifierA22F.InnerText.CompareTo(xPathQualifierValueA22F) == 0
                            && xNodeindicatorA22F != null && xNodeindicatorA22F.InnerText.CompareTo(xPathIndicatorValue) == 0
                            && xNodeDataSourceSchemeA22F == null)
                        {
                            // If the Data in the field is found to be same then the rule need to be validated
                            requiresRuleValidation = true;
                            break;
                        }
                        requiresRuleValidation = false;
                    }
                    if (requiresRuleValidation)
                    {
                        break;
                    }
                }

                // Checking the conditions for the validation of the rule
                if (requiresRuleValidation)
                {
                    // Checking the Sequence C's existence and the Data in the field 22F

                    XmlNodeList xListC = xRoot.SelectNodes(xPathSequenceC);
                    if (xListC == null || xListC.Count == 0)
                    {
                        isValid = false;
                    }
                    else
                    {
                        foreach (XmlNode xNodeC in xListC)
                        {
                            XmlNodeList xListFields = xNodeC.SelectNodes(xPathIndicatorC22F);
                            if (xListFields == null || xListFields.Count == 0)
                            {
                                isValid = false;
                                break;
                            }
                            foreach (XmlNode xList in xListFields)
                            {
                                XmlNode xNodeQualifierC22F = xList.SelectSingleNode(xPathQualifierC22F);
                                // Comparing the value of the field.
                                if (xNodeQualifierC22F != null &&
                                    xNodeQualifierC22F.InnerText.CompareTo(xPathQualifierValueC22F) == 0)
                                {
                                    // Setting the isValid = true is the value is found in Sequence C's 
                                    //field 22F
                                    isValid = true;
                                    break;
                                }
                                else
                                {
                                    isValid = false;
                                }
                            }
                            if (isValid)
                            {
                                break;
                            }
                        }
                    }
                }

                if (!isValid)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        ///
        /// <method>
        ///		SWIFTNetworkRule201
        /// </method>
        /// <summary>
        ///		This method performs validation for field Indicator,if Qualifier is a specified value and Data Source Scheme
        ///		is not present and Indicator has certain value then Sequence C is not allowed and for Indicator with certain
        ///		other value then Sequence C is mandatory(Error code 'E01').
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag22F" type = "string">
        ///		Input reference of the element to be validated (Indicator_22F).
        /// </param>
        /// <param name="xPathDataSourceScheme">
        ///		Input reference of the field element (DataSourceScheme) which should not be present to be validated.
        /// </param>
        /// <param name="xPathIndicator">
        ///		Input reference of the field element (Indicator) to be validated.
        /// </param>
        /// <param name="xPathQualifier">
        ///		Input reference of the field element (Qualifier) to be validated.
        /// </param>
        /// <param name="qualifierValue">
        ///		Reference containing the qualifier value.
        ///		For e.g. CAEV
        /// </param>
        /// <param name="indicatorValueNotSeqC">
        ///		Reference containing the Indicator value for which Sequence C is not allowed.
        ///		For e.g. RHDI
        /// </param>
        /// <param name="indicatorValueSeqC">
        ///		Reference containing the Indicator value for which Sequence C is mandatory.
        ///		For e.g. RHTS
        /// </param>
        /// <param name="indicatorValueNotSeqCAndE">
        ///		Reference containing the Indicator value for which Sequence C is mandatory.
        ///		For e.g. INFO
        /// </param>
        /// <param name="xPathSequenceC">
        ///		Input reference of the element to be validated (Sequence C).
        /// </param>
        /// <param name="xPathSequenceE">
        ///		Input reference of the element to be validated (Sequence E).
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        ///		For e.g. SWIFT_NetworkRule201_Policy
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the Rule name.
        ///		For e.g. Validate_MT564
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT564
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Input containing Conditional Rule Name
        ///		For e.g. C7
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input containing Conditional Rule Number
        /// 	For e.g. Rule 201
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule201(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag22F,
            string xPathDataSourceScheme,
            string xPathIndicator,
            string xPathQualifier,
            string qualifierValue,
            string indicatorValueNotSeqC,
            string indicatorValueSeqC,
            string indicatorValueNotSeqCAndE,
            string xPathSequenceC,
            string xPathSequenceE,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule201" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isPresent = true;
            try
            {
                if (xDocument == null ||
                    xPathTag22F == null ||
                    xPathDataSourceScheme == null ||
                    xPathIndicator == null ||
                    xPathQualifier == null ||
                    qualifierValue == null ||
                    indicatorValueNotSeqC == null ||
                    indicatorValueSeqC == null ||
                    indicatorValueNotSeqCAndE == null ||
                    xPathSequenceC == null ||
                    xPathSequenceE == null ||
                    xPathTag22F.Length == 0 ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathIndicator.Length == 0 ||
                    xPathQualifier.Length == 0 ||
                    qualifierValue.Length == 0 ||
                    indicatorValueNotSeqC.Length == 0 ||
                    indicatorValueSeqC.Length == 0 ||
                    indicatorValueNotSeqCAndE.Length == 0 ||
                    xPathSequenceC.Length == 0 ||
                    xPathSequenceE.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTag = xRoot.SelectNodes(xPathTag22F);

                foreach (XmlNode xNode in xListTag)
                {
                    if (xNode.SelectSingleNode(xPathQualifier) != null)
                    {
                        if (xNode.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifierValue) == 0)
                        {
                            //check if the node has an DataSourceScheme tag
                            XmlNode xNodeField = xNode.SelectSingleNode(xPathDataSourceScheme);

                            //Since the DataSourceScheme is not present, check for validity of code
                            if (xNodeField == null)
                            {
                                if (xNode.SelectSingleNode(xPathIndicator) != null)
                                {
                                    XmlNodeList xListSequenceC = xRoot.SelectNodes(xPathSequenceC);
                                    XmlNodeList xListSequenceE = xRoot.SelectNodes(xPathSequenceE);
                                    int countSeqC = xListSequenceC.Count;
                                    int countSeqE = xListSequenceE.Count;
                                    if (xNode.SelectSingleNode(xPathIndicator).InnerText.CompareTo(indicatorValueNotSeqC) == 0)
                                    {
                                        if (countSeqC > 0)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isPresent = false;
                                        }
                                    }
                                    if (xNode.SelectSingleNode(xPathIndicator).InnerText.CompareTo(indicatorValueSeqC) == 0)
                                    {
                                        if (countSeqC == 0)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isPresent = false;
                                        }
                                    }

                                    if (xNode.SelectSingleNode(xPathIndicator).InnerText.CompareTo(indicatorValueNotSeqCAndE) == 0)
                                    {
                                        if ((countSeqC > 0) || (countSeqE > 0))
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isPresent = false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule203
        /// </method>
        /// <summary>
        ///		This method performs validation for field 22F (xPathTag22F) having qualifier value (qualifier22FValue) and indicator value (indicatorValue).
        ///		if present, then in sequence D field 70E (xPathSeqDTag70E) having qualfier value ADTX (xPath70EQualifier) is mandatory (Error code(s): E03).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag22F" type = "string">
        ///		Input reference of the element to be validated (Indicator_A_22F).
        /// </param>
        /// <param name="xPathDataSourceScheme">
        ///		Input reference of the field element (DataSourceScheme) which should not be present to be validated.
        /// </param>
        /// <param name="xPathIndicator">
        ///		Input reference of the field element (Indicator) to be validated.
        /// </param>
        /// <param name="xPath22FQualifier">
        ///		Input reference of the field element (Qualifier) to be validated.
        /// </param>
        /// <param name="qualifier22FValue">
        ///		Reference containing the qualifier value.
        ///		For e.g. CAEV
        /// </param>
        /// <param name="indicatorValue">
        ///		Reference containing the Indicator value for which Sequence C is not allowed.
        ///		For e.g. OTHR
        /// </param>
        /// <param name="xPathSeqDTag70E">
        ///		Input reference of the element to be validated (Narrative_D_70E).
        /// </param>
        /// <param name="xPathSeqFTag70E">
        ///		Input reference of the element to be validated (Narrative_F_70E).
        /// </param>
        /// <param name="xPath70EQualifier">
        ///		Input reference of the element to be validated (Qualifier).
        /// </param>
        /// <param name="qualifier70EValue">
        ///		Reference containing the qualifier value.
        ///		For e.g. ADTX
        /// </param>
        /// <param name="XPathSequenceD">
        ///		Input reference of SequenceD
        /// </param>
        /// <param name="XPathSequenceF">
        ///		Input reference of SequenceF
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        ///		For e.g. SWIFT_NetworkRule203_Policy
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the Rule name.
        ///		For e.g. Validate_MT564
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT564
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Input containing Conditional Rule Name
        ///		For e.g. C4
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input containing Conditional Rule Number
        /// 	For e.g. Rule 203
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule203(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag22F,
            string xPathDataSourceScheme,
            string xPathIndicator,
            string xPath22FQualifier,
            string qualifier22FValue,
            string indicatorValue,
            string xPathSeqFTag70E,
            string xPath70EQualifier,
            string qualifier70EValue,
            string XPathSequenceF,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule203" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isPresent = true;
            bool isQualifierPresent = true;
            try
            {
                if (xDocument == null ||
                    xPathTag22F == null ||
                    xPathDataSourceScheme == null ||
                    xPathIndicator == null ||
                    xPath22FQualifier == null ||
                    qualifier22FValue == null ||
                    indicatorValue == null ||
                    xPath70EQualifier == null ||
                    qualifier70EValue == null ||
                    xPathTag22F.Length == 0 ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathIndicator.Length == 0 ||
                    xPath22FQualifier.Length == 0 ||
                    qualifier22FValue.Length == 0 ||
                    indicatorValue.Length == 0 ||
                    xPath70EQualifier.Length == 0 ||
                    qualifier70EValue.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTag = xRoot.SelectNodes(xPathTag22F);

                foreach (XmlNode xNode in xListTag)
                {
                    if (xNode.SelectSingleNode(xPath22FQualifier) != null)
                    {
                        if (xNode.SelectSingleNode(xPath22FQualifier).InnerText.CompareTo(qualifier22FValue) == 0)
                        {
                            //check if the node has an DataSourceScheme tag
                            XmlNode xNodeField = xNode.SelectSingleNode(xPathDataSourceScheme);

                            //Since the DataSourceScheme is not present, check for validity of code
                            if (xNodeField == null || xNodeField.InnerText.Length == 0)
                            {
                                if (xNode.SelectSingleNode(xPathIndicator) != null)
                                {
                                    if (xNode.SelectSingleNode(xPathIndicator).InnerText.CompareTo(indicatorValue) == 0)
                                    {
                                        XmlNode XNodeSequenceF = xRoot.SelectSingleNode(XPathSequenceF);

                                        //checks if Sequence F is present
                                        if (XNodeSequenceF != null)
                                        {
                                            isQualifierPresent = false;
                                            XmlNodeList xList70ESequenceF = xRoot.SelectNodes(xPathSeqFTag70E);
                                            if (xList70ESequenceF != null)
                                            {
                                                foreach (XmlNode xNode70ESequenceF in xList70ESequenceF)
                                                {
                                                    if (xNode70ESequenceF.SelectSingleNode(xPath70EQualifier) != null)
                                                    {
                                                        //cheks if field 70E of sequence F is present with specified qualifies
                                                        if (xNode70ESequenceF.SelectSingleNode(xPath70EQualifier).InnerText.CompareTo(qualifier70EValue) == 0)
                                                        {
                                                            isQualifierPresent = true;
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            else //sets to false if 70E field in Sequence F is not present
                                            {
                                                isPresent = false;
                                            }
                                        }
                                        else //sets to false if Sequence F is not present
                                        {
                                            isPresent = false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (isPresent != true || isQualifierPresent != true)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule281
        /// </method>
        /// <summary>
        ///	Within each occurrence of the Sub-Balance sequence B1, the third component (Subbalance
        ///	type) of field :93A::FROM must be different from the third component (Subbalance
        /// type) in all occurrences of field :93A::TOBA in the Intra-Position Movement
        /// sequence B1a (Error code E81).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of the element to be validated in Sequence B1
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of the element to be validated in Sequence B1a
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of Sequence B1.
        /// </param>
        /// <param name ="xPathSubSequence" type = "string">
        ///		Input reference of Sequence B1a.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Input containing Conditional Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input containing Conditional Rule Number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule281(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath1,
            string xPath2,
            string xPathSequence,
            string xPathSubSequence,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule281" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Sequence B1
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    int count = 0;

                    //Select the node Balance From in Sequence B1
                    XmlNode xNode1 = xNodeSequence.SelectSingleNode(xPath1);

                    //Select all the nodes of Sequence B1a in sequence B1
                    XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);

                    foreach (XmlNode xNodeSubSequence in xListSubSequence)
                    {
                        //Select the node Balance To in Sequence B1
                        XmlNode xNode2 = xNodeSubSequence.SelectSingleNode(xPath2);

                        if (xNode1.LastChild != null && xNode2.LastChild != null)
                        {
                            //Compare the third component of Balance From and Balance To
                            if (xNode1.LastChild.InnerText.CompareTo(xNode2.LastChild.InnerText) == 0)
                                count++;
                        }
                    }

                    if (count != 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		IsValidCodeCombination
        /// </method>
        /// <summary>
        ///		In each occurrence of Sequence B: when this field is used more than once,
        ///		the following combinations are not allowed
        ///		(Error code(s): D67).
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag">
        ///		Reference Path of the tag to be validated
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference Path of the sequence
        /// </param>
        /// <param name="xPathInstructionCode">
        ///		Reference path of instruction code
        /// </param>
        /// <param name="combinationCode1">
        ///		Value of the combination code1
        /// </param>
        /// <param name="combinationCode2">
        ///		Value of the combination code2 to be compared with
        /// </param>
        /// <param name="errorCode">
        ///		Error code for the validation
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		type of the message
        /// </param>
        /// <param name="errorObject">
        ///		Error object
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool IsValidCodeCombination(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathSequenceB,
            string xPathInstructionCode,
            string combinationCode1,
            string combinationCode2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCodeCombination" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            // Declarations of variables used in the method
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    combinationCode1 == null ||
                    combinationCode1.Length == 0 ||
                    combinationCode2 == null ||
                    combinationCode2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                // Get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTagSeqB = xRoot.SelectNodes(xPathSequenceB);
                // Split the Codes pair into Array variable
                string[] strArray = combinationCode2.Split(
                    Constants.CHRCOMMA);
                bool isCode1Present = false;
                bool isCode2Present = false;

                foreach (XmlNode xNode in xListTagSeqB)
                {
                    isCode1Present = false;
                    isCode2Present = false;

                    XmlNodeList xNodeFields = xNode.SelectNodes(xPathTag);

                    foreach (XmlNode xNodeField in xNodeFields)
                    {
                        string codeValue = xNodeField.SelectSingleNode(
                            xPathInstructionCode).InnerText;
                        if (codeValue.CompareTo(combinationCode1) == 0)
                        {
                            isCode1Present = true;
                        }

                        foreach (string code in strArray)
                            if (codeValue.CompareTo(code) == 0)
                            {
                                isCode2Present = true;
                            }

                        if (isCode1Present && isCode2Present)
                        {
                            isCode2Present = false;
                            errorObject.AddError(errorCode, policyName,
                                ruleName, xPathInstructionCode, codeValue);
                        }

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;

        }

        /// <method>
        ///		IsValidAdditionalInformation
        /// </method>
        /// <summary>
        ///		Additional Information is only allowed when Instruction code consists of one of the following codes:
        ///		CMTO, PHON,OTHR and REPA (Error code(s): D66).
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPathTag">
        ///		Reference path to the tag
        /// </param>
        /// <param name="xPathInstructionCode">
        ///		Reference path to instructionCode
        /// </param>
        /// <param name="instructionCode">
        ///		Instruction code value
        /// </param>
        /// <param name="xPathAdditionalInformation">
        ///		Reference path to Additional Information
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy Name
        /// </param>
        /// <param name="ruleName">
        ///		Rule Name
        /// </param>
        /// <param name="errorObject">
        ///		Error object
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool IsValidAdditionalInformation(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathInstructionCode,
            string instructionCode,
            string xPathAdditionalInformation,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidAdditionalInformation" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == instructionCode) throw new ArgumentNullException("instructionCode");

                //declarations of variables used in the method


                string code = string.Empty;
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTag = xRoot.SelectNodes(xPathTag);

                foreach (XmlNode xNode in xListTag)
                {
                    //check if the node has an instructionCode tag
                    XmlNode xNodeField = xNode.SelectSingleNode(xPathInstructionCode);

                    //Check if node is not null
                    if (xNodeField != null)
                    {
                        code = xNodeField.InnerText;

                        //Check for the presence of the code value in the codelist.
                        if (instructionCode.IndexOf(code) == -1)
                        {
                            if (xNode.SelectSingleNode(xPathAdditionalInformation) != null)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xPathAdditionalInformation, xNode.SelectSingleNode(xPathAdditionalInformation).InnerText);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		IsValidInstructionCode
        /// </method>
        /// <summary>
        ///		In each occurrence of Sequence B: when this field is repeated,
        ///		the same code word must not be present more than once with
        ///		the exception of OTHR. The code word OTHR may be repeated (Error code(s): E46).
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag">
        ///		Reference path of the tag to be validated
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Reference Path of the sequence
        /// </param>
        /// <param name="xPathInstructionCode">
        ///		Reference path of the instruction code
        /// </param>
        /// <param name="repetitionAllowedCode">
        ///		The particular value of the code for which repetation is allowed
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        /// <param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="errorObject">
        ///		Error object
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool IsValidInstructionCode(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathSequenceB,
            string xPathInstructionCode,
            string repetitionAllowedCode,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidInstructionCode" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTagSeqB = xRoot.SelectNodes(xPathSequenceB);
                ArrayList instructionCodes = new ArrayList();

                int numberOfTags = 0;
                bool isCodePresent = false;

                foreach (XmlNode xNode in xListTagSeqB)
                {
                    instructionCodes.Clear();
                    numberOfTags = 0;

                    XmlNodeList xNodeFields = xNode.SelectNodes(xPathTag);

                    foreach (XmlNode xNodeField in xNodeFields)
                    {
                        numberOfTags = numberOfTags + 1;
                        isCodePresent = false;

                        if (xNodeField.SelectSingleNode(xPathInstructionCode) != null)
                        {
                            if (instructionCodes.Count == 0
                                || xNodeField.SelectSingleNode(xPathInstructionCode).InnerText.CompareTo(repetitionAllowedCode) == 0)
                            {
                                instructionCodes.Add(xNodeField.SelectSingleNode(xPathInstructionCode).InnerText);
                            }
                            else
                            {
                                for (int arrCnt = 0; arrCnt < instructionCodes.Count; arrCnt++)
                                {
                                    if (instructionCodes[arrCnt].ToString().CompareTo(xNodeField.SelectSingleNode(xPathInstructionCode).InnerText) == 0)
                                    {
                                        isCodePresent = true;
                                    }
                                }
                                if (isCodePresent == false)
                                {
                                    instructionCodes.Add(xNodeField.SelectSingleNode(xPathInstructionCode).InnerText);
                                }

                            }
                        }
                    }

                    if (numberOfTags > instructionCodes.Count)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, xPathInstructionCode, xPathInstructionCode);
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule297
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 297.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath22H" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathTag12a" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name="qualifier22H">
        /// 	Qualifier value of field 22H
        /// </param>
        /// <param name="indicatorValue22H">
        /// 	Indicator value of field 22H
        /// </param>
        /// <param name="qualifier1Value22F">
        /// 	Qualifier value of field 22H
        /// </param>
        /// <param name="qualifier2Value22F">
        /// 	Qualifier value of field 22H
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule297(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath22H,
            string xPath22F,
            string xPathTag12a,
            string qualifier22H,
            string indicatorValue22H,
            string qualifier1Value22F,
            string qualifier2Value22F,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule297" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool exists = false;
            int lengthxPathTag12a = 0;
            try
            {
                if (xDocument == null ||
                    xPath22H == null ||
                    xPath22H.Length == 0 ||
                    xPath22F == null ||
                    xPath22F.Length == 0 ||
                    xPathTag12a == null ||
                    xPathTag12a.Length == 0 ||
                    qualifier22H == null ||
                    indicatorValue22H == null ||
                    qualifier1Value22F == null ||
                    qualifier2Value22F == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                string[] xPathTag12aArray = xPathTag12a.Split(Constants.CHRCOMMA);
                lengthxPathTag12a = xPathTag12aArray.Length;

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xList22H = xRoot.SelectNodes(xPath22H);

                foreach (XmlNode xNode22H in xList22H)
                {
                    if (xNode22H.FirstChild != null && xNode22H.FirstChild != null)
                    {
                        if (xNode22H.FirstChild.InnerText.CompareTo(qualifier22H) == 0)
                        {
                            if (xNode22H.LastChild.InnerText.CompareTo(indicatorValue22H) == 0)
                            {
                                XmlNodeList xNode22FList = xRoot.SelectNodes(xPath22F);

                                if (xNode22FList.Count >= 2)
                                {
                                    bool bln1 = false;
                                    bool bln2 = false;
                                    foreach (XmlNode xNode in xNode22FList)
                                    {
                                        if (xNode.FirstChild != null)
                                        {
                                            if (xNode.FirstChild.InnerText.CompareTo(qualifier1Value22F) == 0)
                                            {
                                                bln1 = true;
                                            }
                                            if (xNode.FirstChild.InnerText.CompareTo(qualifier2Value22F) == 0)
                                            {
                                                bln2 = true;
                                            }

                                        }
                                    }
                                    if (bln1 == true && bln2 == false || bln1 == false && bln2 == true || bln1 == false && bln2 == false)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                    }

                                    if (bln1 == true && bln2 == true)
                                    {
                                        for (int count = 0; count <= lengthxPathTag12a - 1; count++)
                                        {
                                            if (xRoot.SelectSingleNode(xPathTag12aArray[count]) != null)
                                            {
                                                exists = true;
                                            }
                                            if (exists == true)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }

                            }
                            else
                            {
                                for (int count = 0; count <= lengthxPathTag12a - 1; count++)
                                {
                                    if (xRoot.SelectSingleNode(xPathTag12aArray[count]) != null)
                                    {
                                        exists = true;
                                    }

                                }
                                if (exists == false)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }

                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule218
        /// </method>
        /// <summary>
        ///		SWIFT Network Rule 218 is applicable to 103 and 103+
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPath23E">Input xPath of Tag 23E </param>
        /// <param name="xPath59a">Input xPath of Tag 59a with First Child Account</param>
        /// <param name="instructionCode">Instruction code 'CHQB'</param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule218(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath23E,
            string xPath59a,
            string instructionCode,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule218" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath23E == null ||
                    xPath23E.Length == 0 ||
                    xPath59a == null ||
                    xPath59a.Length == 0 ||
                    instructionCode == null ||
                    instructionCode.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                bool isPresent = false;
                XmlNodeList xList23E = xRoot.SelectNodes(xPath23E);
                foreach (XmlNode xNode in xList23E)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        if (xNode.FirstChild.InnerText.CompareTo(instructionCode) == 0)
                        {
                            isPresent = true;
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }

                // spec: If any field 23E contains the code CHQB, subfield 1 (Account) in field 59a ... is not allowed.
                if (isPresent)
                {
                    XmlNode xNode59a = xRoot.SelectSingleNode(xPath59a);
                    if (xNode59a != null)
                    {
                        if (xNode59a.InnerText.Length != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, xNode59a.Name, xNode59a.InnerText);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule244and245
        /// </method>
        /// <summary>
        ///		SWIFT Network Rule 244 and 245 is applicable to 103 and 103+
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        ///	</param>
        /// <param name="xPath56List">
        ///		xPath for 56
        ///	</param>
        /// <param name="xPath23E">
        ///		xPath for 23E
        ///	</param>
        /// <param name="instructionCodeList">
        ///		InstructionCodes in comma separated strings
        ///	</param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule244and245(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath56List,
            string xPath23E,
            string instructionCodeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule244and245" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath56List == null ||
                    xPath56List.Length == 0 ||
                    xPath23E == null ||
                    xPath23E.Length == 0 ||
                    instructionCodeList == null ||
                    instructionCodeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                bool isPresent = false;
                char[] chrArray = Constants.COMMA.ToCharArray();

                // Split string based on ","
                string[] xPath56Arr = xPath56List.Split(chrArray);

                int count = 0;
                XmlNodeList xList56;
                foreach (string xPath in xPath56Arr)
                {
                    xList56 = xRoot.SelectNodes(xPath);
                    if (xList56.Count != 0)
                    {
                        count++;
                        break;
                    }
                }
                if (count == 0)
                {
                    XmlNodeList xList23E = xRoot.SelectNodes(xPath23E);
                    if (xList23E.Count > 0)
                    {
                        string[] instructionCodeArr = instructionCodeList.Split(chrArray);

                        foreach (XmlNode xNode in xList23E)
                        {
                            if (isValid)
                            {
                                if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                                {
                                    foreach (string instructionCode in instructionCodeArr)
                                    {
                                        if (xNode.FirstChild.InnerText.CompareTo(instructionCode) == 0)
                                        {
                                            isPresent = true;
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isValid = false;
                                            break;
                                        }
                                    }
                                }
                                else
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                                if (isPresent)
                                {
                                    break;
                                }
                            }
                        }

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule157
        /// </method>
        /// <summary>
        ///		SWIFT Network Rule 157 is applicable to 103 and 103+
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule157(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered SWIFTNetworkRule157:");
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        if (Convert.ToDecimal(xNode.LastChild.InnerText, CultureInfo.InvariantCulture) == 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, xNode.FirstChild.Name, xNode.FirstChild.InnerText);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule283
        /// </method>
        /// <summary>
        ///		If the instruction is against payment (:22H::PAYM//APMT) then it is mandatory to specify a Posting Amount
        ///		(field :19A::PSTA). This rule applies to subsequence B1a2 (Error code(s): E83).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath19A" type = "string">
        ///		Input reference of the Element 19A in Sequence B1a2.
        /// </param>
        /// <param name ="xPath22H" type = "string">
        ///		Input reference of the Element 22H in Sequence B1a2.
        /// </param>
        /// <param name ="qualifierValue19A" type = "string">
        ///		Reference containing the value of the Qualifier for xPath19A.
        /// </param>
        /// <param name ="qualifierValue22H" type = "string">
        ///		Reference containing the value of the Qualifier for xPath22H.
        /// </param>
        /// <param name ="indicatorValue22H" type = "string">
        ///		Reference containing the value of the Indicator for xPath22H.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Reference containing the xPath of Sequence B1a2.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule283(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath19A,
            string xPath22H,
            string qualifierValue19A,
            string qualifierValue22H,
            string indicatorValue22H,
            string xPathSequence,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule283" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath19A == null ||
                    xPath22H == null ||
                    xPath19A.Length == 0 ||
                    xPath22H.Length == 0 ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                //Select all the nodes of Sequence B1a2
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    int count22H = 0;
                    int count19A = 0;

                    //Select all the nodes of Tag 22H in Sequence B1a2
                    XmlNodeList xList1 = xNodeSequence.SelectNodes(xPath22H);

                    foreach (XmlNode xNode1 in xList1)
                    {
                        if (xNode1.FirstChild != null && xNode1.LastChild != null)
                        {
                            //Compare if the Qualifier value of Tag 22H is PAYM & Indicator value is
                            if (xNode1.FirstChild.InnerText.CompareTo(qualifierValue22H) == 0 && xNode1.LastChild.InnerText.CompareTo(indicatorValue22H) == 0)
                                count22H++;
                        }
                    }
                    if (count22H != 0)
                    {
                        //Select all the nodes of Tag 19A in Sequence B1a2
                        XmlNodeList xList2 = xNodeSequence.SelectNodes(xPath19A);

                        foreach (XmlNode xNode2 in xList2)
                        {
                            if (xNode2.FirstChild != null)
                            {
                                //Compare if the Qualifier value of Tag 19A is PSTA
                                if (xNode2.FirstChild.InnerText.CompareTo(qualifierValue19A) == 0)
                                    count19A++;
                            }
                        }

                        //If there is no Tag 19A with Qualifier value as PSTA, throw an error
                        if (count19A == 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule284
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 284.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSeq" type = "string">
        ///		comma separated xPaths of Sequence B1a and B1a2a.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Comma separated xPaths of Tag 95a in Sequence B1a2a.
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the list of the Qualifiers for Tag 95a which shouldn't repeat.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing message number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing name of the conditional rule
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing number of the conditional rule
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule284(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSeq,
            string xPath,
            string qualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule284" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    xPathSeq == null ||
                    xPathSeq.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                int lengthxPath1 = 0;
                string qualifierListTemp = string.Empty;

                //Store the xPaths of tag 95a in an array
                string[] xPathArray1 = xPath.Split(Constants.CHRCOMMA);
                lengthxPath1 = xPathArray1.Length;

                //Store the xPaths of Sequences in an array
                string[] xPathArray2 = xPathSeq.Split(Constants.CHRCOMMA);
                string xPathSequence = xPathArray2[0];
                string xPathSubSequence = xPathArray2[1];

                XmlNode xRoot = xDocument.Document;
                //Select all the nodes of Sequence B1a
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    qualifierListTemp = qualifierList + Constants.COMMA;
                    ArrayList arrayQualifier = new ArrayList();

                    //Select all the nodes of Sequence B1a2a within Sequence B1a
                    XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);

                    foreach (XmlNode xNodeSubSequence in xListSubSequence)
                    {

                        for (int nCount = 0; nCount <= lengthxPath1 - 1; nCount++)
                        {
                            //Select all the nodes for each xPath of tag 95a
                            XmlNodeList xList = xNodeSubSequence.SelectNodes(xPathArray1[nCount].ToString());
                            if (xList.Count != 0)
                            {
                                foreach (XmlNode xNode in xList)
                                {
                                    //Store all the Qualifiers present in an ArrayList
                                    arrayQualifier.Add(xNode.InnerText);
                                }

                            }
                        }
                    }

                    string strQualifier;
                    if (arrayQualifier.Count != 0)
                    {
                        for (int i = 0; i <= arrayQualifier.Count - 1; i++)
                        {
                            strQualifier = arrayQualifier[i].ToString();
                            //For each Qualifier in ArrayList, check if it is present in qualifierList
                            if (qualifierListTemp.IndexOf(strQualifier) == -1)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                            strQualifier = strQualifier + Constants.COMMA;
                            //Remove the Qualifier which has occured once from the qualifierList
                            qualifierListTemp = qualifierListTemp.Replace(strQualifier, Constants.BLANK);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }


        /// <method>
        ///		SWIFTNetworkRule197
        /// </method>
        /// <summary>
        ///		SWIFT Network Rule 197 is applicable to 103 and 103+
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="instructionCodeList" type ="string">
        ///		Instruction CodeList containing the valid instances
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule197(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string instructionCodeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule197" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isMatch = false;
            try
            {

                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    instructionCodeList == null ||
                    instructionCodeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                // Split the instruction codelist based on ","
                char[] chrArray = Constants.COMMA.ToCharArray();
                string[] instructionCodeArr = instructionCodeList.Split(chrArray);

                // Select All the Tag 23E entries
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);
                foreach (XmlNode xNode in xList)
                {
                    if (isValid)
                    {
                        if (xNode.FirstChild.InnerText != null && xNode.FirstChild.InnerText.Length != 0)
                        {
                            foreach (string instructionCode in instructionCodeArr)
                            {
                                if (!(isMatch))
                                {
                                    if (xNode.FirstChild.InnerText.CompareTo(instructionCode) == 0)
                                    {
                                        isMatch = true;
                                    }
                                    else
                                    {
                                        isMatch = false;
                                    }
                                }
                            }
                            if (!(isMatch))
                            {
                                if (xNode.ChildNodes.Count > 1)
                                {
                                    if (xNode.LastChild.InnerText != null && xNode.LastChild.InnerText.Length != 0)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, xPath, xNode.InnerText);
                                        isValid = false;
                                    }
                                }
                            }
                            else
                            {
                                isMatch = false;
                            }

                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule198
        /// </method>
        /// <summary>
        ///		This method performs validation for Optional Repititive field 23E Instruction code.
        ///		If the code is Repititive is should appear in the form of SDVA,INTC,REPA and CORT.
        ///		The First code need not start with SDVA, there may be gaps.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="listOfValues" type = "string">
        ///		Input containing the List of Values name.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        ///	</param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule198(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string listOfValues,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule198" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (null == errorObject) throw new ArgumentNullException("errorObject");

                int index = 0;

                if (xDocument != null && listOfValues != null && listOfValues.Length != 0 && xDocument.Document != null)
                {
                    XmlNodeList xList = xDocument.Document.SelectNodes(xPath);
                    foreach (XmlNode xNode in xList)
                    {
                        if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                        {
                            if (!VerifyFieldOrder(xNode.InnerText.Substring(0, 4), listOfValues, ref index))
                            {
                                errorObject.AddError(Constants.ERRORD98, policyName,
                                    ruleName, xNode.ParentNode.Name, xNode.InnerText.Substring(0, 4));
                                return false;
                            }
                        }
                    }
                }

                else
                {
                    return false;
                }
                return true;
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        /// <method>
        ///		SWIFTNetworkRule246
        /// </method>
        /// <summary>
        ///		SWIFT Network Rule 246 is applicable to 103 and 103+
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="instructionCodeList" type ="string">
        ///		Instruction CodeList containing the valid instances
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule246(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string instructionCodeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule246" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            int count = 0;
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    instructionCodeList == null ||
                    instructionCodeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                // Split the instruction codelist based on ","
                char[] chrArray = Constants.COMMA.ToCharArray();
                string[] instructionCodeArr = instructionCodeList.Split(chrArray);

                // Select All the Tag 23E entries
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach (string instructionCode in instructionCodeArr)
                {
                    if (isValid)
                    {
                        foreach (XmlNode xNode in xList)
                        {
                            if (isValid)
                            {
                                if (xNode.FirstChild.InnerText != null && xNode.FirstChild.InnerText.Length != 0)
                                {
                                    if (xNode.FirstChild.InnerText.CompareTo(instructionCode) == 0)
                                    {
                                        count++;
                                    }
                                }
                                else
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, xNode.ParentNode.Name, Constants.NOCONTENT);
                                    isValid = false;
                                }
                                if (count > 1)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, xPath, xNode.InnerText);
                                    isValid = false;
                                }
                            }
                        }
                        count = 0;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		IsValidCurrencyCode
        /// </method>
        /// <summary>
        ///		This function performs validation specific to the 'SignCodeAmount' attribute. The validation performed is:-
        ///		 -- Currency code must be a valid ISO 4217 currency code --
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSignCodeAmount" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="currencyList" type = "string">
        ///		Input containing the list of Currency Codes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //        public static bool IsValidCurrencyCode(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //            string xPathSignCodeAmount,
        //            string currencyList,
        //            string errorCode,
        //            string policyName,
        //            string ruleName,
        //            ErrorCollection errorObject)
        //        {
        //            if (null == currencyList) throw new ArgumentNullException("currencyList");

        //            bool isValid = true;
        //            string sign = string.Empty;
        //            string currencyCode = string.Empty;
        //            string signCodeAmount = string.Empty;

        //            if(xDocument == null ||
        //                xPathSignCodeAmount == null ||
        //                xPathSignCodeAmount.Length == 0 ||
        //                errorCode == null ||
        //                errorCode.Length == 0 ||
        //                errorObject == null)
        //            {
        //                return false;

        //            }

        //            XmlNode xRoot = xDocument.Document;
        //            //Select all the nodes of element SignCodeAmount
        //            XmlNodeList xListSignCodeAmount = xRoot.SelectNodes(xPathSignCodeAmount);

        //            foreach(XmlNode xNodeSignCodeAmount in xListSignCodeAmount)
        //            {
        //                //Get the value of SignCodeAmount
        //                signCodeAmount = xNodeSignCodeAmount.InnerText.ToString().Trim();

        //                //Select the fourth character of the SignCodeAmount
        //                sign = signCodeAmount.Substring(3,1);

        //                //Check if the fourth character is a number or alphabet in order to check whether the Sign is present or not
        //                if(sign[0] >= Constants.CHR0 && sign[0] <= Constants.CHR9)
        //                {
        //                    //Select the first three characters of the SignCodeAmount, if Sign is not present
        //                    currencyCode = signCodeAmount.Substring(0,3);
        //                }
        //                else
        //                {
        //                    //Select the second,third and fourth characters of the SignCodeAmount, if Sign is present
        //                    currencyCode = signCodeAmount.Substring(1,3);
        //                }

        //                //If the currencyCode is not a valid Currency code, throw an error
        //                //if(currencyList.IndexOf(currencyCode) == -1)
        //                if(!SqlConnector.hashCurrencyCodeList.ContainsKey(currencyCode))
        //                {
        ////					errorObject.AddError(errorCode, policyName, ruleName,
        ////						xNodeSignCodeAmount.Name.Substring(4,4), currencyCode);
        //                    isValid = false;
        //                }
        //            }

        //            return isValid;
        //        }

        /// <method>
        ///		SWIFTNetworkRule59
        /// </method>
        /// <summary>
        ///		The amount specified in field 32A must be the same as the amount specified in the preceding
        ///		field 34B
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPath1">
        ///		Reference path to field 32A
        /// </param>
        /// <param name="xPath2">
        ///		Reference path to field 34B
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        ///	<param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule59(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath1,
            string xPath2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule59" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                string amount1 = null;
                string amount2 = null;

                if (xRoot.SelectSingleNode(xPath1) != null && xRoot.SelectSingleNode(xPath2) != null)
                {
                    if (xRoot.SelectSingleNode(xPath1).LastChild != null && xRoot.SelectSingleNode(xPath2).LastChild != null)
                    {
                        if (xRoot.SelectSingleNode(xPath1).LastChild.InnerText != null && xRoot.SelectSingleNode(xPath2).LastChild.InnerText != null)
                        {
                            amount1 = xRoot.SelectSingleNode(xPath1).LastChild.InnerText;

                            amount2 = xRoot.SelectSingleNode(xPath2).LastChild.InnerText;
                        }
                    }

                    if (amount1 != amount2)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule56
        /// </method>
        /// <summary>
        /// In sequence B, when field 17Z is "Y" then 22Q must be present
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPath1">
        ///		Reference path to field 17Z
        ///	</param>
        /// <param name="xPath2">
        ///		Reference path to field 22Q
        ///	</param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        ///	<param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule56(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath1,
            string xPath2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule56" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Tag 17Z in Sequence B
                XmlNodeList xList = xRoot.SelectNodes(xPath1);

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.FirstChild != null)
                    {
                        //Check if the Flag value is 'Y'
                        if (xNode.FirstChild.InnerText.CompareTo(Constants.ALPHAY) == 0)
                        {
                            XmlNodeList xList2 = xRoot.SelectNodes(xPath2);

                            if (xList2.Count == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                    }
                }
            }

            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule57
        /// </method>
        /// <summary>
        /// If field 34N of sequence B is present, field 31F of that sequence and
        /// field 33N in sequence C must also be present.
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPath1">
        ///		Reference path to field 31F
        ///	</param>
        /// <param name="xPath2">
        ///		Reference path to field 34N
        ///	</param>
        /// <param name="xPath3">
        ///		Reference path to field 33N
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        ///	<param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule57(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath1,
            string xPath2,
            string xPath3,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule57" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    xPath3 == null ||
                    xPath3.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                XmlNode xRoot = xDocument.Document;

                XmlNodeList xList1 = xRoot.SelectNodes(xPath2);
                if (xList1.Count != 0)
                {
                    XmlNodeList xList2 = xRoot.SelectNodes(xPath1);
                    if ((xList1.Count > xList2.Count) || (xRoot.SelectSingleNode(xPath3) == null))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule58
        /// </method>
        /// <summary>
        ///		The amount component in field 33N of Sequence C must be equal to the total of the amount
        ///		component of all sequence B field 34Ns present in the message.
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        /// </param>
        /// <param name="xPathSequence">
        /// 	Reference path to sequence B.
        /// </param>
        /// <param name="xPath1">
        ///		Reference path to field 34N
        ///	</param>
        /// <param name="xPath2">
        ///		Reference path to field 33N
        /// </param>
        /// <param name="errorCode">
        ///		Error code
        /// </param>
        /// <param name="policyName">
        ///		Policy name
        /// </param>
        ///	<param name="ruleName">
        ///		Rule name
        /// </param>
        /// <param name="messageType">
        ///		Message type
        /// </param>
        /// <param name="conditionalRuleName">
        ///		conditionalRuleName
        /// </param>
        /// <param name="conditionalRuleNumber">
        ///		conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		errorObject
        /// </param>
        /// <returns>
        ///		bool
        /// </returns>
        public static bool SWIFTNetworkRule58(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath1,
            string xPath2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule58" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                double amount1 = 0;
                double amount2 = 0;
                string strValue = string.Empty;

                if (xRoot.SelectSingleNode(xPath1) != null &&
                    xRoot.SelectSingleNode(xPath2) != null)
                {
                    if (xRoot.SelectSingleNode(xPath2).InnerText != null && xRoot.SelectSingleNode(xPath2).InnerText != Constants.BLANK)
                    {
                        strValue = xRoot.SelectSingleNode(xPath2).InnerText.Substring(0, 1);
                        if (Comparer.Equals(strValue, Constants.ALPHAN))
                        {
                            strValue = xRoot.SelectSingleNode(xPath2).InnerText.Substring(10);
                        }
                        else
                        {
                            strValue = xRoot.SelectSingleNode(xPath2).InnerText.Substring(9);
                        }

                        strValue = strValue.Replace(Constants.COMMA, decimalSeparator);
                        amount1 = Convert.ToDouble(strValue, CultureInfo.InvariantCulture);
                    }

                    XmlNode xNode = xRoot.SelectSingleNode(xPathSequence);
                    if (xNode != null)
                    {
                        XmlNodeList xList = xNode.SelectNodes(xPath1);
                        if (xList.Count != 0)
                        {
                            foreach (XmlNode xNode1 in xList)
                            {
                                if (xNode1.InnerText != null)
                                {
                                    strValue = xNode1.InnerText.Substring(0, 1);
                                    if (Comparer.Equals(strValue, Constants.ALPHAN))
                                    {
                                        strValue = xNode1.InnerText.Substring(10);
                                    }
                                    else
                                    {
                                        strValue = xNode1.InnerText.Substring(9);
                                    }

                                    strValue = strValue.Replace(Constants.COMMA, decimalSeparator);
                                    amount2 = amount2 + Convert.ToDouble(strValue, CultureInfo.InvariantCulture);
                                }
                            }
                        }
                    }
                    if (amount1 != amount2)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule166
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 166, Subfield 2 of field 23E is only allowed when
        ///		subfield 1 of this field consists of set of values say 'CMTO',PHON or OTHR.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the desired Sequence say sequence B, for e.g. //SequenceB
        ///	</param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the desired tag say sequence B, for e.g. ./InstructionCode_B_23E
        ///	</param>
        /// <param name ="xPathSubField1" type = "string">
        ///		Input reference of subfield 1, for e.g., ./InstructionCode
        /// </param>
        /// <param name ="instructionCodeList" type = "string">
        ///		Input reference of instructionCodeList, for e.g.,
        ///		CMSW,PHON etc
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule166(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag,
            string xPathSubField1,
            string instructionCodeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule166" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubField1 == null ||
                    xPathSubField1.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    instructionCodeList == null ||
                    instructionCodeList.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Declare a string array to store all the xpaths for the desired tag and its corresponding required Tag
                string[] xListInstructionCode = instructionCodeList.Split(Constants.CHRCOMMA);

                //Select all the nodes of the desired Sequence say Sequence B
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                foreach (XmlNode xNode in xListSequence)	//	SequenceB
                {
                    XmlNodeList xNodeTagList = xNode.SelectNodes(xPathTag); // InstructionCode_B_23E
                    bool bInstructionCodeExists = false;
                    foreach (XmlNode xNodeTag in xNodeTagList)
                    {
                        for (int i = 0; i < xListInstructionCode.Length; i++)
                        {
                            if (xNodeTag.SelectSingleNode(xPathSubField1).InnerText.CompareTo(xListInstructionCode[i]) == 0)
                            {
                                bInstructionCodeExists = true;
                                break;
                            }
                        }
                        if (bInstructionCodeExists == false)
                        {
                            //	If the Instruction code does not match from the given set of values and Additional Information field
                            //	exists then give an error
                            if (xNodeTag.FirstChild != xNodeTag.LastChild)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                                break;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule167
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 167,
        ///		In each occurrence of Sequence B: when field 23E is used more than once, the following
        ///		combinations are not allowed {Error code D67}:
        ///			CMSW with CMTO
        ///			CMSW with CMZB
        ///			CMTO with CMZB
        ///			CORT with CMSW
        ///			CORT with CMTO
        ///			CORT with CMZB
        ///			NETS with RTGS
        ///			etc...
        ///
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the desired Sequence say sequence B, for e.g. //SequenceB
        ///	</param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the desired tag say sequence B, for e.g. ./InstructionCode_B_23E
        ///	</param>
        /// <param name ="subFieldName" type = "string">
        ///		Input reference of subfield 1, for e.g., ./InstructionCode
        /// </param>
        /// <param name ="instructionCode" type = "string">
        ///		Instruction code against which the mutual exclusion has to check CMSW
        /// </param>
        /// <param name ="mutexInstructionCodeList" type = "string">
        ///		Input reference of mutually exclusive instructionCodeList, for e.g., CMTO,PHON etc...
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule167(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag,
            string subFieldName,
            string instructionCode,
            string mutexInstructionCodeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule167" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    mutexInstructionCodeList == null ||
                    mutexInstructionCodeList.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Declare a string array to store all the xpaths for the desired tag and its corresponding required Tag
                string[] xListInstructionCode = mutexInstructionCodeList.Split(Constants.CHRCOMMA);

                //Select all the nodes of the desired Sequence say Sequence B
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                foreach (XmlNode xNode in xListSequence)	//	SequenceB
                {
                    XmlNodeList xNodeTagList = xNode.SelectNodes(xPathTag); // InstructionCode_B_23E
                    if (xNodeTagList.Count == 1)
                    {
                        return true;
                    }
                    // If InstructionCode_B_23E exists more than once in Seq B then check for non-existence of mutual exclusive codes.
                    // If mutual exclusive codes exists then raise an error
                    // Concatenate the qualifier and indicator into the given xPath
                    //	e.g.: "//SequenceB/InstructionCode_B_23E[InstructionCode='CMSW' or InstructionCode='CMTO' or InstructionCode='CMZB' or InstructionCode='CORT']"
                    string xPathInstructionCodeList = xPathTag + Constants.OPENSQUAREBRACKET + subFieldName + Constants.EQUAL + Constants.SINGLEQUOTE + instructionCode + Constants.SINGLEQUOTE + Constants.SPACE;
                    for (int i = 0; i < xListInstructionCode.Length; i++)
                    {
                        xPathInstructionCodeList += Constants.SPACE + Constants.OR + Constants.SPACE + subFieldName + Constants.EQUAL + Constants.SINGLEQUOTE + xListInstructionCode[i] + Constants.SINGLEQUOTE + Constants.SPACE;
                    }
                    xPathInstructionCodeList += Constants.CLOSESQUAREBRACKET;

                    xNodeTagList = xNode.SelectNodes(xPathInstructionCodeList);
                    if (xNodeTagList.Count >= 1)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// SWIFTNetworkRule9
        /// </method>
        /// <summary>
        /// 	This function performs Conditional Rule C09 Validation which ensures that , field 32a must be present in the Same Sequence when 33a is present
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPathSequence" type = "string">
        /// 	Input containing the xpath of Sequence.
        /// </param>
        /// <param name="xPathTag32a" type = "string">
        /// 	Input containing the xpath of Tag 32A of SequenceA,
        /// 	Input containing the xpath of Tag 32K of SequenceA.
        /// </param>
        /// <param name="xPathTag33a" type = "string">
        /// 	Input containing the xpath of Tag 33A of SequenceA,Input
        /// 	containing the xpath of Tag 33K of SequenceA.
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Inutput containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule9(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag32a,
            string xPathTag33a,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule9" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int lengthxPathTag32a = 0;
            int lengthxPathTag33a = 0;
            bool blnTag1 = false;
            bool blnTag2 = false;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag32a == null ||
                    xPathTag33a == null ||
                    xPathTag32a.Length == 0 ||
                    xPathTag33a.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                string[] xPathTag32aArray = xPathTag32a.Split(Constants.CHRCOMMA);
                string[] xPathTag33aArray = xPathTag33a.Split(Constants.CHRCOMMA);

                lengthxPathTag32a = xPathTag32aArray.Length;
                lengthxPathTag33a = xPathTag33aArray.Length;

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    blnTag1 = false;
                    blnTag2 = false;

                    for (int count = 0; count <= lengthxPathTag33a - 1; count++)
                    {
                        if (xNodeSequence.SelectSingleNode(xPathTag33aArray[count]) != null)
                        {
                            blnTag1 = true;
                        }
                    }


                    for (int count1 = 0; count1 <= lengthxPathTag32a - 1; count1++)
                    {
                        if (xNodeSequence.SelectSingleNode(xPathTag32aArray[count1]) != null)
                        {
                            blnTag2 = true;
                        }
                    }

                    if (blnTag1 && !blnTag2)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule167
        /// </method>
        /// <summary>
        ///		When field 23E is used more than once, the following combinations are not allowed {Error code D67}:
        ///			SDVA with HOLD
        ///			SDVA with CHQB
        /// 		INTC with BONL
        ///			INTC with HOLD
        ///			etc...
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the desired tag say sequence B, for e.g. ./InstructionCode_B_23E
        ///	</param>
        /// <param name="subFieldName">
        /// 	Input reference of subfield 1, for e.g., ./InstructionCode
        /// </param>
        /// <param name ="instructionCode" type = "string">
        ///		Instruction code against which the mutual exclusion has to check CMSW
        /// </param>
        /// <param name ="mutexInstructionCodeList" type = "string">
        ///		Input reference of mutually exclusive instructionCodeList, for e.g., CMTO,PHON etc...
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule167(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            ErrorCollection errorObject,
            string xPathTag,
            string subFieldName,
            string instructionCode,
            string mutexInstructionCodeList,
            string errorCode,
            string policyName,
            string ruleName)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule167" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    mutexInstructionCodeList == null ||
                    mutexInstructionCodeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Declare a string array to store all the xpaths for the desired tag and its corresponding required Tag
                string[] xListInstructionCode = mutexInstructionCodeList.Split(Constants.CHRCOMMA);

                XmlNodeList xNodeTagList = xRoot.SelectNodes(xPathTag); // InstructionCode_23E
                if (xNodeTagList.Count == 1)
                {
                    return true;
                }

                //If the instruction code given exists in the instance then check if any of the mutual exclusive
                //instructions for this code is also present, if present - error, else proceed as valid.
                string xPathInstructionCodeMain = xPathTag + Constants.OPENSQUAREBRACKET + subFieldName + Constants.EQUAL + Constants.SINGLEQUOTE + instructionCode + Constants.SINGLEQUOTE + Constants.SPACE + Constants.CLOSESQUAREBRACKET;
                XmlNodeList xNodeCurrentTag = xRoot.SelectNodes(xPathInstructionCodeMain);
                if (xNodeCurrentTag.Count > 0)
                {
                    string xPathInstructionCodeList = xPathTag + Constants.OPENSQUAREBRACKET + subFieldName + Constants.EQUAL + Constants.SINGLEQUOTE + xListInstructionCode[0] + Constants.SINGLEQUOTE;
                    for (int i = 1; i < xListInstructionCode.Length; i++)
                    {
                        xPathInstructionCodeList += Constants.SPACE + Constants.OR + Constants.SPACE + subFieldName + Constants.EQUAL + Constants.SINGLEQUOTE + xListInstructionCode[i] + Constants.SINGLEQUOTE + Constants.SPACE;
                    }
                    xPathInstructionCodeList += Constants.CLOSESQUAREBRACKET;

                    xNodeTagList = xRoot.SelectNodes(xPathInstructionCodeList);
                    if (xNodeTagList.Count >= 1)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, subFieldName, instructionCode);
                        isValid = false;
                    }
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule201
        /// </method>
        /// <summary>
        ///		This method performs validation for field function.
        ///		If field 23B contains the code SPRI, field 23E may contain only the codes SDVA or INTC (Error code(s): E01).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathField23EInstruction">
        ///		Input reference of the element to be validated (Field 23E; Qualifier).
        /// </param>
        /// <param name="qualifierList1">
        ///		Input Value of first valid Qualifier value.
        /// </param>
        /// <param name="qualifierList2">
        ///		Input Value of second valid Qualifier value.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code (E01).
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        ///		For e.g. SWIFT_NetworkRule201_Policy
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the Rule name.
        ///		For e.g. Validate_MT103+
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT103Plus
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Input containing Conditional Rule Name
        ///		For e.g. C3
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input containing Conditional Rule Number
        /// 	For e.g. Rule 103Plus
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule201(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathField23EInstruction,
            string qualifierList1,
            string qualifierList2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule201" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;

            try
            {
                if (xDocument == null ||
                    xPathField23EInstruction == null ||
                    qualifierList1 == null ||
                    qualifierList2 == null ||
                    xPathField23EInstruction.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListQualifier = xRoot.SelectNodes(xPathField23EInstruction);


                foreach (XmlNode xNode in xListQualifier)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        if (xNode.InnerText.CompareTo(qualifierList1) != 0 && xNode.InnerText.CompareTo(qualifierList2) != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                        else
                        {
                            isValid = true;
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule175
        /// </method>
        /// <summary>
        ///		If field 33B is present and the currency code is different from the currency code in field 32A,
        ///		field 36 must be present,otherwise field 36 is not allowed (Error code(s): D75).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath32A" type = "string">
        ///		Input reference of the Element 32A.
        /// </param>
        /// <param name ="xPath33B" type = "string">
        ///		Input reference of the Element 33B.
        /// </param>
        /// <param name ="xPath36" type = "string">
        ///		Input reference of the Element 36.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule175(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath32A,
            string xPath33B,
            string xPath36,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule175" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath32A == null ||
                    xPath32A.Length == 0 ||
                    xPath33B == null ||
                    xPath33B.Length == 0 ||
                    xPath36 == null ||
                    xPath36.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                //Select the Currency element of Tag 33B
                XmlNode xNode33B = xRoot.SelectSingleNode(xPath33B);
                //Select the Currency element of Tag 32A
                XmlNode xNode32A = xRoot.SelectSingleNode(xPath32A);
                //Select the Tag 36
                XmlNode xNode36 = xRoot.SelectSingleNode(xPath36);

                //Check if Tag 33B is present
                if (xNode33B != null)
                {
                    if (xNode32A != null)
                    {
                        //If Currency Codes are equal and Tag 36 is present (or) If Currency Codes are not equal and Tag 36 is not present, throw an error
                        if ((xNode33B.InnerText.CompareTo(xNode32A.InnerText) == 0 && xNode36 != null)
                            || (xNode33B.InnerText.CompareTo(xNode32A.InnerText) != 0 && xNode36 == null))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
                else
                {
                    //If Tag 33B is not present and Tag 36 is present, throw an error
                    if (xNode36 != null)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType,
                            conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule1
        /// </method>
        /// <summary>
        ///		Field 19 at the completion of each outer repetitive sequence must equal the sum of the products
        ///		of Number of Cheques(first subfield) and Denomination (third subfield) of all occurrences of
        ///		field 68A from the respective inner repetitive sequence.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of the element 68A to be validated.
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of the element 19 to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Input containing Conditional Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input containing Conditional Rule Number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule1(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            ErrorCollection errorObject,
            string xPath1,
            string xPath2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule1" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;

            int count = 0;
            double Value = 0.0;
            try
            {
                if (xDocument == null ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xNodeList = xRoot.SelectNodes(xPath1);

                foreach (XmlNode xNode in xNodeList)
                {
                    if (xNode.PreviousSibling != null && xRoot.SelectSingleNode(xPath2) != null)
                    {
                        if (xNode.PreviousSibling.LocalName == xRoot.SelectSingleNode(xPath2).LocalName || count == 0)
                        {
                            XmlNode xNode1 = xNode;
                            Value = 0.0;
                            while (xNode1.LocalName != xRoot.SelectSingleNode(xPath2).LocalName && xNode1.NextSibling != null)
                            {
                                if (xRoot.SelectSingleNode(xPath1) != null)
                                {
                                    if (xNode1.LocalName.CompareTo(xRoot.SelectSingleNode(xPath1).LocalName) == 0)
                                    {
                                        if (xNode1.FirstChild != null)
                                        {
                                            string szinnerText = xNode1.FirstChild.InnerText;
                                            string value1Text = null;
                                            string value2Text = null;
                                            for (int i = 0; i < szinnerText.Length; i++)
                                            {
                                                if (szinnerText[i] >= Constants.CHR0 && szinnerText[i] <= Constants.CHR9)
                                                {
                                                    value1Text = value1Text + szinnerText[i];

                                                }
                                                else
                                                {
                                                    value2Text = szinnerText.Substring(i + 3);
                                                    break;
                                                }

                                            }

                                            double value1 = Convert.ToDouble(value1Text, CultureInfo.InvariantCulture);
                                            double value2 = Convert.ToDouble(value2Text, CultureInfo.InvariantCulture);

                                            Value = Value + (value1 * value2);

                                        }
                                    }
                                }
                                xNode1 = xNode1.NextSibling;
                            }
                            if (xNode1 != null)
                            {
                                if (xNode1.LocalName.CompareTo(xRoot.SelectSingleNode(xPath2).LocalName) == 0)
                                {
                                    string Valuetext = xNode1.InnerText;
                                    Valuetext = Valuetext.Replace(Constants.COMMA, decimalSeparator);
                                    if (Convert.ToDouble(Valuetext, CultureInfo.InvariantCulture) != Value)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                    }
                                }
                            }

                        }
                    }
                    count++;
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule42
        /// </method>
        /// <summary>
        ///		The currency code in all fields 68A in a currency details sequence preceding a field 19,
        ///		 must be the same.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Absolute Xpath to the element that contains the sequence of 68A fields.
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Relative XPath to the 68A element itself, within the XPath1 above
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Input containing Conditional Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input containing Conditional Rule Number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule42(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath1,
            string xPath2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule42" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                // XML element name of the the field containing the currency code... - this is expected to be common in all the 
                // message types that use this rule

                const string ElementNameWithCurrencyCode = "NumberCurrencyAndDenomination";

                XmlNode xRoot = xDocument.Document;

                XmlNodeList segments = xRoot.SelectNodes(xPath1);

                foreach (XmlNode seg in segments)
                {
                    XmlNodeList detail68AList = seg.SelectNodes(xPath2);

                    if (detail68AList.Count <= 1)
                    {
                        continue;
                    }

                    string currencyCode = String.Empty;
                    foreach (XmlNode detail in detail68AList)
                    {
                        if (currencyCode.Length == 0)
                        {
                            string s = detail.SelectSingleNode(@"descendant::" + ElementNameWithCurrencyCode).InnerText;
                            for (int i = 0; i < s.Length; i++)
                            {
                                if (!Char.IsNumber(s[i]))
                                {
                                    currencyCode = s.Substring(i, 3);
                                    break;
                                }
                            }
                            continue;
                        }
                        string currencyCode2 = String.Empty;
                        string s2 = detail.SelectSingleNode(@"descendant::" + ElementNameWithCurrencyCode).InnerText;

                        for (int i = 0; i < s2.Length; i++)
                        {
                            if (!Char.IsNumber(s2[i]))
                            {
                                currencyCode2 = s2.Substring(i, 3);
                                break;
                            }
                        }

                        if (currencyCode2 != currencyCode)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                                            messageType, conditionalRuleName, conditionalRuleNumber);
                            return false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule155
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 155
        ///		In sequences B, C, E and F, if field 14A consists of code OTHER, field 37N must be present in the respective sequence
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag14A">
        ///		Input reference of the element 14A (list separated by comma) to be validated.
        /// </param>
        /// <param name="tagValue">
        /// 	Input Value of tag 14A.
        /// </param>
        /// <param name="xPathTag37N">
        ///		Input reference of the element 37N (list separated by comma) to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule155(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag14A,
            string tagValue,
            string xPathTag37N,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule155" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathTag14A) throw new ArgumentNullException("xPathTag14A");
                if (null == xPathTag37N) throw new ArgumentNullException("xPathTag37N");


                bool isPresent = true;

                string[] xPathTag14AArray = xPathTag14A.Split(Constants.CHRCOMMA);
                string[] xPathTag37NArray = xPathTag37N.Split(Constants.CHRCOMMA);

                int lengthxPath = 0;
                lengthxPath = xPathTag14AArray.Length;

                if (xDocument == null ||
                    xPathTag14A == null ||
                    tagValue == null ||
                    xPathTag37N == null ||
                    xPathTag14A.Length == 0 ||
                    tagValue.Length == 0 ||
                    xPathTag37N.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                {
                    XmlNodeList xList14A = xRoot.SelectNodes(xPathTag14AArray[nCount].ToString());
                    if (xList14A.Count != 0)
                    {
                        if (xList14A.Item(0).InnerText.CompareTo(tagValue) == 0)
                        {
                            XmlNodeList xList37N = xRoot.SelectNodes(xPathTag37NArray[nCount].ToString());
                            if (xList37N.Count == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }
                    }

                }
                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule137
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 137
        ///		In sequences B, C, E and F, if field 14D consists of code OTHER, field 37N must be present in the respective sequence
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag14D">
        ///		Input reference of the element 14D (list separated by comma) to be validated.
        /// </param>
        /// <param name="tagValue">
        /// 	Input Value of tag 14A.
        /// </param>
        /// <param name="xPathTag37N">
        ///		Input reference of the element 37N (list separated by comma) to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule137(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag14D,
            string tagValue,
            string xPathTag37N,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule137" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathTag14D) throw new ArgumentNullException("xPathTag14D");
                if (null == xPathTag37N) throw new ArgumentNullException("xPathTag37N");


                bool isPresent = true;

                string[] xPathTag14DArray = xPathTag14D.Split(Constants.CHRCOMMA);
                string[] xPathTag37NArray = xPathTag37N.Split(Constants.CHRCOMMA);

                int lengthxPath = 0;
                lengthxPath = xPathTag14DArray.Length;

                if (xDocument == null ||
                    xPathTag14D == null ||
                    tagValue == null ||
                    xPathTag37N == null ||
                    xPathTag14D.Length == 0 ||
                    tagValue.Length == 0 ||
                    xPathTag37N.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                {
                    XmlNodeList xList14D = xRoot.SelectNodes(xPathTag14DArray[nCount].ToString());
                    if (xList14D.Count != 0)
                    {
                        if (xList14D.Item(0).InnerText.CompareTo(tagValue) == 0)
                        {
                            XmlNodeList xList37N = xRoot.SelectNodes(xPathTag37NArray[nCount].ToString());
                            if (xList37N.Count == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }
                    }

                }
                if (isPresent == false)
                {
                    isValid = false;
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule138
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 138
        ///		In sequences C and F, if field 14F consists of code OTHER, field 37N must be present in the respective sequence
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag14F">
        ///		Input reference of the element 14F (list separated by comma) to be validated.
        /// </param>
        /// <param name="tagValue">
        /// 	Input Value of tag 14F.
        /// </param>
        /// <param name="xPathTag37N">
        ///		Input reference of the element 37N (list separated by comma) to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule138(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag14F,
            string tagValue,
            string xPathTag37N,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule138" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathTag14F) throw new ArgumentNullException("xPathTag14F");
                if (null == xPathTag37N) throw new ArgumentNullException("xPathTag37N");


                bool isPresent = true;

                string[] xPathTag14FArray = xPathTag14F.Split(Constants.CHRCOMMA);
                string[] xPathTag37NArray = xPathTag37N.Split(Constants.CHRCOMMA);

                int lengthxPath = 0;
                lengthxPath = xPathTag14FArray.Length;

                if (xDocument == null ||
                    xPathTag14F == null ||
                    tagValue == null ||
                    xPathTag37N == null ||
                    xPathTag14F.Length == 0 ||
                    tagValue.Length == 0 ||
                    xPathTag37N.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                {
                    XmlNodeList xList14F = xRoot.SelectNodes(xPathTag14FArray[nCount].ToString());
                    if (xList14F.Count != 0)
                    {
                        if (xList14F.Item(0).InnerText.CompareTo(tagValue) == 0)
                        {
                            XmlNodeList xList37N = xRoot.SelectNodes(xPathTag37NArray[nCount].ToString());
                            if (xList37N.Count == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }
                    }

                }
                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule139
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 139
        ///		In sequences C and F, if field 14J consists of code OTHER, field 37N must be present in the respective sequence
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag14J">
        ///		Input reference of the element 14J (list separated by comma) to be validated.
        /// </param>
        /// <param name="tagValue">
        ///		Input Value of tag 14J.
        /// </param>
        /// <param name="xPathTag37N">
        ///		Input reference of the element 37N (list separated by comma) to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule139(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag14J,
            string tagValue,
            string xPathTag37N,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule139" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathTag14J) throw new ArgumentNullException("xPathTag14J");
                if (null == xPathTag37N) throw new ArgumentNullException("xPathTag37N");


                bool isPresent = true;

                string[] xPathTag14JArray = xPathTag14J.Split(Constants.CHRCOMMA);
                string[] xPathTag37NArray = xPathTag37N.Split(Constants.CHRCOMMA);

                int lengthxPath = 0;
                lengthxPath = xPathTag14JArray.Length;

                if (xDocument == null ||
                    xPathTag14J == null ||
                    tagValue == null ||
                    xPathTag37N == null ||
                    xPathTag14J.Length == 0 ||
                    tagValue.Length == 0 ||
                    xPathTag37N.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                {
                    XmlNodeList xList14J = xRoot.SelectNodes(xPathTag14JArray[nCount].ToString());
                    if (xList14J.Count != 0)
                    {
                        if (xList14J.Item(0).InnerText.CompareTo(tagValue) == 0)
                        {
                            XmlNodeList xList37N = xRoot.SelectNodes(xPathTag37NArray[nCount].ToString());
                            if (xList37N.Count == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }
                    }

                }
                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule140
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 140
        ///		In sequences C and F, if Frequency of field 14G consists of code O, field 37N must be present in the respective sequence
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag14G">
        ///		Input reference of the element 14G (list separated by comma) to be validated.
        /// </param>
        /// <param name="tagValue">
        /// 	Input Value of tag 14G.
        /// </param>
        /// <param name="xPathTag37N">
        ///		Input reference of the element 37N (list separated by comma) to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule140(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag14G,
            string tagValue,
            string xPathTag37N,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule140" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathTag14G) throw new ArgumentNullException("xPathTag14G");
                if (null == xPathTag37N) throw new ArgumentNullException("xPathTag37N");


                bool isPresent = true;

                string[] xPathTag14GArray = xPathTag14G.Split(Constants.CHRCOMMA);
                string[] xPathTag37NArray = xPathTag37N.Split(Constants.CHRCOMMA);

                int lengthxPath = 0;
                lengthxPath = xPathTag14GArray.Length;

                if (xDocument == null ||
                    xPathTag14G == null ||
                    tagValue == null ||
                    xPathTag37N == null ||
                    xPathTag14G.Length == 0 ||
                    tagValue.Length == 0 ||
                    xPathTag37N.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                {
                    XmlNodeList xList14G = xRoot.SelectNodes(xPathTag14GArray[nCount].ToString());
                    if (xList14G.Count != 0)
                    {
                        if (xList14G.Item(0).InnerText.CompareTo(tagValue) == 0)
                        {
                            XmlNodeList xList37N = xRoot.SelectNodes(xPathTag37NArray[nCount].ToString());
                            if (xList37N.Count == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }
                    }

                }
                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule141
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 141
        ///		In sequences C and F, if Period of field 38E consists of code O, field 37N must be present in the respective sequence
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag38E">
        ///		Input reference of the element 38E (list separated by comma) to be validated.
        /// </param>
        /// <param name="tagValue">
        /// 	Input Value of tag 38E.
        /// </param>
        /// <param name="xPathTag37N">
        ///		Input reference of the element 37N (list separated by comma) to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule141(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag38E,
            string tagValue,
            string xPathTag37N,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule141" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathTag38E) throw new ArgumentNullException("xPathTag38E");
                if (null == xPathTag37N) throw new ArgumentNullException("xPathTag37N");


                bool isPresent = true;

                string[] xPathTag38EArray = xPathTag38E.Split(Constants.CHRCOMMA);
                string[] xPathTag37NArray = xPathTag37N.Split(Constants.CHRCOMMA);

                int lengthxPath = 0;
                lengthxPath = xPathTag38EArray.Length;

                if (xDocument == null ||
                    xPathTag38E == null ||
                    tagValue == null ||
                    xPathTag37N == null ||
                    xPathTag38E.Length == 0 ||
                    tagValue.Length == 0 ||
                    xPathTag37N.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                {
                    XmlNodeList xList38E = xRoot.SelectNodes(xPathTag38EArray[nCount].ToString());
                    if (xList38E.Count != 0)
                    {
                        if (xList38E.Item(0).InnerText.EndsWith(tagValue))
                        {
                            XmlNodeList xList37N = xRoot.SelectNodes(xPathTag37NArray[nCount].ToString());
                            if (xList37N.Count == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }
                    }

                }
                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule142
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 142
        ///		In sequences C and F, if Period From or Period To of 38G or field 38H consist of code O, field 37N must be present in the respective sequence
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag38G">
        ///		Input reference of the element 38G (list separated by comma) to be validated.
        /// </param>
        /// <param name="xPathTag38H">
        ///		Input reference of the element 38H (list separated by comma) to be validated.
        /// </param>
        /// <param name="tagValue">
        ///		Input Value of tag 38G, 38H.
        /// </param>
        /// <param name="xPathTag37N">
        ///		Input reference of the element 37N (list separated by comma) to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule142(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag38G,
            string xPathTag38H,
            string tagValue,
            string xPathTag37N,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule142" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathTag38G) throw new ArgumentNullException("xPathTag38G");
                if (null == xPathTag38H) throw new ArgumentNullException("xPathTag38H");
                if (null == xPathTag37N) throw new ArgumentNullException("xPathTag37N");


                bool isPresent = true;

                string[] xPathTag38GArray = xPathTag38G.Split(Constants.CHRCOMMA);
                string[] xPathTag38HArray = xPathTag38H.Split(Constants.CHRCOMMA);
                string[] xPathTag37NArray = xPathTag37N.Split(Constants.CHRCOMMA);

                int lengthxPath = 0;
                lengthxPath = xPathTag38GArray.Length;

                if (xDocument == null ||
                    xPathTag38G == null ||
                    xPathTag38H == null ||
                    tagValue == null ||
                    xPathTag37N == null ||
                    xPathTag38G.Length == 0 ||
                    xPathTag38H.Length == 0 ||
                    tagValue.Length == 0 ||
                    xPathTag37N.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                {
                    XmlNodeList xList38G = xRoot.SelectNodes(xPathTag38GArray[nCount].ToString());
                    if (xList38G.Count != 0)
                    {
                        if ((xList38G.Item(0).FirstChild.InnerText.EndsWith(tagValue)) || (xList38G.Item(0).LastChild.InnerText.EndsWith(tagValue)))
                        {
                            XmlNodeList xList37N = xRoot.SelectNodes(xPathTag37NArray[nCount].ToString());
                            if (xList37N.Count == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }
                    }
                    XmlNodeList xList38H = xRoot.SelectNodes(xPathTag38HArray[nCount].ToString());
                    if (xList38H.Count != 0)
                    {
                        if ((xList38H.Item(0).FirstChild.InnerText.EndsWith(tagValue)) || (xList38H.Item(0).LastChild.InnerText.EndsWith(tagValue)))
                        {
                            XmlNodeList xList37N = xRoot.SelectNodes(xPathTag37NArray[nCount].ToString());
                            if (xList37N.Count == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }
                    }

                }
                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule158
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 158
        ///		Depending on the code value in sequence A, field 23A Type of Swap, only the following combinations of the optional sequences B, C, E, F, L and M are allowed.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag23A">
        ///		Input reference of the element 23A to be validated.
        /// </param>
        /// <param name="valueTag23A">
        /// 	Input Value of tag 23A.
        /// </param>
        /// <param name="xPathMandatoryTag">
        ///		Input reference of the mandatory tag (list separated by comma) to be validated.
        /// </param>
        /// <param name="xPathNotAllowedTag">
        ///		Input reference of the 'Not allowed' tag (list separated by comma) to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule158(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag23A,
            string valueTag23A,
            string xPathMandatoryTag,
            string xPathNotAllowedTag,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule158" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathMandatoryTag) throw new ArgumentNullException("xPathMandatoryTag");
                if (null == xPathNotAllowedTag) throw new ArgumentNullException("xPathNotAllowedTag");
                if (null == errorObject) throw new ArgumentNullException("errorObject");


                bool isPresent = true;

                string[] xPathMandatorySeqArray = xPathMandatoryTag.Split(Constants.CHRCOMMA);
                string[] xPathNotAllowedSeqArray = xPathNotAllowedTag.Split(Constants.CHRCOMMA);

                int lengthxPathMandatorySeq = 0;
                lengthxPathMandatorySeq = xPathMandatorySeqArray.Length;

                int lengthxPathNotAllowedSeq = 0;
                lengthxPathNotAllowedSeq = xPathNotAllowedSeqArray.Length;

                if (xDocument == null ||
                    xPathTag23A == null ||
                    xPathMandatoryTag == null ||
                    xPathNotAllowedTag == null ||
                    valueTag23A == null ||
                    xPathTag23A.Length == 0 ||
                    xPathMandatoryTag.Length == 0 ||
                    xPathNotAllowedTag.Length == 0 ||
                    valueTag23A.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList23A = xRoot.SelectNodes(xPathTag23A.ToString());

                if (xList23A.Count != 0)
                {
                    if (xList23A.Item(0).InnerText.CompareTo(valueTag23A) == 0)
                    {
                        for (int nCount = 0; nCount <= lengthxPathMandatorySeq - 1; nCount++)
                        {
                            XmlNodeList xListMandatorySeq = xRoot.SelectNodes(xPathMandatorySeqArray[nCount].ToString());
                            if (xListMandatorySeq.Count == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }

                        for (int nCount = 0; nCount <= lengthxPathNotAllowedSeq - 1; nCount++)
                        {
                            XmlNodeList xListNotAllowedSeq = xRoot.SelectNodes(xPathNotAllowedSeqArray[nCount].ToString());
                            if (xListNotAllowedSeq.Count != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }
                    }
                }
                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule145
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 145
        ///		If in Sequence B field 37U is Present -
        ///			if Subsequence B1 is present then in each occurrence of the internal loop field 32M is Not allowed
        /// 		if Subsequence B1 is present then field 17F is Mandatory
        ///			if Subsequence B1 is present then field 14D is Mandatory
        ///		If in Sequence B field 37U is NOT Present -
        ///			if Subsequence B1 is present then in each occurrence of the internal loop field 32M is Mandatory
        ///			if Subsequence B1 is present then field 17F is Not Allowed
        ///			if Subsequence B1 is present then field 14D is Not Allowed
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag37U">
        ///		Input reference of the element 37U to be validated.
        /// </param>
        /// <param name="xPathSeqB1">
        ///		Input reference of the element Sequence B1 to be validated.
        /// </param>
        /// <param name="xPathTag30F">
        ///		Input reference of the element 30F to be validated.
        /// </param>
        /// <param name="xPathTag32M">
        ///		Input reference of the element 32M to be validated.
        /// </param>
        /// <param name="xPathTag17F">
        ///		Input reference of the element 17F to be validated.
        /// </param>
        /// <param name="xPathTag14D">
        ///		Input reference of the element 14D to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule145(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag37U,
            string xPathSeqB1,
            string xPathTag30F,
            string xPathTag32M,
            string xPathTag17F,
            string xPathTag14D,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule145" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isPresent = true;

            try
            {
                if (xDocument == null ||
                    xPathTag37U == null ||
                    xPathSeqB1 == null ||
                    xPathTag30F == null ||
                    xPathTag32M == null ||
                    xPathTag17F == null ||
                    xPathTag14D == null ||
                    xPathTag37U.Length == 0 ||
                    xPathSeqB1.Length == 0 ||
                    xPathTag30F.Length == 0 ||
                    xPathTag32M.Length == 0 ||
                    xPathTag17F.Length == 0 ||
                    xPathTag14D.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSeqB1 = xRoot.SelectNodes(xPathSeqB1.ToString());

                if (xListSeqB1.Count != 0)
                {
                    XmlNodeList xList37U = xRoot.SelectNodes(xPathTag37U.ToString());
                    XmlNodeList xList32M = xRoot.SelectNodes(xPathTag32M.ToString());
                    XmlNodeList xList17F = xRoot.SelectNodes(xPathTag17F.ToString());
                    XmlNodeList xList14D = xRoot.SelectNodes(xPathTag14D.ToString());

                    if (xList37U.Count != 0)
                    {
                        if ((xList32M.Count != 0) || (xList17F.Count == 0) || (xList14D.Count == 0))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isPresent = false;
                        }
                    }
                    else
                    {
                        bool is30FPresent = false;

                        XmlNodeList xList30F = xRoot.SelectNodes(xPathTag30F.ToString());

                        if (xList32M.Count == xList30F.Count)
                        {
                            is30FPresent = true;
                        }
                        if ((is30FPresent == false) || (xList17F.Count != 0) || (xList14D.Count != 0))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isPresent = false;
                        }
                    }
                    if (isPresent == false)
                    {
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule159
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 159
        ///		If in Sequence E field 37U is Present -
        ///			if Subsequence E1 is present then in each occurrence of the internal loop field 32M is Not allowed
        /// 		if Subsequence E1 is present then field 17F is Mandatory
        ///			if Subsequence E1 is present then field 14D is Mandatory
        ///		If in Sequence E field 37U is NOT Present -
        ///			if Subsequence E1 is present then in each occurrence of the internal loop field 32M is Mandatory
        ///			if Subsequence E1 is present then field 17F is Not Allowed
        ///			if Subsequence E1 is present then field 14D is Not Allowed
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag37U">
        ///		Input reference of the element 37U to be validated.
        /// </param>
        /// <param name="xPathSeqE1">
        ///		Input reference of the element Sequence E1 to be validated.
        /// </param>
        /// <param name="xPathTag30F">
        ///		Input reference of the element 30F to be validated.
        /// </param>
        /// <param name="xPathTag32M">
        ///		Input reference of the element 32M to be validated.
        /// </param>
        /// <param name="xPathTag17F">
        ///		Input reference of the element 17F to be validated.
        /// </param>
        /// <param name="xPathTag14D">
        ///		Input reference of the element 14D to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule159(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag37U,
            string xPathSeqE1,
            string xPathTag30F,
            string xPathTag32M,
            string xPathTag17F,
            string xPathTag14D,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule159" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isPresent = true;
            try
            {
                if (xDocument == null ||
                    xPathTag37U == null ||
                    xPathSeqE1 == null ||
                    xPathTag30F == null ||
                    xPathTag32M == null ||
                    xPathTag17F == null ||
                    xPathTag14D == null ||
                    xPathTag37U.Length == 0 ||
                    xPathSeqE1.Length == 0 ||
                    xPathTag30F.Length == 0 ||
                    xPathTag32M.Length == 0 ||
                    xPathTag17F.Length == 0 ||
                    xPathTag14D.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSeqE1 = xRoot.SelectNodes(xPathSeqE1.ToString());

                if (xListSeqE1.Count != 0)
                {
                    XmlNodeList xList37U = xRoot.SelectNodes(xPathTag37U.ToString());
                    XmlNodeList xList32M = xRoot.SelectNodes(xPathTag32M.ToString());
                    XmlNodeList xList17F = xRoot.SelectNodes(xPathTag17F.ToString());
                    XmlNodeList xList14D = xRoot.SelectNodes(xPathTag14D.ToString());

                    if (xList37U.Count != 0)
                    {
                        if ((xList32M.Count != 0) || (xList17F.Count == 0) || (xList14D.Count == 0))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isPresent = false;
                        }
                    }
                    else
                    {
                        bool is30FPresent = false;
                        XmlNodeList xList30F = xRoot.SelectNodes(xPathTag30F.ToString());

                        if (xList32M.Count == xList30F.Count)
                        {
                            is30FPresent = true;
                        }
                        if ((is30FPresent == false) || (xList17F.Count != 0) || (xList14D.Count != 0))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isPresent = false;
                        }
                    }
                }
                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule148
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 148
        ///		For all occurrences of the fields 53a, 56a and 57a in sequences L or M:
        ///		If, in sequence L or M,field 57a is Present Then, in the same sequence fields 53a, 56a are Optional
        ///		If, in sequence L or M,field 57a is NOT Present Then, in the same sequence fields 53a, 56a are NOT ALLOWED
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSeqLTag57a">
        ///		Input reference of the element 57a of Sequence L to be validated.
        /// </param>
        /// <param name="xPathSeqLTag53a56a">
        ///		Input reference of the element 53a and 56a (separated by comma) of Sequence L to be validated.
        /// </param>
        /// <param name="xPathSeqMTag57a">
        ///		Input reference of the element 57a of Sequence M to be validated.
        /// </param>
        /// <param name="xPathSeqMTag53a56a">
        ///		Input reference of the element 53a and 56a (separated by comma) of Sequence M to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule148(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSeqLTag57a,
            string xPathSeqLTag53a56a,
            string xPathSeqMTag57a,
            string xPathSeqMTag53a56a,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule148" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathSeqLTag57a) throw new ArgumentNullException("xPathSeqLTag57a");
                if (null == xPathSeqLTag53a56a) throw new ArgumentNullException("xPathSeqLTag53a56a");
                if (null == xPathSeqMTag57a) throw new ArgumentNullException("xPathSeqMTag57a");
                if (null == xPathSeqMTag53a56a) throw new ArgumentNullException("xPathSeqMTag53a56a");
                if (null == errorObject) throw new ArgumentNullException("errorObject");


                bool isPresent = true;
                bool isTag57aPresent = false;

                string[] xPathSeqLTag57aArray = xPathSeqLTag57a.Split(Constants.CHRCOMMA);
                string[] xPathSeqLTag53a56aArray = xPathSeqLTag53a56a.Split(Constants.CHRCOMMA);
                string[] xPathSeqMTag57aArray = xPathSeqMTag57a.Split(Constants.CHRCOMMA);
                string[] xPathSeqMTag53a56aArray = xPathSeqMTag53a56a.Split(Constants.CHRCOMMA);

                int lengthxPathSeqLTag57aArray = xPathSeqLTag57aArray.Length;
                int lengthxPathSeqLTag53a56aArray = xPathSeqLTag53a56aArray.Length;
                int lengthxPathSeqMTag57aArray = xPathSeqMTag57aArray.Length;
                int lengthxPathSeqMTag53a56aArray = xPathSeqMTag53a56aArray.Length;

                if (xDocument == null ||
                    xPathSeqLTag57a == null ||
                    xPathSeqLTag53a56a == null ||
                    xPathSeqMTag57a == null ||
                    xPathSeqMTag53a56a == null ||
                    xPathSeqLTag57a.Length == 0 ||
                    xPathSeqLTag53a56a.Length == 0 ||
                    xPathSeqMTag57a.Length == 0 ||
                    xPathSeqMTag53a56a.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                for (int nCount = 0; nCount <= lengthxPathSeqLTag57aArray - 1; nCount++)
                {
                    XmlNodeList xListSeqLTag57a = xRoot.SelectNodes(xPathSeqLTag57aArray[nCount].ToString());

                    if (xListSeqLTag57a.Count != 0)
                    {
                        isTag57aPresent = true;
                        break;
                    }
                }

                if (isTag57aPresent == false)
                {
                    for (int nCountChild = 0; nCountChild <= lengthxPathSeqLTag53a56aArray - 1; nCountChild++)
                    {
                        XmlNodeList xListSeqLTag53a56a = xRoot.SelectNodes(xPathSeqLTag53a56aArray[nCountChild].ToString());

                        if (xListSeqLTag53a56a.Count != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isPresent = false;
                        }

                    }

                }

                isTag57aPresent = false;

                for (int nCount = 0; nCount <= lengthxPathSeqMTag57aArray - 1; nCount++)
                {
                    XmlNodeList xListSeqMTag57a = xRoot.SelectNodes(xPathSeqMTag57aArray[nCount].ToString());

                    if (xListSeqMTag57a.Count != 0)
                    {
                        isTag57aPresent = true;
                        break;
                    }
                }

                if (isTag57aPresent == false)
                {
                    for (int nCountChild = 0; nCountChild <= lengthxPathSeqMTag53a56aArray - 1; nCountChild++)
                    {
                        XmlNodeList xListSeqMTag53a56a = xRoot.SelectNodes(xPathSeqMTag53a56aArray[nCountChild].ToString());

                        if (xListSeqMTag53a56a.Count != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isPresent = false;
                        }

                    }

                }

                if (isPresent == false)
                {
                    isValid = false;
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule235
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 235
        ///		For all occurrences of the fields 56a and 86a:
        ///		If, in a sequence,field 56a is Present then, in the same sequence,field 86a is Optional
        /// 	If, in a sequence,field 56a is Not present then, in the same sequence,field 86a is Not allowed
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        ///		Input reference of the Sequences (separated by comma) to be validated.
        /// </param>
        /// <param name="xPathTag56a">
        ///		Input reference of the element 56a (list separated by comma) to be validated.
        /// </param>
        /// <param name="xPathTag86a">
        ///		Input reference of the element 86a (list separated by comma) to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule235(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag56a,
            string xPathTag86a,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule235" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathSequence) throw new ArgumentNullException("xPathSequence");
                if (null == xPathTag56a) throw new ArgumentNullException("xPathTag56a");
                if (null == xPathTag86a) throw new ArgumentNullException("xPathTag86a");
                if (null == errorObject) throw new ArgumentNullException("errorObject");


                bool isPresent = true;
                bool is56aPresent = false;

                string[] xPathSequenceArray = xPathSequence.Split(Constants.CHRCOMMA);
                string[] xPathTag56aArray = xPathTag56a.Split(Constants.CHRCOMMA);
                string[] xPathTag86aArray = xPathTag86a.Split(Constants.CHRCOMMA);

                int lengthxPathSequenceArray = xPathSequenceArray.Length;
                int lengthxPathTag56aArray = xPathTag56aArray.Length;
                int lengthxPathTag86aArray = xPathTag86aArray.Length;

                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathTag56a == null ||
                    xPathTag86a == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag56a.Length == 0 ||
                    xPathTag86a.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                for (int nCount = 0; nCount <= lengthxPathSequenceArray - 1; nCount++)
                {
                    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequenceArray[nCount].ToString());
                    is56aPresent = false;

                    //It checks if the Sequence exist.
                    if (xListSequence.Count != 0)
                    {
                        //If Sequence exists, It checks if tag 86a exist in it.
                        for (int nCount86a = 0; nCount86a <= lengthxPathTag86aArray - 1; nCount86a++)
                        {
                            if (xListSequence.Item(0).SelectSingleNode(xPathTag86aArray[nCount86a]) != null)
                            {
                                //If tag 86a exists then it checks if Tag 56a exists in it.
                                for (int nCount56a = 0; nCount56a <= lengthxPathTag56aArray - 1; nCount56a++)
                                {
                                    if (xListSequence.Item(0).SelectSingleNode(xPathTag56aArray[nCount56a]) != null)
                                    {
                                        is56aPresent = true;
                                        break;
                                    }
                                }
                                //If tag 56a does not exist then it throws an error.
                                if (is56aPresent == false)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isPresent = false;
                                }
                                break;
                            }
                        }
                    }

                }

                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule240
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 240
        ///		In Sequence A,if subfield 1 of field 77H is AFB, then fields 14G, 37R in subsequences C1 and F1	and Subsequences C2 and F2 are Not allowed
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag77H">
        ///		Input reference of the element 77F to be validated.
        /// </param>
        /// <param name="valueTag77H">
        ///		Input value of Tag 77H
        /// </param>
        /// <param name="xPathNotAllowedTag">
        ///		Input reference of the 'Not Allowed' tag to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule240(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag77H,
            string valueTag77H,
            string xPathNotAllowedTag,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule240" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathNotAllowedTag) throw new ArgumentNullException("xPathNotAllowedTag");


                bool isPresent = true;

                string[] xPathNotAllowedTagArray = xPathNotAllowedTag.Split(Constants.CHRCOMMA);

                int lengthxPathNotAllowedTag = 0;
                lengthxPathNotAllowedTag = xPathNotAllowedTagArray.Length;

                if (xDocument == null ||
                    xPathTag77H == null ||
                    xPathNotAllowedTag == null ||
                    valueTag77H == null ||
                    xPathTag77H.Length == 0 ||
                    xPathNotAllowedTag.Length == 0 ||
                    valueTag77H.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList77H = xRoot.SelectNodes(xPathTag77H.ToString());

                if (xList77H.Count != 0)
                {
                    if (xList77H.Item(0).InnerText.CompareTo(valueTag77H) == 0)
                    {
                        for (int nCount = 0; nCount <= lengthxPathNotAllowedTag - 1; nCount++)
                        {
                            XmlNodeList xListNotAllowedTag = xRoot.SelectNodes(xPathNotAllowedTagArray[nCount].ToString());
                            if (xListNotAllowedTag.Count != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }
                    }
                }
                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule241
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 241
        ///
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathFloatIntPaySeq">
        ///		Input reference of the 'Floating Interest Payable by Party' Sequence to be validated.
        /// </param>
        /// <param name="xPathTag77H">
        ///		Input reference of the element 77F to be validated.
        /// </param>
        /// <param name="valueTag77H">
        ///		Input value of Tag 77H
        /// </param>
        /// <param name="xPathTag14F">
        ///		Input reference of the element 14F to be validated.
        /// </param>
        /// <param name="valueTag14F">
        ///		Input value of Tag 14F
        /// </param>
        /// <param name="xPathNotAllowedTag">
        ///		Input reference of the 'Not Allowed' tag to be validated.
        /// </param>
        /// <param name="xPathFixedIntPaySeq">
        ///		Input reference of the 'Fixed Interest Payable by Party' Sequence to be validated.
        /// </param>
        /// <param name="xPathIntDetSeq">
        ///		Input reference of the 'Interest Details' SubSequence to be validated.
        /// </param>
        /// <param name="xPathTag37U">
        ///		Input reference of the element 37U to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule241(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathFloatIntPaySeq,
            string xPathTag77H,
            string valueTag77H,
            string xPathTag14F,
            string valueTag14F,
            string xPathNotAllowedTag,
            string xPathFixedIntPaySeq,
            string xPathIntDetSeq,
            string xPathTag37U,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule241" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathNotAllowedTag) throw new ArgumentNullException("xPathNotAllowedTag");

                bool isPresent = true;

                string[] xPathNotAllowedTagArray = xPathNotAllowedTag.Split(Constants.CHRCOMMA);

                int lengthxPathNotAllowedTag = 0;
                lengthxPathNotAllowedTag = xPathNotAllowedTagArray.Length;

                if (xDocument == null ||
                    xPathFloatIntPaySeq == null ||
                    xPathTag77H == null ||
                    valueTag77H == null ||
                    xPathTag14F == null ||
                    valueTag14F == null ||
                    xPathNotAllowedTag == null ||
                    xPathFixedIntPaySeq == null ||
                    xPathIntDetSeq == null ||
                    xPathTag37U == null ||
                    xPathFloatIntPaySeq.Length == 0 ||
                    xPathTag77H.Length == 0 ||
                    valueTag77H.Length == 0 ||
                    xPathTag14F.Length == 0 ||
                    valueTag14F.Length == 0 ||
                    xPathNotAllowedTag.Length == 0 ||
                    xPathFixedIntPaySeq.Length == 0 ||
                    xPathIntDetSeq.Length == 0 ||
                    xPathTag37U.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                //Check for the existence of Sequence
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathFloatIntPaySeq.ToString());
                if (xListSequence.Count != 0)
                {
                    XmlNodeList xListTag77H = xRoot.SelectNodes(xPathTag77H.ToString());
                    if (xListTag77H.Count != 0)
                    {
                        if (xListTag77H.Item(0).InnerText.CompareTo(valueTag77H) == 0)
                        {
                            XmlNode xListTag14F = xListSequence.Item(0).SelectSingleNode(xPathTag14F);
                            if (xListTag14F != null && valueTag14F.IndexOf(xListTag14F.InnerText.ToString()) != -1)
                            {
                                for (int nCount = 0; nCount <= lengthxPathNotAllowedTag - 1; nCount++)
                                {
                                    if (xListSequence.Item(0).SelectSingleNode(xPathNotAllowedTagArray[nCount].ToString()) != null)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isPresent = false;
                                    }

                                }

                                //If Fixed Ineterest Payable by Party is present then 37U is mandatory and Interest Details subsequence is not allowed.
                                XmlNodeList xListFIPSequence = xRoot.SelectNodes(xPathFixedIntPaySeq.ToString());
                                if (xListFIPSequence.Count != 0)
                                {
                                    if (xListFIPSequence.Item(0).SelectSingleNode(xPathIntDetSeq.ToString()) != null)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isPresent = false;
                                    }

                                    if (xListFIPSequence.Item(0).SelectSingleNode(xPathTag37U.ToString()) == null)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isPresent = false;
                                    }
                                }
                            }
                        }
                    }

                }

                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }


        /// <method>
        ///		SWIFTNetworkRule241
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 241
        ///		IF SEQUENCE C IS PRESENT AND in Sequence A, if subfield 1 of field 77H is the given value (valueTag77H) AND in Sequence C,
        ///		if field 14F is given value (valueTag14F) then Subsequences C1, C2 and C3 are Not allowed.
        ///		IF BOTH SEQUENCES C AND E ARE PRESENT then Subsequence E1 is Not Allowed and in Sequence E field 37U is Mandatory
        ///		Similarly for Sequence F and B, Subsequence F1,F2,F3 and B1.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathFloatIntPaySeq">
        ///		Input reference of the 'Floating Interest Payable by Party' Sequence to be validated.
        /// </param>
        /// <param name="xPathTag77H">
        ///		Input reference of the element 77F to be validated.
        /// </param>
        /// <param name="valueTag77H">
        ///		Input value of Tag 77H
        /// </param>
        /// <param name="xPathMandatorySeq">
        ///		Input reference of the Mandatory Sequence to be validated.
        /// </param>
        /// <param name="xPathFixedIntPaySeq">
        ///		Input reference of the 'Fixed Interest Payable by Party' Sequence to be validated.
        /// </param>
        /// <param name="xPathIntDetSeq">
        ///		Input reference of the 'Interest Details' SubSequence to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule241(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathFloatIntPaySeq,
            string xPathTag77H,
            string valueTag77H,
            string xPathMandatorySeq,
            string xPathFixedIntPaySeq,
            string xPathIntDetSeq,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule241" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isPresent = true;
            try
            {
                if (xDocument == null ||
                    xPathFloatIntPaySeq == null ||
                    xPathTag77H == null ||
                    valueTag77H == null ||
                    xPathMandatorySeq == null ||
                    xPathFixedIntPaySeq == null ||
                    xPathIntDetSeq == null ||
                    xPathFloatIntPaySeq.Length == 0 ||
                    xPathTag77H.Length == 0 ||
                    valueTag77H.Length == 0 ||
                    xPathMandatorySeq.Length == 0 ||
                    xPathFixedIntPaySeq.Length == 0 ||
                    xPathIntDetSeq.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                //Check for the existence of Sequence
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathFloatIntPaySeq.ToString());
                if (xListSequence.Count != 0)
                {
                    XmlNodeList xListTag77H = xRoot.SelectNodes(xPathTag77H.ToString());
                    if (xListTag77H.Count != 0)
                    {
                        if (valueTag77H.IndexOf(xListTag77H.Item(0).InnerText) == -1)
                        {
                            if (xListSequence.Item(0).SelectSingleNode(xPathMandatorySeq.ToString()) == null)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                            //If Fixed Ineterest Payable by Party is present then Interest Details subsequence is mandatory.
                            XmlNodeList xListFIPSequence = xRoot.SelectNodes(xPathFixedIntPaySeq.ToString());
                            if (xListFIPSequence.Count != 0)
                            {
                                if (xListFIPSequence.Item(0).SelectSingleNode(xPathIntDetSeq.ToString()) == null)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isPresent = false;
                                }
                            }
                        }
                    }

                }

                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule241
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 241
        ///		if B AND E sequences are present then Subsequence B1 and E1 are Mandatory
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSeqB">
        ///		Input reference of the Sequence B to be validated.
        /// </param>
        /// <param name="xPathSubSeqB1">
        ///		Input reference of the SubSequence B1 to be validated.
        /// </param>
        /// <param name="xPathSeqE">
        ///		Input reference of the Sequence E to be validated.
        /// </param>
        /// <param name="xPathSubSeqE1">
        ///		Input reference of the SubSequence E1 to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule241(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSeqB,
            string xPathSubSeqB1,
            string xPathSeqE,
            string xPathSubSeqE1,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule241" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSeqB == null ||
                    xPathSubSeqB1 == null ||
                    xPathSeqE == null ||
                    xPathSubSeqE1 == null ||
                    xPathSeqB.Length == 0 ||
                    xPathSubSeqB1.Length == 0 ||
                    xPathSeqE.Length == 0 ||
                    xPathSubSeqE1.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                //Check for the existence of Sequence
                XmlNodeList xListSeqB = xRoot.SelectNodes(xPathSeqB.ToString());
                XmlNodeList xListSeqE = xRoot.SelectNodes(xPathSeqE.ToString());

                if ((xListSeqB.Count != 0) && (xListSeqE.Count != 0))
                {
                    if ((xListSeqB.Item(0).SelectSingleNode(xPathSubSeqB1.ToString()) == null) || (xListSeqE.Item(0).SelectSingleNode(xPathSubSeqE1.ToString()) == null))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule102
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 102
        ///		In Sequence A, if field 22A is AMND or CANC then field 21 is Mandatory
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag22A">
        ///		Input reference of the element 22A to be validated.
        /// </param>
        /// <param name="valueTag22A">
        ///		Input value of Tag 22A
        /// </param>
        /// <param name="xPathMandatoryTag21">
        ///		Input reference of the Mandatory element 21 to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule102(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag22A,
            string valueTag22A,
            string xPathMandatoryTag21,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule102" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPathTag22A == null ||
                    valueTag22A == null ||
                    xPathMandatoryTag21 == null ||
                    xPathTag22A.Length == 0 ||
                    valueTag22A.Length == 0 ||
                    xPathMandatoryTag21.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList22A = xRoot.SelectNodes(xPathTag22A.ToString());

                if (xList22A.Count != 0)
                {
                    if (valueTag22A.IndexOf(xList22A.Item(0).InnerText) != -1)
                    {
                        XmlNodeList xListMandatoryTag = xRoot.SelectNodes(xPathMandatoryTag21.ToString());
                        if (xListMandatoryTag.Count == 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule174
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 174
        ///		In Sequence A, if field 94A is Not present, then Sequence N with field 71F is 'Not Allowed'
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag94A">
        ///		Input reference of the element 94A to be validated.
        /// </param>
        /// <param name="xPathNotAllowedTag71F">
        ///		Input reference of the 'Not Allowed' element 71F to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule174(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag94A,
            string xPathNotAllowedTag71F,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule174" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag94A == null ||
                    xPathNotAllowedTag71F == null ||
                    xPathTag94A.Length == 0 ||
                    xPathNotAllowedTag71F.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList94A = xRoot.SelectNodes(xPathTag94A.ToString());

                if (xList94A.Count == 0)
                {
                    XmlNodeList xList71F = xRoot.SelectNodes(xPathNotAllowedTag71F.ToString());
                    if (xList71F.Count != 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule174
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 174
        ///		In Sequence A, if field 94A is AGNT or BILA, then Sequence N with field 71F is 'Not Allowed'
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag94A">
        ///		Input reference of the element 94A to be validated.
        /// </param>
        /// <param name="valueTag94A">
        ///		Input value of Tag 94A
        /// </param>
        /// <param name="xPathNotAllowedTag71F">
        ///		Input reference of the 'Not Allowed' element 71F to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule174(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag94A,
            string valueTag94A,
            string xPathNotAllowedTag71F,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule174" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag94A == null ||
                    valueTag94A == null ||
                    xPathNotAllowedTag71F == null ||
                    xPathTag94A.Length == 0 ||
                    valueTag94A.Length == 0 ||
                    xPathNotAllowedTag71F.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList94A = xRoot.SelectNodes(xPathTag94A.ToString());

                if (xList94A.Count != 0)
                {
                    if (valueTag94A.IndexOf(xList94A.Item(0).InnerText) != -1)
                    {
                        XmlNodeList xList71F = xRoot.SelectNodes(xPathNotAllowedTag71F.ToString());
                        if (xList71F.Count != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule174
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 174
        ///		In Sequence A, if field 94A is BROK, then Sequence N and Sequence N with field 88a are mandatory
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag94A">
        ///		Input reference of the element 94A to be validated.
        /// </param>
        /// <param name="valueTag94A">
        ///		Input value of Tag 94A
        /// </param>
        /// <param name="xPathMandatoryTag">
        ///		Input reference of the Mandatory element to be validated.
        /// </param>
        /// <param name="xPathMandatoryTag88a">
        ///		Input reference of the Mandatory element 88a to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule174(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag94A,
            string valueTag94A,
            string xPathMandatoryTag,
            string xPathMandatoryTag88a,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule174" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathMandatoryTag88a) throw new ArgumentNullException("xPathMandatoryTag88a");
                if (null == xPathMandatoryTag) throw new ArgumentNullException("xPathMandatoryTag");


                bool isTag88aPresent = false;

                string[] xPathMandatoryTag88aArray = xPathMandatoryTag88a.Split(Constants.CHRCOMMA);
                int lengthxPathMandatoryTag88aArray = xPathMandatoryTag88aArray.Length;

                if (xDocument == null ||
                    xPathTag94A == null ||
                    valueTag94A == null ||
                    xPathMandatoryTag == null ||
                    xPathMandatoryTag88a == null ||
                    xPathTag94A.Length == 0 ||
                    valueTag94A.Length == 0 ||
                    xPathMandatoryTag.Length == 0 ||
                    xPathMandatoryTag88a.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList94A = xRoot.SelectNodes(xPathTag94A.ToString());

                if (xList94A.Count != 0)
                {
                    if (xList94A.Item(0).InnerText.CompareTo(valueTag94A.ToString()) == 0)
                    {
                        XmlNodeList xListMandatorySeq = xRoot.SelectNodes(xPathMandatoryTag.ToString());
                        if (xListMandatorySeq.Count == 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }

                        else
                        {
                            for (int nCount = 0; nCount <= lengthxPathMandatoryTag88aArray - 1; nCount++)
                            {
                                if (xListMandatorySeq.Item(0).SelectSingleNode(xPathMandatoryTag88aArray[nCount].ToString()) != null)
                                {
                                    isTag88aPresent = true;
                                    break;
                                }
                            }
                            if (isTag88aPresent == false)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule242
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 242
        ///		In Sequence A, if subfield 1 of field 23A is CAPBUYER, then field 37J of Sequence C is Mandatory and then field 37L of Sequence C is Not Allowed
        ///		In Sequence A, if subfield 1 of field 23A is CAPSELLER, then field 37J of Sequence F is Mandatory and then field 37L of Sequence F is Not Allowed
        ///		In Sequence A, if subfield 1 of field 23A is FLOORBUYER, then field 37J of Sequence C is Not Allowed and then field 37L of Sequence C is Mandatory
        ///		In Sequence A, if subfield 1 of field 23A is FLOORSLLER, then field 37J of Sequence F is Not Allowed and then field 37L of Sequence F is Mandatory
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag23A">
        ///		Input reference of the element 23A to be validated.
        /// </param>
        /// <param name="valueTag23A">
        ///		Input value of Tag 23A
        /// </param>
        /// <param name="xPathMandatoryTag">
        ///		Input reference of the Mandatory element to be validated.
        /// </param>
        /// <param name="xPathNotAllowedTag">
        ///		Input reference of the 'Not Allowed' element to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule242(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag23A,
            string valueTag23A,
            string xPathMandatoryTag,
            string xPathNotAllowedTag,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule242" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathMandatoryTag) throw new ArgumentNullException("xPathMandatoryTag");
                if (null == xPathNotAllowedTag) throw new ArgumentNullException("xPathNotAllowedTag");

                bool isPresent = true;

                string[] xPathMandatoryTagArray = xPathMandatoryTag.Split(Constants.CHRCOMMA);
                string[] xPathNotAllowedTagArray = xPathNotAllowedTag.Split(Constants.CHRCOMMA);

                int lengthxPathMandatoryTag = 0;
                lengthxPathMandatoryTag = xPathMandatoryTagArray.Length;

                int lengthxPathNotAllowedTag = 0;
                lengthxPathNotAllowedTag = xPathNotAllowedTagArray.Length;

                if (xDocument == null ||
                    xPathTag23A == null ||
                    xPathMandatoryTag == null ||
                    xPathNotAllowedTag == null ||
                    valueTag23A == null ||
                    xPathTag23A.Length == 0 ||
                    xPathMandatoryTag.Length == 0 ||
                    xPathNotAllowedTag.Length == 0 ||
                    valueTag23A.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList23A = xRoot.SelectNodes(xPathTag23A.ToString());

                if (xList23A.Count != 0)
                {
                    if (xList23A.Item(0).InnerText.CompareTo(valueTag23A) == 0)
                    {
                        for (int nCount = 0; nCount <= lengthxPathMandatoryTag - 1; nCount++)
                        {
                            XmlNodeList xListMandatoryTag = xRoot.SelectNodes(xPathMandatoryTagArray[nCount].ToString());
                            if (xListMandatoryTag.Count == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }

                        for (int nCount = 0; nCount <= lengthxPathNotAllowedTag - 1; nCount++)
                        {
                            XmlNodeList xListNotAllowedTag = xRoot.SelectNodes(xPathNotAllowedTagArray[nCount].ToString());
                            if (xListNotAllowedTag.Count != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }
                    }
                }
                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule242
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 242
        ///		In Sequence A, if subfield 1 of field 23A is COLLARBYER, then either field 37J of Sequence C and field 37L of Sequence F is Mandatory OR field 37L of Sequence C and field 37J of Sequence F is Mandatory
        ///		In Sequence A, if subfield 1 of field 23A is COLLARSLLR, then either field 37J of Sequence C and field 37L of Sequence F is Mandatory OR field 37L of Sequence C and field 37J of Sequence F is Mandatory
        ///
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag23A">
        ///		Input reference of the element 23A to be validated.
        /// </param>
        /// <param name="valueTag23A">
        ///		Input value of Tag 23A
        /// </param>
        /// <param name="xPathSeqCTag37J">
        ///		Input reference of the element 37J of Sequence C to be validated.
        /// </param>
        /// <param name="xPathSeqCTag37L">
        ///		Input reference of the element 37L of Sequence C to be validated.
        /// </param>
        /// <param name="xPathSeqFTag37J">
        ///		Input reference of the element 37J of Sequence F to be validated.
        /// </param>
        /// <param name="xPathSeqFTag37L">
        ///		Input reference of the element 37L of Sequence F to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule242(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag23A,
            string valueTag23A,
            string xPathSeqCTag37J,
            string xPathSeqCTag37L,
            string xPathSeqFTag37J,
            string xPathSeqFTag37L,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule242" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||

                    xPathTag23A == null ||
                    valueTag23A == null ||
                    xPathSeqCTag37J == null ||
                    xPathSeqCTag37L == null ||
                    xPathSeqFTag37J == null ||
                    xPathSeqFTag37L == null ||

                    xPathTag23A.Length == 0 ||
                    valueTag23A.Length == 0 ||
                    xPathSeqCTag37J.Length == 0 ||
                    xPathSeqCTag37L.Length == 0 ||
                    xPathSeqFTag37J.Length == 0 ||
                    xPathSeqFTag37L.Length == 0 ||

                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList23A = xRoot.SelectNodes(xPathTag23A.ToString());

                if (xList23A.Count != 0)
                {
                    if (valueTag23A.IndexOf(xList23A.Item(0).InnerText) != -1)
                    {
                        XmlNodeList xListSeqCTag37J = xRoot.SelectNodes(xPathSeqCTag37J.ToString());
                        XmlNodeList xListSeqCTag37L = xRoot.SelectNodes(xPathSeqCTag37L.ToString());
                        XmlNodeList xListSeqFTag37J = xRoot.SelectNodes(xPathSeqFTag37J.ToString());
                        XmlNodeList xListSeqFTag37L = xRoot.SelectNodes(xPathSeqFTag37L.ToString());

                        if (((xListSeqCTag37L.Count != 0) && (xListSeqFTag37J.Count != 0)) || ((xListSeqCTag37J.Count != 0) && (xListSeqFTag37L.Count != 0)))
                        {
                            isValid = true;
                        }
                        else
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule243
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 243
        ///		In Sequence A, if subfield 1 of field 23A is FIXEDFIXED or FLOATFIXED, then sequence B and E are mandatory and sequence C and F are Not Allowed
        ///		In Sequence A, if subfield 1 of field 23A is FLOATFLOAT or FIXEDFLOAT, then sequence C and F are mandatory and sequence B and E are Not Allowed
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag23A">
        ///		Input reference of the element 23A to be validated.
        /// </param>
        /// <param name="valueTag23A">
        ///		Input value of Tag 23A
        /// </param>
        /// <param name="xPathMandatoryTag">
        ///		Input reference of the Mandatory element (list separated by comma) to be validated.
        /// </param>
        /// <param name="xPathNotAllowedTag">
        ///		Input reference of the 'Not Allowed' element (list separated by comma) to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule243(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag23A,
            string valueTag23A,
            string xPathMandatoryTag,
            string xPathNotAllowedTag,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule243" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPathMandatoryTag) throw new ArgumentNullException("xPathMandatoryTag");
                if (null == xPathNotAllowedTag) throw new ArgumentNullException("xPathNotAllowedTag");

                bool isPresent = true;

                string[] xPathMandatorySeqArray = xPathMandatoryTag.Split(Constants.CHRCOMMA);
                string[] xPathNotAllowedSeqArray = xPathNotAllowedTag.Split(Constants.CHRCOMMA);

                int lengthxPathMandatorySeq = 0;
                lengthxPathMandatorySeq = xPathMandatorySeqArray.Length;

                int lengthxPathNotAllowedSeq = 0;
                lengthxPathNotAllowedSeq = xPathNotAllowedSeqArray.Length;

                if (xDocument == null ||
                    xPathTag23A == null ||
                    xPathMandatoryTag == null ||
                    xPathNotAllowedTag == null ||
                    valueTag23A == null ||
                    xPathTag23A.Length == 0 ||
                    xPathMandatoryTag.Length == 0 ||
                    xPathNotAllowedTag.Length == 0 ||
                    valueTag23A.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList23A = xRoot.SelectNodes(xPathTag23A.ToString());

                if (xList23A.Count != 0)
                {
                    if (xList23A.Item(0).InnerText.CompareTo(valueTag23A) == 0)
                    {
                        for (int nCount = 0; nCount <= lengthxPathMandatorySeq - 1; nCount++)
                        {
                            XmlNodeList xListMandatorySeq = xRoot.SelectNodes(xPathMandatorySeqArray[nCount].ToString());
                            if (xListMandatorySeq.Count == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }

                        for (int nCount = 0; nCount <= lengthxPathNotAllowedSeq - 1; nCount++)
                        {
                            XmlNodeList xListNotAllowedSeq = xRoot.SelectNodes(xPathNotAllowedSeqArray[nCount].ToString());
                            if (xListNotAllowedSeq.Count != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isPresent = false;
                            }
                        }
                    }
                }
                if (isPresent == false)
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		IsValidCommonReference
        /// </method>
        /// <summary>
        ///		Reference code must consist of the year (its last two characters) and month of the termination date in field 30P, in the format YYMM
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag22C">
        ///		Input reference of the element 22C to be validated.
        /// </param>
        /// <param name="xPathReferenceCode">
        ///		Input reference of the Reference Code element to be validated.
        /// </param>
        /// <param name="xPathTag30P">
        ///		Input reference of the element 30P to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidCommonReference(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag22C,
            string xPathReferenceCode,
            string xPathTag30P,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCommonReference" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            string code;
            try
            {
                if (xDocument == null ||
                    xPathTag22C == null ||
                    xPathReferenceCode == null ||
                    xPathTag30P == null ||
                    xPathTag22C.Length == 0 ||
                    xPathReferenceCode.Length == 0 ||
                    xPathTag30P.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList22C = xRoot.SelectNodes(xPathTag22C.ToString());

                if (xList22C.Count != 0)
                {
                    XmlNodeList xList30P = xRoot.SelectNodes(xPathTag30P.ToString());
                    string reqYYMM = xList30P.Item(0).InnerText.Substring(2, 4);

                    XmlNode xListReferenceCode = xList22C.Item(0).SelectSingleNode(xPathReferenceCode.ToString());
                    code = xListReferenceCode.InnerText.ToString();
                    if (code != reqYYMM)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xListReferenceCode.Name, code);
                        isValid = false;
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }


        /// <method>
        ///		CheckNumberOfRepetitions
        /// </method>
        /// <summary>
        ///		Number field of Tag 18A must equal the number of occurrences of the subsequent repeating field.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag18A">
        ///		Input reference of the element 18A to be validated.
        /// </param>
        /// <param name="xPathRepetitiveTag">
        ///		Input reference of the Repetitive element (followed by tag 18A) to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckNumberOfRepetitions(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag18A,
            string xPathRepetitiveTag,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckNumberOfRepetitions" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag18A == null ||
                    xPathRepetitiveTag == null ||
                    xPathTag18A.Length == 0 ||
                    xPathRepetitiveTag.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                int numberOfRepetitions = 0;
                int numberCode = 0;


                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList18A = xRoot.SelectNodes(xPathTag18A.ToString());

                if (xList18A.Count != 0)
                {
                    //Separate the comma separated list
                    string[] xPathRepetitiveTagList = xPathRepetitiveTag.Split(Constants.COMMA.ToCharArray());
                    foreach (string xPath in xPathRepetitiveTagList)
                    {
                        XmlNodeList xListRepetitiveTag = xRoot.SelectNodes(xPath);
                        if (xListRepetitiveTag.Count != 0)
                        {
                            foreach (XmlNode xNode in xListRepetitiveTag)
                            {
                                if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                                {
                                    numberOfRepetitions++;
                                }
                            }
                        }
                    }
                    numberCode = Convert.ToInt32(xList18A.Item(0).InnerText, CultureInfo.InvariantCulture);
                    if (numberCode != numberOfRepetitions)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, xList18A.Item(0).Name, numberCode.ToString(CultureInfo.InvariantCulture));
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		CompareDates
        /// </method>
        /// <summary>
        ///		Start Date should always be equal to or less than End Date.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathStartDate">
        ///		Input reference of Start Date Element to be validated
        /// </param>
        /// <param name="xPathEndDate">
        ///		Input reference of End Date Element to be validated
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CompareDates(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathStartDate,
            string xPathEndDate,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CompareDates" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                string strStartDate;
                string strEndDate;
                string Day;
                string Month;
                string Year;
                DateTime StartDate;
                DateTime EndDate;


                if (xDocument == null ||
                    xPathStartDate == null ||
                    xPathEndDate == null ||
                    xPathStartDate.Length == 0 ||
                    xPathEndDate.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListStartDate = xRoot.SelectNodes(xPathStartDate.ToString());
                XmlNodeList xListEndDate = xRoot.SelectNodes(xPathEndDate.ToString());

                if ((xListStartDate.Count != 0) && (xListEndDate.Count != 0))
                {
                    strStartDate = xListStartDate.Item(0).InnerText;
                    Year = strStartDate.Substring(0, 4);
                    Month = strStartDate.Substring(4, 2);
                    Day = strStartDate.Substring(6, 2);
                    strStartDate = Month + Constants.SLASH + Day + Constants.SLASH + Year;

                    strEndDate = xListEndDate.Item(0).InnerText;
                    Year = strEndDate.Substring(0, 4);
                    Month = strEndDate.Substring(4, 2);
                    Day = strEndDate.Substring(6, 2);
                    strEndDate = Month + Constants.SLASH + Day + Constants.SLASH + Year;

                    StartDate = Convert.ToDateTime(strStartDate, Constants.INVARIANTCULTURE);
                    EndDate = Convert.ToDateTime(strEndDate, Constants.INVARIANTCULTURE);

                    if (DateTime.Compare(StartDate, EndDate) > 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xListStartDate.Item(0).Name, StartDate.ToString(CultureInfo.InvariantCulture));
                        isValid = false;
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule49
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 49.If 71B is Present, Amounts in 32a and 33D
        ///		must be different.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath71B" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath33D" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath32a" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule49(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath71B,
            string xPath33D,
            string xPath32a,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule49" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int lastChildFlag = 0;
            int lengthxPath32a = 0;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath71B == null ||
                    xPath71B.Length == 0 ||
                    xPath33D == null ||
                    xPath33D.Length == 0 ||
                    xPath32a == null ||
                    xPath32a.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                string[] xPath32aArray = xPath32a.Split(Constants.CHRCOMMA);
                lengthxPath32a = xPath32aArray.Length;

                XmlNode xRoot = xDocument.Document;
                XmlNode xNode = xRoot.SelectSingleNode(xPathSequence);

                if (xNode != null)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        if (xRoot.LastChild != null && xRoot.LastChild.LastChild != null)
                        {
                            string amount32a = null;
                            string amount33D = null;
                            bool bln71BPresent = false;

                            while (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0
                                || xNode.NextSibling != null)
                            {
                                if (xRoot.SelectSingleNode(xPathSequence) != null)
                                {
                                    amount32a = null;
                                    amount33D = null;
                                    bln71BPresent = false;

                                    while (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPathSequence).Name) != 0
                                        && lastChildFlag <= 1)
                                    {
                                        if (xRoot.SelectSingleNode(xPath71B) != null)
                                        {
                                            if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath71B).Name) == 0)
                                            {
                                                bln71BPresent = true;
                                            }
                                        }
                                        for (int count = 0; count <= lengthxPath32a - 1; count++)
                                        {
                                            if (xRoot.SelectSingleNode(xPath32aArray[count]) != null)
                                            {
                                                if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath32aArray[count]).Name) == 0)
                                                {
                                                    if (xNode.InnerText != null)
                                                    {
                                                        amount32a = xNode.LastChild.InnerText;
                                                    }
                                                }
                                            }
                                        }

                                        if (xRoot.SelectSingleNode(xPath33D) != null)
                                        {
                                            if (xNode.Name.CompareTo(xRoot.SelectSingleNode(xPath33D).Name) == 0)
                                            {
                                                if (xNode.InnerText != null)
                                                {
                                                    amount33D = xNode.LastChild.InnerText;
                                                }
                                            }
                                        }

                                        if (bln71BPresent == true && amount32a == amount33D)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                                conditionalRuleName, conditionalRuleNumber);
                                            isValid = false;

                                            amount32a = null;
                                            amount33D = null;
                                            bln71BPresent = false;

                                        }

                                        if ((xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0
                                            && xNode.NextSibling != null
                                            || (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0)))
                                        {
                                            xNode = xNode.NextSibling;
                                        }

                                        if (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0
                                            && xNode.NextSibling == null)
                                        {
                                            lastChildFlag++;
                                        }

                                    }
                                }
                                if ((xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) == 0
                                    && xNode.NextSibling != null) ||
                                    (xNode.Name.CompareTo(xRoot.LastChild.LastChild.Name) != 0))
                                {
                                    xNode = xNode.NextSibling;
                                }
                            }
                        }

                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule266
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 266 specific to message MT537.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath17B" type = "string">
        ///		Input reference of the element 17B in Sequence A
        /// </param>
        /// <param name ="xPath22H" type = "string">
        ///		Input reference of the element 22H in Sequence A.
        /// </param>
        /// <param name ="xPathSequenceB" type = "string">
        ///		Input reference of the Sequence B.
        /// </param>
        /// <param name ="xPathSequenceC" type = "string">
        ///		Input reference of the Sequence C.
        /// </param>
        /// <param name ="indicatorValue1" type = "string">
        ///		Input containing the value(STAT) of the Indicator of element 22H in Sequence A.
        /// </param>
        /// <param name ="indicatorValue2" type = "string">
        ///		Input containing the value(TRAN) of the Indicator of element 22H in Sequence A.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule266(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath17B,
            string xPath22H,
            string xPathSequenceB,
            string xPathSequenceC,
            string indicatorValue1,
            string indicatorValue2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule266" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPathSequenceC == null ||
                    xPathSequenceC.Length == 0 ||
                    xPath17B == null ||
                    xPath17B.Length == 0 ||
                    xPath22H == null ||
                    xPath22H.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                //Select the node of Tag 17B in Sequence A
                XmlNode xNode17B = xRoot.SelectSingleNode(xPath17B);

                //Select the node of Tag 22H in Sequence A
                XmlNode xNode22H = xRoot.SelectSingleNode(xPath22H);

                //Select all the nodes of Sequence B
                XmlNodeList xListSequenceB = xRoot.SelectNodes(xPathSequenceB);

                //Select all the nodes of Sequence C
                XmlNodeList xListSequenceC = xRoot.SelectNodes(xPathSequenceC);

                //Check if the Tag 17B exists
                if (xNode17B != null)
                {
                    if (xNode17B.LastChild != null)
                    {
                        //Check if the value of the Flag is 'N'
                        if (xNode17B.LastChild.InnerText.CompareTo(Constants.ALPHAN) == 0)
                        {
                            //If either Sequence B or Sequence C exists, throw an error
                            if (xListSequenceB.Count != 0 || xListSequenceC.Count != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                        //Check if the value of the Flag is 'Y'
                        else if (xNode17B.LastChild.InnerText.CompareTo(Constants.ALPHAY) == 0)
                        {
                            //Check if the Tag 22H exists
                            if (xNode22H != null)
                            {
                                if (xNode22H.LastChild != null)
                                {
                                    //Check if the Indicator value is 'STAT'
                                    if (xNode22H.LastChild.InnerText.CompareTo(indicatorValue1) == 0)
                                    {
                                        //If Sequence B does not exist or Sequence C exists, throw an error
                                        if (xListSequenceB.Count == 0 || xListSequenceC.Count != 0)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isValid = false;
                                        }
                                    }
                                    //Check if the Indicator value is 'TRAN'
                                    else if (xNode22H.LastChild.InnerText.CompareTo(indicatorValue2) == 0)
                                    {
                                        //If Sequence B exists or Sequence C does not exist, throw an error
                                        if (xListSequenceB.Count != 0 || xListSequenceC.Count == 0)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isValid = false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule285
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 285
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B2b (or) C2.
        /// </param>
        /// <param name ="xPathSubSequence" type = "string">
        ///		Input reference of the Sequence B2b1 (or) C2a.
        /// </param>
        /// <param name ="xPath95a" type = "string">
        ///		Comma separated input references of the elements to be validated for tag 95a in
        ///		Sequence B2b1 (or) C2a.
        /// </param>
        /// <param name ="xPath22H" type = "string">
        ///		Input reference of the Element 22H in Sequence B2b (or) C2.
        /// </param>
        /// <param name ="qualifierValue22H" type = "string">
        ///		Reference containing the value of the Qualifier of Tag 22H.
        /// </param>
        /// <param name ="qualifierValue95a" type = "string">
        ///		Reference containing the value of the Qualifier of Tag 95a.
        /// </param>
        /// <param name ="indicatorValue22H" type = "string">
        ///		Reference containing the value of the Indicator of Tag 22H.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule285(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPath95a,
            string xPath22H,
            string qualifierValue22H,
            string qualifierValue95a,
            string indicatorValue22H,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule285" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int lengthxPath = 0;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSubSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence.Length == 0 ||
                    xPath95a == null ||
                    xPath22H == null ||
                    xPath95a.Length == 0 ||
                    xPath22H.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                //Declare an array to store the xPaths of Tag 95a
                string[] xPathArray = xPath95a.Split(Constants.CHRCOMMA);
                lengthxPath = xPathArray.Length;

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Sequence B2b (or) C2
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    //Select all the nodes of Tag 22H in Sequence B2b (or) C2
                    XmlNodeList xList22H = xNodeSequence.SelectNodes(xPath22H);

                    foreach (XmlNode xNode22H in xList22H)
                    {
                        if (xNode22H.FirstChild != null && xNode22H.LastChild != null)
                        {
                            //Check the value of the Qualifier and Indicator of Tag 22H
                            if (xNode22H.FirstChild.InnerText.CompareTo(qualifierValue22H) == 0 &&
                                xNode22H.LastChild.InnerText.CompareTo(indicatorValue22H) == 0)
                            {
                                //Select all the nodes of Sequence B2b1 (or) C2a
                                XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);

                                //Check if Sequence B2b1 (or) C2a exists
                                if (xListSubSequence.Count != 0)
                                {
                                    int count = 0;

                                    foreach (XmlNode xNodeSubSequence in xListSubSequence)
                                    {
                                        //Check for each option of Tag 95a
                                        for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                                        {
                                            XmlNodeList xList95a = xNodeSubSequence.SelectNodes(xPathArray[nCount].ToString());

                                            foreach (XmlNode xNode95a in xList95a)
                                            {
                                                if (xNode95a.FirstChild != null)
                                                {
                                                    //Check if the Qualifier value of Tag 95a is equal to desired value
                                                    if (xNode95a.FirstChild.InnerText.CompareTo(qualifierValue95a) == 0)
                                                    {
                                                        count++;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    //If there is no Tag 95a with desired Qualifier value, throw an error
                                    if (count == 0)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule237
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 237
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B (or) C3.
        /// </param>
        /// <param name ="xPathSubSequence" type = "string">
        ///		Input reference of the Sequence B1 (or) C3a.
        /// </param>
        /// <param name ="xPath25D" type = "string">
        ///		Input reference of the element 25D in Sequence B (or) C3.
        /// </param>
        /// <param name ="xPath24B" type = "string">
        ///		Input reference of the element 24B in Sequence B1 (or) C3a.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Reference containing the xPath of the Qualifier.
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Reference containing the xPath of the Data Source Scheme.
        /// </param>
        /// <param name ="xPathStatusCode" type = "string">
        ///		Reference containing the xPath of the Status Code.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule237(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPath25D,
            string xPath24B,
            string xPathQualifier,
            string xPathDataSourceScheme,
            string xPathStatusCode,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule237" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);

            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSubSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence.Length == 0 ||
                    xPath25D == null ||
                    xPath25D.Length == 0 ||
                    xPath24B == null ||
                    xPath24B.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathStatusCode == null ||
                    xPathStatusCode.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Sequence B (or) C3
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    //Select the node of the Tag 25D in Sequence B (or) C3
                    XmlNode xNode25D = xNodeSequence.SelectSingleNode(xPath25D);

                    if (xNode25D != null)
                    {
                        //Check for the presence of Data Source Scheme in Tag 25D
                        if (xNode25D.SelectSingleNode(xPathDataSourceScheme) == null)
                        {
                            //Select all the nodes of Sequence B1 (or) C3a
                            XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);

                            foreach (XmlNode xNodeSubSequence in xListSubSequence)
                            {
                                //Select the node of the Tag 24B in Sequence B1 (or) C3a
                                XmlNode xNode24B = xNodeSubSequence.SelectSingleNode(xPath24B);

                                if (xNode24B != null && xNode24B.SelectSingleNode(xPathQualifier) != null && xNode25D.SelectSingleNode(xPathStatusCode) != null)
                                {
                                    //Get the value of the Qualifier of Tag 24B
                                    string xNode24BQualifier = xNode24B.SelectSingleNode(xPathQualifier).InnerText.ToString(CultureInfo.InvariantCulture);
                                    //Get the value of the Status Code of Tag 25D
                                    string xNode25DStatusCode = xNode25D.SelectSingleNode(xPathStatusCode).InnerText.ToString(CultureInfo.InvariantCulture);

                                    //If the value of Qualifier of Tag 24B is not equal to value of Status Code of Tag 25D, throw an error
                                    if (xNode24BQualifier.CompareTo(xNode25DStatusCode) != 0)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        ///<method>
        /// IsValidIdentificationOfTheMetal
        ///</method>
        /// <summary>
        ///		Function Validates Tag 26C ChildFields.
        ///		Validation for the fields Allocation,type and Denomination is done against the Codelists
        ///		which are passed as parameters in Function Signature.
        /// </summary>
        /// <param name="xDocument">
        ///		Reference path to the document
        ///	</param>
        /// <param name="xPath">
        ///		xpath of identification of metal to be passed as //IdentificationOfTheMetal
        ///	</param>
        /// <param name="isCIFPresent">
        ///		boolean Value which decides presence of deliveryDetails
        ///	</param>
        /// <param name="codelistCIF">
        ///		Contains value CIF
        /// </param>
        /// <param name="codelistAllocation">
        ///		Contains Enumerated Values for Field Allocation</param>
        /// <param name="codelistTypeCoin">
        ///		Contains Enumerated
        /// </param>
        /// <param name="policyName">
        ///		Name of the policy
        /// </param>
        /// <param name="ruleName">
        ///		name of the rule
        /// </param>
        /// <param name="messageType">
        ///		Message Number
        /// </param>
        /// <param name="sequenceName">
        ///		Sequence Name
        /// </param>
        /// <param name="errorObject">
        ///		ErrorCollection Object
        /// </param>
        /// <returns></returns>

        public static bool IsValidIdentificationOfTheMetal(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            bool isCIFPresent,
            string codelistCIF,
            string codelistAllocation,
            string codelistTypeCoin,
            string policyName,
            string ruleName,
            string messageType,
            string sequenceName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidIdentificationOfTheMetal" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    codelistCIF == null ||
                    codelistAllocation == null ||
                    codelistTypeCoin == null ||
                    policyName == null ||
                    messageType == null ||
                    sequenceName == null ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);


                string deliveryDetails = string.Empty;
                //Added for SRG2010
                string[] codelistDeliveryDetails;
                bool isValidDeliveryDetail = false;

                string type = string.Empty;
                string denomination = string.Empty;
                string denominationPlusForm = string.Empty;
                string denominationList = string.Empty;
                string[] codelistAllocationArray;

                int indexCoin = 0;
                int denominationValid = 0;
                int startPositionOfField3 = 0;
                int startPositionOfField4 = 0;
                int startPositionOfField5 = 0;
                int startPositionOfField6 = 0;



                ArrayList startPositionOfField3ArrList = new ArrayList();
                //Added SRG 2010
                codelistDeliveryDetails = codelistCIF.Split(Constants.CHRCOMMA);
                foreach (XmlNode xNode in xList)
                {
                    deliveryDetails = xNode.InnerText.Substring(0, xNode.InnerText.IndexOf(Constants.SLASH));
                    //Added for SRG 2010
                    if (deliveryDetails.Length > 0)
                    {
                        for (int i = 0; i < codelistDeliveryDetails.Length; i++)
                        {
                            if (codelistDeliveryDetails[i] == deliveryDetails)
                            {
                                isValidDeliveryDetail = true;
                                break;
                            }
                        }
                    }
                    else
                    {
                        isValidDeliveryDetail = true;
                    }

                    if (!isValidDeliveryDetail)
                    {
                        errorObject.AddError(Constants.ERRORT35, policyName, ruleName, messageType, sequenceName, xNode.Name, deliveryDetails);
                        isValid = false;
                    }

                    codelistAllocationArray = codelistAllocation.Split(Constants.CHRCOMMA);

                    for (int i = 0; i < codelistAllocationArray.Length; i++)
                    {
                        do
                        {
                            startPositionOfField3ArrList.Add(xNode.InnerText.IndexOf(codelistAllocationArray[i]));
                            if (Convert.ToInt32(startPositionOfField3ArrList[i], CultureInfo.InvariantCulture) != -1)
                                break;

                        } while (Convert.ToInt32(startPositionOfField3ArrList[i], CultureInfo.InvariantCulture) <= 20 && Convert.ToInt32(startPositionOfField3ArrList[i], CultureInfo.InvariantCulture) != -1);

                    }

                    for (int i = 0; i < startPositionOfField3ArrList.Count - 1; i++)
                    {
                        if (Convert.ToInt32(startPositionOfField3ArrList[i], CultureInfo.InvariantCulture) < Convert.ToInt32(startPositionOfField3ArrList[i + 1], CultureInfo.InvariantCulture))
                        {
                            startPositionOfField3ArrList[i] = startPositionOfField3ArrList[i + 1];
                        }

                    }

                    //The first Position contains the farthest but less than 20th position of field3
                    startPositionOfField3 = Convert.ToInt32(startPositionOfField3ArrList[0], CultureInfo.InvariantCulture);

                    startPositionOfField3ArrList.Clear();

                    startPositionOfField4 = startPositionOfField3 + 5;

                    type = xNode.InnerText.Substring(startPositionOfField4, 4);

                    indexCoin = codelistTypeCoin.IndexOf(type);

                    if (indexCoin != -1)
                    {
                        //Getting the value of denomination from the data
                        startPositionOfField5 = startPositionOfField4 + 4;

                        denominationPlusForm = xNode.InnerText.Substring(startPositionOfField5);

                        startPositionOfField6 = denominationPlusForm.IndexOf(Constants.DOUBLESLASH);

                        if (startPositionOfField6 == -1)
                        {
                            denomination = denominationPlusForm.Substring(0);
                        }
                        else
                        {
                            denomination = denominationPlusForm.Substring(0, startPositionOfField6);
                        }

                        //Getting the denomination for a particular type from Codelist
                        int nextCoin = codelistTypeCoin.IndexOfAny(Constants.ALPHASET.ToCharArray(), indexCoin + 4);

                        if (nextCoin != -1)
                        {
                            denominationList = codelistTypeCoin.Substring(indexCoin + 4, nextCoin - indexCoin - 4);
                        }
                        else
                        {
                            denominationList = codelistTypeCoin.Substring(indexCoin + 4);

                        }

                        denomination = Constants.COMMA + denomination + Constants.COMMA;

                        denominationValid = denominationList.IndexOf(denomination);

                        if (denominationValid == -1)
                        {
                            errorObject.AddError(Constants.ERRORT04, policyName, ruleName, messageType, sequenceName, xNode.Name, denomination);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		IsMandatoryTagExists
        /// </method>
        /// <summary>
        /// This Function will check for the presence of a tag that may be optional say in the schema
        /// but if the conditional tag have a specific value then the optional tag will have to be there
        /// in the message, i.e., will be mandatory in that scenario, for a given sequence say Sequence A
        ///	For e.g.,
        ///	In the Sequence A the presence of Field 21 depends upon field 22A,
        ///	i.e., If Field 22A has the value either AMND or CANC then Field 21 is mandatory.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathConditionalTag">
        ///		Input reference of the Tag.
        ///	</param>
        /// <param name="valueListConditionalTag">
        ///		Constant value.
        /// </param>
        /// <param name="xPathMandatoryTag">
        ///		Input reference of the Tag.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsMandatoryTagExists(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathConditionalTag,
            string valueListConditionalTag,
            string xPathMandatoryTag,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsMandatoryTagExists" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathConditionalTag == null ||
                    valueListConditionalTag == null ||
                    xPathMandatoryTag == null ||
                    xPathConditionalTag.Length == 0 ||
                    valueListConditionalTag.Length == 0 ||
                    xPathMandatoryTag.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList22A = xRoot.SelectNodes(xPathConditionalTag.ToString());

                string[] szValues = valueListConditionalTag.Split(Constants.CHRCOMMA);

                foreach (XmlNode xNode in xList22A)
                {
                    if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        for (int i = 0; i < szValues.Length; i++)
                        {
                            if (szValues[i].IndexOf(xNode.InnerText.ToString()) != -1)
                            {
                                XmlNodeList xListMandatoryTag = xRoot.SelectNodes(xPathMandatoryTag.ToString());
                                if (xListMandatoryTag.Count == 0)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                    break;
                                }
                                else if (xListMandatoryTag.Count != 0)
                                {
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule260
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 260. In each occurrence of subsequence D1
        ///		if field :94B::RATS is Present,then field :70C::RATS is Mandatory.
        ///		If :94B::RATS is not Present field :70C::RATS is not Alllowed.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath94B" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath70C" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the qualifier value.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message Type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule260(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath94B,
            string xPath70C,
            string qualifierValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule260" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath94B == null ||
                    xPath94B.Length == 0 ||
                    xPath70C == null ||
                    xPath70C.Length == 0 ||
                    qualifierValue == null ||
                    qualifierValue.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    bool bln1 = false;
                    bool bln2 = false;

                    if (xNodeSequence.SelectSingleNode(xPath94B) != null)
                    {
                        XmlNodeList xNodeField1 = xNodeSequence.SelectNodes(xPath94B);
                        foreach (XmlNode xNode in xNodeField1)
                        {
                            if (xNode.FirstChild != null)
                            {
                                if (xNode.FirstChild.InnerText.CompareTo(qualifierValue) == 0)
                                {
                                    bln1 = true;
                                }

                            }
                        }
                    }
                    if (xNodeSequence.SelectSingleNode(xPath70C) != null)
                    {
                        XmlNode xNodeField2 = xNodeSequence.SelectSingleNode(xPath70C);
                        if (xNodeField2.FirstChild != null)
                        {
                            if (xNodeField2.FirstChild.InnerText.CompareTo(qualifierValue) == 0)
                            {
                                bln2 = true;
                            }

                        }

                    }

                    if (bln1 == true && bln2 == false || bln1 == false && bln2 == true)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule271
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 271. In each occurrence of subsequence A1 if field :22F::AGRE is not present
        /// 	then fild :70C::AGRE is Mandatory.If :22F::AGRE is Present field :70C::AGRE is Optional.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath70C" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the qualifier value.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message Type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule271(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath22F,
            string xPath70C,
            string qualifierValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule271" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath22F == null ||
                    xPath22F.Length == 0 ||
                    xPath70C == null ||
                    xPath70C.Length == 0 ||
                    qualifierValue == null ||
                    qualifierValue.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    bool bln1 = false;
                    bool bln2 = false;

                    if (xNodeSequence.SelectSingleNode(xPath22F) != null)
                    {
                        XmlNode xNodeField1 = xNodeSequence.SelectSingleNode(xPath22F);

                        if (xNodeField1.FirstChild != null)
                        {
                            if (xNodeField1.FirstChild.InnerText.CompareTo(qualifierValue) == 0)
                            {
                                bln1 = true;
                            }
                        }
                    }
                    if (xNodeSequence.SelectSingleNode(xPath70C) != null)
                    {
                        XmlNode xNodeField2 = xNodeSequence.SelectSingleNode(xPath70C);
                        if (xNodeField2.FirstChild != null)
                        {
                            if (xNodeField2.FirstChild.InnerText.CompareTo(qualifierValue) == 0)
                            {
                                bln2 = true;
                            }

                        }

                    }

                    if (bln1 == false && bln2 == false)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRuleT47
        /// </method>
        /// <summary>
        ///		This method performs validation for the SWIFT Network Rule T47
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element 72.
        /// </param>
        /// <param name ="elementName" type = "string">
        ///		Input containing the name of the child element.
        /// </param>
        /// <param name ="code" type = "string">
        ///		Input containing the value of the Code to be verified.
        /// </param>
        /// <param name ="nCountRep" type = "string">
        ///		Input containing the number of child elements to be checked.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message Type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRuleT47(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string elementName,
            string code,
            int nCountRep,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRuleT47" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int count = 0;
            try
            {
                if (xDocument == null ||
                    elementName == null ||
                    elementName.Length == 0 ||
                    code == null ||
                    code.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                //Select all the nodes of Tag 72
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                //Creating the value of the Code
                string codeValue = Constants.SLASH + code + Constants.SLASH;

                foreach (XmlNode xNode in xList)
                {
                    //For all possible child elements under the Tag 72
                    for (int i = 1; i <= nCountRep; i++)
                    {
                        //Creating the required xPath for child element
                        string xPathElement = elementName + i;

                        //Select the child element
                        XmlNode xNodeElement = xNode.SelectSingleNode(xPathElement);

                        //If there is no such child element under the Tag, exit
                        if (xNodeElement == null)
                        {
                            break;
                        }
                        else
                        {
                            //Check if the line starts with the code
                            if (xNodeElement.InnerText.StartsWith(codeValue))
                                count++;
                        }
                        //If the Code is present at the specified location in more than 1 child element, throw an error
                        if (count > 1)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                            break;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRuleT81
        /// </method>
        /// <summary>
        ///		This method performs validation for the SWIFT Network Rule T81.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element 72.
        /// </param>
        /// <param name ="elementName" type = "string">
        ///		Input containing the name of the child element.
        /// </param>
        /// <param name ="code1" type = "string">
        ///		Input containing the value of the Code to be verified.
        /// </param>
        /// <param name ="code2" type = "string">
        ///		Input containing the value of the Code to be verified.
        /// </param>
        /// <param name ="nCountRep" type = "string">
        ///		Input containing the number of child elements to be checked.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message Type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRuleT81(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string elementName,
            string code1,
            string code2,
            int nCountRep,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRuleT81" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    elementName == null ||
                    elementName.Length == 0 ||
                    code1 == null ||
                    code1.Length == 0 ||
                    code2 == null ||
                    code2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                //Select all the nodes of Tag 72
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                //Creating the values of the Code
                string codeValue1 = Constants.SLASH + code1 + Constants.SLASH;
                string codeValue2 = Constants.SLASH + code2 + Constants.SLASH;

                foreach (XmlNode xNode in xList)
                {
                    //For all possible child elements under the Tag 72
                    for (int i = 1; i <= nCountRep; i++)
                    {
                        //Creating the required xPath for child element
                        string xPathElement = elementName + i;

                        //Select the child element
                        XmlNode xNodeElement = xNode.SelectSingleNode(xPathElement);

                        //If there is no such child element under the Tag, exit
                        if (xNodeElement == null)
                        {
                            break;
                        }
                        else
                        {
                            //If the value of the Code is equal to any of the codeValues, throw an error
                            if (xNodeElement.InnerText.StartsWith(codeValue1) ||
                                xNodeElement.InnerText.StartsWith(codeValue2))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                                break;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule4
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 4. In sequence B if field :19B::TEXA is Present
        /// 	then field :19B::TCRL is Optional.If :19B::TEXA is not Present field :19B::TCRL is not Mandatory.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath19B" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="qualifier1" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="qualifier2" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message Type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule4(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath19B,
            string qualifier1,
            string qualifier2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule4" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool bln1 = false;
            try
            {
                if (xDocument == null ||
                    xPath19B == null ||
                    xPath19B.Length == 0 ||
                    qualifier1 == null ||
                    qualifier1.Length == 0 ||
                    qualifier2 == null ||
                    qualifier2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListTag = xRoot.SelectNodes(xPath19B);

                foreach (XmlNode xNodeTag in xListTag)
                {
                    if (xNodeTag.InnerText != null && xNodeTag.InnerText.Length != 0)
                    {
                        if (xNodeTag.FirstChild != null)
                        {
                            if (xNodeTag.FirstChild.InnerText.CompareTo(qualifier1) == 0 || xNodeTag.FirstChild.InnerText.CompareTo(qualifier2) == 0)
                            {
                                bln1 = true;
                            }
                        }
                    }
                }

                if (bln1 == false)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		IsValidNumberOfSettlements
        /// </method>
        /// <summary>
        ///		This method performs validation for the number of settlements which must equal the number
        ///		of repetitions within Sequence D.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathMandatoryRepeatedTag" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message Type.
        /// </param>
        /// <param name ="sequenceName" type = "string">
        ///		Input containing the name of the Sequence.
        /// </param>
        /// <param name ="elementName" type = "string">
        ///		Input containing the name of the element.
        /// </param>
        /// <param name ="elementValue" type = "string">
        ///		Input containing the value of the element.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidNumberOfSettlements(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathMandatoryRepeatedTag,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string sequenceName,
            string elementName,
            string elementValue,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidNumberOfSettlements" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathMandatoryRepeatedTag == null ||
                    xPathMandatoryRepeatedTag.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    sequenceName == null ||
                    sequenceName.Length == 0 ||
                    elementName == null ||
                    elementName.Length == 0 ||
                    elementValue == null ||
                    elementValue.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                XmlNode xNode = xRoot.SelectSingleNode(xPathTag);

                XmlNodeList xNodeListMandatoryRepeatedTag = xRoot.SelectNodes(xPathMandatoryRepeatedTag);

                if (!ContainsAllNumber(xNode.InnerText))
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, sequenceName, elementName, elementValue);
                    isValid = false;
                    return isValid;
                }

                if (Convert.ToInt32(xNode.InnerText, CultureInfo.InvariantCulture) != xNodeListMandatoryRepeatedTag.Count)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, sequenceName, elementName, elementValue);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule53
        /// </method>
        /// <summary>
        ///		When sequence B is present and fields 33a and 71C are present,
        ///		field 34a must also be present in that sequence.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B whose occurence is to be checked
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of 33a whose occurence is to be checked
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of 71C whose occurence is to be checked
        /// </param>
        /// <param name ="xPath3" type = "string">
        ///		Input reference of 34a whose occurence is to be checked
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message Type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule53(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath1,
            string xPath2,
            string xPath3,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule53" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    xPath3 == null ||
                    xPath3.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                bool isPresent = false;

                //Select all the nodes of Sequence B
                XmlNodeList xList = xRoot.SelectNodes(xPathSequence);

                string[] xPathArray1 = xPath1.Split(Constants.CHRCOMMA);
                string[] xPathArray2 = xPath3.Split(Constants.CHRCOMMA);

                foreach (XmlNode xNode in xList)
                {
                    for (int i = 0; i <= xPathArray1.Length - 1; i++)
                    {
                        if ((xNode.SelectSingleNode(xPathArray1[i]) != null) && (xNode.SelectSingleNode(xPath2) != null))
                        {
                            for (int j = 0; j <= xPathArray2.Length - 1; j++)
                            {
                                if (xNode.SelectSingleNode(xPathArray2[j]) != null)
                                {
                                    isPresent = true;
                                }
                            }
                            if (isPresent == false)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                                break;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule60
        /// </method>
        /// <summary>
        ///		In each sequence B, the currency in fields 32P, 33a and 34a must be the same.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B whose occurence is to be checked
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of 32P whose occurence is to be checked
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of 33a whose occurence is to be checked
        /// </param>
        /// <param name ="xPath3" type = "string">
        ///		Input reference of 34a whose occurence is to be checked
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message Type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule60(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath1,
            string xPath2,
            string xPath3,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule60" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    xPath3 == null ||
                    xPath3.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Sequence B
                XmlNodeList xList = xRoot.SelectNodes(xPathSequence);

                string[] xPathArray1 = xPath2.Split(Constants.CHRCOMMA);
                string[] xPathArray2 = xPath3.Split(Constants.CHRCOMMA);

                foreach (XmlNode xNode in xList)
                {
                    string currencyCode1 = string.Empty;
                    string currencyCode2 = string.Empty;
                    string currencyCode3 = string.Empty;
                    string currencyCode = string.Empty;

                    if (xNode.SelectSingleNode(xPath1) != null)
                    {
                        if (xNode.SelectSingleNode(xPath1).InnerText != null)
                        {
                            currencyCode1 = xNode.SelectSingleNode(xPath1).InnerText.Substring(6, 3);
                        }
                    }

                    for (int i = 0; i < xPathArray1.Length; i++)
                    {
                        if (xNode.SelectSingleNode(xPathArray1[i]) != null)
                        {
                            if (xNode.SelectSingleNode(xPathArray1[i]).InnerText != null)
                            {
                                currencyCode2 = xNode.SelectSingleNode(xPathArray1[i]).InnerText.Substring(6, 3);
                            }
                        }
                    }
                    for (int i = 0; i < xPathArray2.Length; i++)
                    {
                        if (xNode.SelectSingleNode(xPathArray2[i]) != null)
                        {
                            if (xNode.SelectSingleNode(xPathArray2[i]).InnerText != null)
                            {
                                currencyCode3 = xNode.SelectSingleNode(xPathArray2[i]).InnerText.Substring(6, 3);
                            }
                        }
                    }


                    if (currencyCode1.CompareTo(Constants.BLANK) != 0)
                    {
                        currencyCode = currencyCode1;
                        if (currencyCode2.CompareTo(Constants.BLANK) != 0)
                        {
                            if (currencyCode2.CompareTo(currencyCode) != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                        if (currencyCode3.CompareTo(Constants.BLANK) != 0)
                        {
                            if (currencyCode3.CompareTo(currencyCode) != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                    }
                    else
                    {
                        if (currencyCode2.CompareTo(Constants.BLANK) != 0)
                        {
                            currencyCode = currencyCode2;
                            if (currencyCode3.CompareTo(Constants.BLANK) != 0)
                            {
                                if (currencyCode3.CompareTo(currencyCode) != 0)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule61
        /// </method>
        /// <summary>
        ///		In each sequence C, the currency in fields 32B and 33B must be the same.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B whose occurence is to be checked
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of 32B whose occurence is to be checked
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of 33B whose occurence is to be checked
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message Type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule61(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath1,
            string xPath2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule61" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    xPath2 == null ||
                    xPath2.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Sequence B
                XmlNodeList xList = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNode in xList)
                {

                    string currencyCode1 = string.Empty;
                    string currencyCode2 = string.Empty;
                    string currencyCode = string.Empty;

                    if (xNode.SelectSingleNode(xPath1) != null)
                    {
                        if (xNode.SelectSingleNode(xPath1).InnerText != null)
                        {
                            currencyCode1 = xNode.SelectSingleNode(xPath1).InnerText.Substring(0, 3);
                        }
                    }

                    if (xNode.SelectSingleNode(xPath2) != null)
                    {
                        if (xNode.SelectSingleNode(xPath2).InnerText != null)
                        {
                            currencyCode2 = xNode.SelectSingleNode(xPath2).InnerText.Substring(0, 3);
                        }
                    }


                    if (currencyCode1.CompareTo(Constants.BLANK) != 0)
                    {
                        currencyCode = currencyCode1;
                        if (currencyCode2.CompareTo(Constants.BLANK) != 0)
                        {
                            if (currencyCode2.CompareTo(currencyCode) != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule66
        /// </method>
        /// <summary>
        ///		Each sequence B must be accompanied by a sequence C (sequence C may be present without sequence B).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence1" type = "string">
        ///		Input reference of the Sequence B whose occurence is to be checked
        /// </param>
        /// <param name ="xPathSequence2" type = "string">
        ///		Input reference of the Sequence C whose occurence is to be checked
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message Type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>

        public static bool SWIFTNetworkRule66(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence1,
            string xPathSequence2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule66" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence1 == null ||
                    xPathSequence1.Length == 0 ||
                    xPathSequence2 == null ||
                    xPathSequence2.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Sequence B
                XmlNodeList xList1 = xRoot.SelectNodes(xPathSequence1);

                //Select all the nodes of Sequence C
                XmlNodeList xList2 = xRoot.SelectNodes(xPathSequence2);

                if (xList1.Count > xList2.Count)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		IsValidReasonCode
        /// </method>
        /// <summary>
        ///		The qualifier of field 24B shoudl be the same as the Status Code of field 25D.
        ///		This usage rule is applicable only when the 25D does not have DataSourceScheme as part
        ///		of its data.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the element to be Validated.
        /// </param>
        /// <param name ="xPathSubSequence" type = "string">
        ///		Input reference of the element to be Validated.
        /// </param>
        /// <param name ="xPath25D" type = "string">
        ///		Input reference of the element 25D.
        /// </param>
        /// <param name ="xPath24B" type = "string">
        ///		Input reference of the element 24B.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Reference containing the xPath of the Qualifier.
        /// </param>
        /// <param name ="xPathStatusCode" type = "string">
        ///		Reference containing the xPath of the Status Code.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidReasonCode(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPath25D,
            string xPath24B,
            string xPathQualifier,
            string xPathStatusCode,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidReasonCode" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSubSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence.Length == 0 ||
                    xPath25D == null ||
                    xPath25D.Length == 0 ||
                    xPath24B == null ||
                    xPath24B.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathStatusCode == null ||
                    xPathStatusCode.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    XmlNode xNode25D = xNodeSequence.SelectSingleNode(xPath25D);

                    if (xNode25D != null)
                    {
                        // This validation only holds when Field 25D does not have DataSorceScheme.
                        // If DataSourceScheme is present then the StatusCode can be of any value and hence
                        // cannot match the Qualifier of field 24B - hence we exit.
                        XmlNode xDataSourceSchemeNode = xNode25D.SelectSingleNode("./DataSource/DataSourceScheme");
                        if (null == xDataSourceSchemeNode || xDataSourceSchemeNode.InnerText.Length == 0)
                        {
                            XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);

                            foreach (XmlNode xNodeSubSequence in xListSubSequence)
                            {
                                XmlNode xNode24B = xNodeSubSequence.SelectSingleNode(xPath24B);

                                if (xNode24B != null && xNode24B.SelectSingleNode(xPathQualifier) != null && xNode25D.SelectSingleNode(xPathStatusCode) != null)
                                {
                                    string xNode24BQualifier = xNode24B.SelectSingleNode(xPathQualifier).InnerText.ToString();

                                    string xNode25DStatusCode = xNode25D.SelectSingleNode(xPathStatusCode).InnerText.ToString();


                                    if (xNode24BQualifier.CompareTo(xNode25DStatusCode) != 0)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, xNode24B.ParentNode.Name, xNode24B.InnerText);
                                        isValid = false;
                                    }
                                }
                            }
                        }
                    }
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	SWIFTNetworkRule98
        /// </method>
        /// <summary>
        /// 	This method checks whether specified Sequence X contains more than one tag or not.
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence" type = "string">
        /// 	Contains xPath for Sequence for which validation is to be done.
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Error code to be displayed.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input Containing policyName
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input Containing Rule Name
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input Containing MessageType.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input Containing Conditional Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber" type = "string">
        /// 	Input containing Conditional Rule number
        /// </param>
        /// <param name="errorObject">
        /// 	Input containing Object Of ErrorCollection Class.
        /// </param>
        /// <returns>
        /// 	boolean
        /// </returns>

        public static bool SWIFTNetworkRule98(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule98" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                XmlNode xSequence = xRoot.SelectSingleNode(xPathSequence);

                if (xSequence.ChildNodes.Count < 2)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule2
        /// </method>
        /// <summary>
        ///		This method performs a check on the Currencies of all tags specified in xPath and xPath1.
        ///		This is an overloaded function which takes into account the structure of signcodeamount
        ///		and then performs validation for currency for tags using this structure.
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPath" type = "string">
        ///		List of Comma Separated xPaths which contain Currency as seperate Field
        /// </param>
        /// <param name="xPath1" type = "string">
        ///		List of Comma Separated xPath which contain Currency Clubbed with other fields i.e. SignCodeAmount.
        ///		Here Code part Contains Currency.
        /// </param>
        /// <param name="errorCode" type = "string">
        ///		Error code to be displayed.
        /// </param>
        /// <param name="policyName" type = "string">
        ///		Input Containing PolicyName
        /// </param>
        /// <param name="ruleName" type = "string">
        ///		Input Containing Rule Name
        /// </param>
        ///	<param name="messageType" type = "string">
        ///		Input Containing MessageType.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        ///		Input Containing Conditional Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber" type = "string">
        ///		Input containing Conditional Rule number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing Object Of ErrorCollection Class.
        /// </param>
        /// <returns>
        ///		boolean
        ///	</returns>

        public static bool SWIFTNetworkRule2(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xPath1,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule2" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                isValid = IsValidCurrencyInSignCodeAmount(xDocument, xPath, xPath1, errorCode, policyName,
                    ruleName, messageType, conditionalRuleName,
                    conditionalRuleNumber, errorObject);
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        /// 	ConvertToDecimal
        /// </method>
        /// <summary>
        /// 	This method converts an input string with format as [N]3!a15d
        /// 	( same as that of SignCodeAmount) into an equivalent Decimal.
        /// 	If the input string is null then it returns 0;
        /// </summary>
        /// <param name="signCodeAmount" type = "string" >
        /// 	Input string containing Amount clubbed with sign and Currency to be converted into equivalent Decimal Amount.
        /// </param>
        /// <returns>
        /// 	Decimal
        /// </returns>
        public static Decimal ConvertToDecimal(string signCodeAmount)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function ConvertToDecimal:");
            try
            {
                if (null == signCodeAmount) throw new ArgumentNullException("signCodeAmount");

                int startPositionOfAmount = 0;
                string tempValue = string.Empty;
                Decimal amount = 0;

                if (signCodeAmount.CompareTo(Constants.BLANK) != 0)
                {
                    tempValue = signCodeAmount.Substring(Constants.INT3, Constants.INT1);

                    if (Constants.ALPHASET.IndexOf(tempValue) == -1)
                    {
                        startPositionOfAmount = Constants.INT3;
                    }

                    else
                    {
                        startPositionOfAmount = Constants.INT4;
                    }

                    amount = Convert.ToDecimal(signCodeAmount.Substring(startPositionOfAmount).Replace(Constants.COMMA, decimalSeparator), CultureInfo.InvariantCulture);

                    if (startPositionOfAmount == Constants.INT4)
                    {
                        return (-amount);
                    }

                    return amount;
                }

                else
                {
                    return 0;

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        /// <method>
        /// IsValidDateYYMMDD
        /// </method>
        /// <summary>
        /// The functions Converts a string input into equivalent Datetime Format.
        /// If the input string is invaid date then it returns False otherwise it returns True.
        /// </summary>
        /// <param name="strDate" type = "string">
        /// Input string to be converted into Equivalent Datetime.
        /// </param>
        /// <returns>bool</returns>

        public static bool IsValidDateYYMMDD(string strDate)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidDateYYMMDD:");
            bool isValid;

            if (null == strDate)
            {
                isValid = false;
            }
            else
            {
                try
                {
                    int year = Int32.Parse(strDate.Substring(0, 2), Constants.INVARIANTCULTURE);
                    int month = Int32.Parse(strDate.Substring(2, 2), Constants.INVARIANTCULTURE);
                    int day = Int32.Parse(strDate.Substring(4, 2), Constants.INVARIANTCULTURE);

                    // Y2K stuff...
                    if (year >= 60 && year <= 99) year += 1900;
                    else if (year >= 0) year += 2000;
                    else throw new ArgumentOutOfRangeException();

                    DateTime dtDate = new DateTime(year, month, day);
                    isValid = true;
                }
                catch (FormatException)
                {
                    isValid = false;
                }

                catch (ArgumentOutOfRangeException)
                {
                    isValid = false;
                }
                catch (ArgumentException)
                {
                    isValid = false;
                }
            }
            return isValid;
        }

        /// <method>
        /// IsValidDateYYYYMMDD
        /// </method>
        /// <summary>
        /// The functions Converts a string input into equivalent Datetime Format.
        /// If the input string is invaid date then it returns False otherwise it returns True.
        /// </summary>
        /// <param name="strDate" type = "string">
        /// Input string to be converted into Equivalent Datetime.
        /// </param>
        /// <returns> bool</returns>


        public static bool IsValidDateYYYYMMDD(string strDate)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidDateYYYYMMDD:");
            bool isValid;

            if (null == strDate)
            {
                isValid = false;
            }
            else
            {
                try
                {
                    int year = Int32.Parse(strDate.Substring(0, 4), Constants.INVARIANTCULTURE);
                    int month = Int32.Parse(strDate.Substring(4, 2), Constants.INVARIANTCULTURE);
                    int day = Int32.Parse(strDate.Substring(6, 2), Constants.INVARIANTCULTURE);

                    DateTime dtDate = new DateTime(year, month, day);
                    isValid = true;
                }
                catch (FormatException)
                {
                    isValid = false;
                }

                catch (ArgumentOutOfRangeException)
                {
                    isValid = false;
                }
                catch (ArgumentException)
                {
                    isValid = false;
                }
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule286
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 286.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence in which the Rule has to be validated.
        /// </param>
        /// <param name ="xPathSubSequence" type = "string">
        ///		Input reference of the Sub Sequence in ehich the Tag occurs.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Comma separated Tag name e.g 95C,95S.
        /// </param>
        /// <param name ="fieldName" type = "string">
        ///		Generic field name of the Tag.
        /// </param>
        /// <param name ="qualifierListDel" type = "string">
        ///		Reference containing the Deliverers list.
        /// </param>
        /// <param name ="qualifierListRec" type = "string">
        ///		Reference containing the Receivers list.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing message number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing name of the conditional rule
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing number of the conditional rule
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule286(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPath,
            string fieldName,
            string qualifierListDel,
            string qualifierListRec,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule286" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                if (null == qualifierListRec) throw new ArgumentNullException("qualifierListRec");
                if (null == xPathSubSequence) throw new ArgumentNullException("xPathSubSequence");
                if (null == qualifierListDel) throw new ArgumentNullException("qualifierListDel");

                ArrayList xPathArrayTemp = new ArrayList();

                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);
                string[] xPathSeqArray = xPathSubSequence.Split(Constants.CHRCOMMA);

                //creating required xPaths
                for (int j = 0; j <= xPathSeqArray.Length - 1; j++)
                {
                    for (int i = 0; i <= xPathArray.Length - 1; i++)
                    {
                        string tempHoldValue = Constants.XPATH + fieldName + Constants.UNDERSCORE + xPathSeqArray[j].Substring(10) + Constants.UNDERSCORE + xPathArray[i] + Constants.SLASH + Constants.QUALIFIER;
                        xPathArrayTemp.Add(tempHoldValue);
                    }
                }

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Sequence in which the Rule is to be verified
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    ArrayList arrayQualifier = new ArrayList();

                    string qualifierListDelReq = string.Empty;
                    string qualifierListRecReq = string.Empty;
                    string qualifierList = string.Empty;

                    int startIndexDel = 0;
                    int startIndexRec = 0;

                    string qualifierListTemp = qualifierList;

                    //Select all the nodes of Subsequence under the Sequence
                    XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);

                    foreach (XmlNode xNodeSubSequence in xListSubSequence)
                    {
                        for (int nCount = 0; nCount <= xPathArrayTemp.Count - 1; nCount++)
                        {
                            XmlNodeList xList = xNodeSubSequence.SelectNodes(xPathArrayTemp[nCount].ToString());
                            if (xList.Count != 0)
                            {
                                foreach (XmlNode xNode in xList)
                                {
                                    //Store the values of Qualifiers of all the Tags under the Sequence
                                    arrayQualifier.Add(xNode.InnerText);
                                }

                            }
                        }
                    }

                    string strQualifier = string.Empty;
                    bool qualifierDelExist = false;
                    bool qualifierRecExist = false;

                    //Check for delivers and receivers qualifier list
                    if (arrayQualifier.Count != 0)
                    {
                        /*---Delivers--*/
                        for (int i = 0; i <= arrayQualifier.Count - 1; i++)
                        {
                            strQualifier = arrayQualifier[i].ToString().Trim();
                            startIndexDel = qualifierListDel.IndexOf(strQualifier);

                            //if the qualifier exists in input instance
                            if (startIndexDel != -1)
                            {
                                qualifierDelExist = true;
                                if (qualifierListDel.Substring(startIndexDel).Length > qualifierListDelReq.Length)
                                {
                                    //Store the values of all the Qualifiers that need to occur
                                    qualifierListDelReq = qualifierListDel.Substring(startIndexDel);
                                    qualifierListDelReq = qualifierListDelReq + Constants.COMMA;
                                }
                            }
                        }
                        /*----Receivers--*/
                        for (int i = 0; i <= arrayQualifier.Count - 1; i++)
                        {
                            strQualifier = arrayQualifier[i].ToString().Trim();
                            startIndexRec = qualifierListRec.IndexOf(strQualifier);

                            //if the qualifier exist in input instance
                            if (startIndexRec != -1)
                            {
                                qualifierRecExist = true;
                                if (qualifierListRec.Substring(startIndexRec).Length > qualifierListRecReq.Length)
                                {
                                    //Store the values of all the Qualifiers that need to occur
                                    qualifierListRecReq = qualifierListRec.Substring(startIndexRec);
                                    qualifierListRecReq = qualifierListRecReq + Constants.COMMA;
                                }
                            }
                        }
                    }

                    //If one of the Qualifier occurs from the Deliverers list
                    if (qualifierDelExist == true)
                    {
                        for (int j = 0; j <= arrayQualifier.Count - 1; j++)
                        {
                            strQualifier = arrayQualifier[j].ToString().Trim();
                            if (qualifierListDelReq.IndexOf(strQualifier) != -1)
                            {
                                strQualifier = strQualifier + Constants.COMMA;
                                qualifierListDelReq = qualifierListDelReq.Replace(strQualifier, Constants.BLANK);
                            }

                        }
                        qualifierListDelReq = qualifierListDelReq.Replace(Constants.COMMA, Constants.BLANK).Trim();

                        //If some of the Qualifiers which need to occur does not occur, then Rule is not satisfied
                        if (qualifierListDelReq.Length != 0)
                        {
                            isValid = false;
                        }

                    }

                    //If one of the Qualifier occurs from the Receivers list
                    if (qualifierRecExist == true)
                    {
                        for (int j = 0; j <= arrayQualifier.Count - 1; j++)
                        {
                            strQualifier = arrayQualifier[j].ToString().Trim();
                            if (qualifierListRecReq.IndexOf(strQualifier) != -1)
                            {
                                strQualifier = strQualifier + Constants.COMMA;
                                qualifierListRecReq = qualifierListRecReq.Replace(strQualifier, Constants.BLANK);
                            }

                        }
                        qualifierListRecReq = qualifierListRecReq.Replace(Constants.COMMA, Constants.BLANK).Trim();

                        //If some of the Qualifiers which need to occur does not occur, then Rule is not satisfied
                        if (qualifierListRecReq.Length != 0)
                        {
                            isValid = false;
                        }

                    }

                    //If some of the Qualifiers which need to occur does not occur, then throw an error
                    if (isValid == false)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType,
                            conditionalRuleName, conditionalRuleNumber);
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule237
        /// </method>
        /// <summary>
        ///		Within each occurrence of sequence B, the qualifier field 24B must be the same as the code word
        ///		(Status Code) used with the appropriate qualifier in field 25D of the same occurrence of sequence B
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B
        /// </param>
        /// <param name ="xPath25D" type = "string">
        ///		Input reference of the element 25D in Sequence B
        /// </param>
        /// <param name ="xPath24B" type = "string">
        ///		Input reference of the element 24B in Sequence B
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Reference containing the xPath of the Qualifier in the current node(element 24B).
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Reference containing the xPath of the Data Source Scheme in the current node(element 25D).
        /// </param>
        /// <param name ="xPathStatusCode" type = "string">
        ///		Reference containing the xPath of the Status Code in the current node(element 25D).
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule237(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath25D,
            string xPath24B,
            string xPathQualifier,
            string xPathDataSourceScheme,
            string xPathStatusCode,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule237" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath25D == null ||
                    xPath25D.Length == 0 ||
                    xPath24B == null ||
                    xPath24B.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathStatusCode == null ||
                    xPathStatusCode.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Sequence B (or) C3
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    //Select all the nodes of Field 24B
                    XmlNodeList xListNode24B = xNodeSequence.SelectNodes(xPath24B);
                    if (xListNode24B.Count != 0)
                    {
                        XmlNode xNode25D = xNodeSequence.SelectSingleNode(xPath25D);
                        if (xNode25D != null && xNode25D.InnerText.Length != 0)
                        {
                            if (xNode25D.SelectSingleNode(xPathDataSourceScheme) == null)
                            {
                                foreach (XmlNode xNode24B in xListNode24B)
                                {
                                    if (xNode24B != null && xNode24B.InnerText.Length != 0)
                                    {
                                        XmlNode xNode24BQualifier = xNode24B.SelectSingleNode(xPathQualifier);
                                        XmlNode xNode25DStatusCode = xNode25D.SelectSingleNode(xPathStatusCode);
                                        if (xNode24BQualifier != null && xNode24BQualifier.InnerText.Length != 0 && xNode25DStatusCode != null && xNode25DStatusCode.InnerText.Length != 0)
                                        {
                                            if ((Convert.ToString(xNode24BQualifier.InnerText, CultureInfo.InvariantCulture)) != (Convert.ToString(xNode25DStatusCode.InnerText, CultureInfo.InvariantCulture)))
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule211
        /// </method>
        /// <summary>
        ///		If field 23E contains TRAV, then either field 21D or field 29a must be present, but not both.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of the Element 22E in Sequence A.
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of the Element 21D in Sequence B.
        /// </param>
        /// <param name ="xPath3" type = "string">
        ///		Input reference of the Element 29a in Sequence B.
        /// </param>
        /// <param name ="code" type = "string">
        ///		Reference containing the value of the Type for xPath1.
        ///	</param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule211(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath1,
            string xPath2,
            string xPath3,
            string code,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule211" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath1 == null ||
                    xPath2 == null ||
                    xPath3 == null ||
                    xPathSequence == null ||
                    xPath1.Length == 0 ||
                    xPath2.Length == 0 ||
                    xPath3.Length == 0 ||
                    xPathSequence.Length == 0 ||
                    code == null ||
                    code.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleName.Length == 0 ||
                    conditionalRuleNumber == null ||
                    conditionalRuleNumber.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xList = xRoot.SelectNodes(xPathSequence);
                XmlNode xNode1 = xRoot.SelectSingleNode(xPath1);
                string[] xPathArray3 = xPath3.Split(Constants.CHRCOMMA);

                if (xNode1 != null)
                {
                    if (xNode1.FirstChild != null)
                    {
                        if (xNode1.FirstChild.InnerText != null)
                        {
                            if (xNode1.FirstChild.InnerText.CompareTo(code) == 0)
                            {
                                foreach (XmlNode xNode in xList)
                                {
                                    if (xNode.SelectSingleNode(xPath2) != null)
                                    {
                                        for (int i = 0; i < xPathArray3.Length; i++)
                                        {
                                            if (xNode.SelectSingleNode(xPathArray3[i]) != null)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        for (int i = 0; i < xPathArray3.Length; i++)
                                        {
                                            if (xNode.SelectSingleNode(xPathArray3[i]) != null)
                                            {
                                                break;
                                            }
                                            if (i == xPathArray3.Length - 1)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                isValid = false;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule219
        /// </method>
        /// <summary>
        ///		If field 23E contains GENC or OTHR and there is no field 29a, the following fields must be present,
        ///		field 58a Issuers Financial Institution
        /// 	field 25 Issuers Account Number/Code
        ///		field 21D Cheque Number
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of the Element 23E in Sequence A.
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of the Element 29a in Sequence B.
        /// </param>
        /// <param name ="xPath3" type = "string">
        ///		Input reference of the Element 21D in Sequence B.
        /// </param>
        /// <param name ="xPath4" type = "string">
        ///		Input reference of the Element 25 in Sequence B.
        /// </param>
        /// <param name ="xPath5" type = "string">
        ///		Input reference of the Element 58a in Sequence B.
        /// </param>
        /// <param name ="code" type = "string">
        ///		Reference containing the value of the Type for xPath1.
        ///	</param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool SWIFTNetworkRule219(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence,
        //    string xPath1,
        //    string xPath2,
        //    string xPath3,
        //    string xPath4,
        //    string xPath5,
        //    string code,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)

        //{
        //    bool isValid = true;

        //    if(xDocument == null ||
        //        xPath1 == null ||
        //        xPath2 == null ||
        //        xPath3 == null ||
        //        xPath4 == null ||
        //        xPath5 == null ||
        //        xPathSequence == null ||
        //        xPath1.Length == 0 ||
        //        xPath2.Length == 0 ||
        //        xPath3.Length == 0 ||
        //        xPath4.Length == 0 ||
        //        xPath5.Length == 0 ||
        //        xPathSequence.Length == 0 ||
        //        code == null ||
        //        code.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        ruleName == null ||
        //        ruleName.Length == 0 ||
        //        messageType == null ||
        //        messageType.Length == 0 ||
        //        conditionalRuleName == null ||
        //        conditionalRuleName.Length == 0 ||
        //        conditionalRuleNumber == null ||
        //        conditionalRuleNumber.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    XmlNode xRoot = xDocument.Document;

        //    XmlNodeList xList = xRoot.SelectNodes(xPathSequence);
        //    XmlNode xNode1 = xRoot.SelectSingleNode(xPath1);
        //    string[] xPathArray2 = xPath2.Split(Constants.CHRCOMMA);
        //    string[] xPathArray5 = xPath5.Split(Constants.CHRCOMMA);
        //    string[] codeArray = code.Split(Constants.CHRCOMMA);

        //    if(xNode1 != null)
        //    {
        //        if(xNode1.FirstChild != null)
        //        {
        //            if(xNode1.FirstChild.InnerText != null)
        //            {
        //                for(int j=0 ; j<codeArray.Length ; j++)
        //                {
        //                    if(xNode1.FirstChild.InnerText.CompareTo(codeArray[j])== 0)
        //                    {
        //                        foreach(XmlNode xNode in xList)
        //                        {
        //                            for(int i=0 ;i <xPathArray2.Length ; i++)
        //                            {
        //                                if(xNode.SelectSingleNode(xPathArray2[i]) != null)
        //                                {
        //                                    break;
        //                                }
        //                                if(i == xPathArray2.Length-1 )
        //                                {
        //                                    if(xNode.SelectSingleNode(xPath3) == null)
        //                                    {
        //                                        errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                                        isValid = false;
        //                                    }
        //                                    if(xNode.SelectSingleNode(xPath4) == null)
        //                                    {
        //                                        errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                                        isValid = false;
        //                                    }
        //                                    for(int k=0 ;k < xPathArray5.Length ; k++)
        //                                    {
        //                                        if(xNode.SelectSingleNode(xPathArray5[k]) != null)
        //                                        {
        //                                            break;
        //                                        }
        //                                        if(k == xPathArray5.Length-1 )
        //                                        {
        //                                            errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                                            isValid = false;
        //                                        }
        //                                    }
        //                                }
        //                            }
        //                        }
        //                        break;
        //                    }
        //                }
        //            }
        //        }
        //    }

        //    return isValid;

        //}

        /// <method>
        ///		CheckSumOfAmounts
        /// </method>
        /// <summary>
        ///		It checks that if a particular tag contains a particular value , then the sum of amounts of all
        ///		occurences of a tag in a repetitive sequence is equal to the amount of the third tag.
        ///		for eg:When field 28E contains ONLY, the amount specified in field 32A must be equal to the
        ///		sum of all occurrences of field 32J in sequence B
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of the Element 28E in Sequence A.
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of the Element 32J in Sequence B.
        /// </param>
        /// <param name ="xPath3" type = "string">
        ///		Input reference of the Element 32A in Sequence C.
        /// </param>
        /// <param name ="code" type = "string">
        ///		Reference containing the value of the Type for xPath1.
        ///	</param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool CheckSumOfAmounts(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence,
        //    string xPath1,
        //    string xPath2,
        //    string xPath3,
        //    string code,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)

        //{
        //    bool isValid = true;
        //    double amount = 0.0;

        //    if(xDocument == null ||
        //        xPath1 == null ||
        //        xPath2 == null ||
        //        xPath3 == null ||
        //        xPathSequence == null ||
        //        xPath1.Length == 0 ||
        //        xPath2.Length == 0 ||
        //        xPath3.Length == 0 ||
        //        xPathSequence.Length == 0 ||
        //        code == null ||
        //        code.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        ruleName == null ||
        //        ruleName.Length == 0 ||
        //        messageType == null ||
        //        messageType.Length == 0 ||
        //        conditionalRuleName == null ||
        //        conditionalRuleName.Length == 0 ||
        //        conditionalRuleNumber == null ||
        //        conditionalRuleNumber.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    XmlNode xRoot = xDocument.Document;

        //    XmlNodeList xList = xRoot.SelectNodes(xPathSequence);
        //    XmlNode xNode1 = xRoot.SelectSingleNode(xPath1);
        //    string[] codelistArray = code.Split(Constants.CHRCOMMA);

        //    if(xNode1 != null)
        //    {
        //        if(xNode1.LastChild != null)
        //        {
        //            if(xNode1.LastChild .InnerText != null)
        //            {
        //                string stringAmount = string.Empty;
        //                double amount1 = 0.0;
        //                for(int j=0; j< codelistArray.Length ;j++)
        //                {
        //                    if(xNode1.LastChild.InnerText.CompareTo(codelistArray[j])== 0)
        //                    {
        //                        foreach(XmlNode xNode in xList)
        //                        {
        //                            if(xNode.SelectSingleNode(xPath2) != null)
        //                            {
        //                                if(xNode.SelectSingleNode(xPath2).InnerText != null)
        //                                {
        //                                    stringAmount =xNode.SelectSingleNode(xPath2).InnerText.Replace(Constants.COMMA,decimalSeparator);
        //                                    amount = amount + Convert.ToDouble(stringAmount, CultureInfo.InvariantCulture);
        //                                }
        //                            }
        //                        }
        //                        XmlNode xNode2 = xRoot.SelectSingleNode(xPath3);

        //                        stringAmount =string.Empty;
        //                        if(xNode2 != null && xNode2.InnerText != null)
        //                        {
        //                            if(xNode2.InnerText.Length > 9)
        //                            {
        //                                if (Constants.ALPHASET.IndexOf(xNode2.InnerText.Substring(6,1)) != -1 )
        //                                {
        //                                    stringAmount = xNode2.InnerText.Substring(9).Replace(Constants.COMMA,decimalSeparator);
        //                                    amount1 = Convert.ToDouble(stringAmount, CultureInfo.InvariantCulture);
        //                                }
        //                                else
        //                                {
        //                                    stringAmount = xNode2.InnerText.Replace(Constants.COMMA,decimalSeparator);
        //                                    amount1 = Convert.ToDouble(stringAmount, CultureInfo.InvariantCulture);
        //                                }

        //                            }
        //                            else
        //                            {
        //                                stringAmount = xNode2.InnerText.Replace(Constants.COMMA,decimalSeparator);
        //                                amount1 = Convert.ToDouble(stringAmount, CultureInfo.InvariantCulture);
        //                            }
        //                            if(amount1 != amount)
        //                            {
        //                                errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                                isValid = false;
        //                            }
        //                        }
        //                    }
        //                }
        //            }
        //        }
        //    }

        //    return isValid;
        //}
        /* Commented against Bug Id 96926
        /// <method>
        ///		IsValidExtendedNumberId
        /// </method>
        /// <summary>
        ///		This method performs validation for Usage Rule of Tag 13a in Sequence A of message MT536.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPath13J">
        ///		Input reference of the element 13J in Sequence A.
        /// </param>
        /// <param name="xPath22F">
        /// 	Input reference of the element 22F in Sequence A.
        /// </param>
        /// <param name="xPathDataSourceScheme">
        ///		Input reference of the element 'DataSourceScheme' of Tag 22F.
        /// </param>
        /// <param name="qualifierValue">
        ///		Input containing the value of Qualifier of Tag 22F.
        /// </param>
        /// <param name="indicatorValue">
        ///		Input containing the value of Indicator of Tag 22F.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidExtendedNumberId(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath13J,
            string xPath22F,
            string xPathDataSourceScheme,
            string qualifierValue,
            string indicatorValue,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {

            bool isValid = true;

            if(xDocument == null ||
                xPath13J == null ||
                xPath13J.Length == 0 ||
                xPath22F == null ||
                xPath22F.Length == 0 ||
                xPathDataSourceScheme == null ||
                xPathDataSourceScheme.Length == 0 ||
                qualifierValue == null ||
                qualifierValue.Length == 0 ||
                indicatorValue == null ||
                indicatorValue.Length == 0 ||
                errorCode == null ||
                errorCode.Length == 0 ||
                errorObject == null)
            {
                return false;
            }
            XmlNode xRoot = xDocument.Document;

            //Select the node of Tag 13J
            XmlNode xNode13J = xRoot.SelectSingleNode(xPath13J);

            //If Tag 13J is present
            if(xNode13J != null)
            {
                int count = 0;

                //Select the nodes of Tag 22F
                XmlNodeList xList22F = xRoot.SelectNodes(xPath22F);

                foreach(XmlNode xNode22F in xList22F)
                {
                    if(xNode22F.FirstChild != null && xNode22F.LastChild != null)
                    {
                        //If the Qualifier is equal to qualifierValue, Data Source Scheme not present and Indicator is equal to indicatorValue
                        if(xNode22F.FirstChild.InnerText.CompareTo(qualifierValue) == 0
                            && xNode22F.SelectSingleNode(xPathDataSourceScheme) == null
                            && xNode22F.LastChild.InnerText.CompareTo(indicatorValue) == 0)
                            count++;
                    }
                }

                //If it is not a DELTA statement and Tag 13J is present
                if(count == 0)
                {
                    errorObject.AddError(errorCode,policyName,ruleName,xNode13J.LocalName.ToString(),xNode13J.InnerText);
                    isValid = false;
                }
            }

            return isValid;
        }

        */

        /// <method>
        /// IsValidCommonReference
        /// </method>
        /// <summary>
        /// This functions Performs a validation on ReferenceCode ,third field in CommonReference Node, which must consist of the rightmost non-zero digit of field
        /// specified by xPathRate, preceded by the three digits to the left of it. If there are no digits to the left of it, the space must be zero
        /// filled.
        /// </summary>
        /// <param name="xDocument" Type = " string" >
        /// Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathReferenceCode" Type = " string">
        /// Reference containing the xPath of the ReferenceCode in CommonReference Node(element 22/22C).
        /// </param>
        /// <param name="xPathRate" Type = " string">
        /// Reference containing the xPath of the Decimal Part in Rate.
        /// </param>
        /// <param name="errorCode" Type = " string" >
        /// Input containing Error Code</param>
        /// <param name="policyName" Type = " string">
        /// Input Containing Policy Name
        /// </param>
        /// <param name="errorObject" Type = "ErrorCollection">
        /// Input Containing Object of ErrorCollection used to Add errors.
        /// </param>
        /// <param name="ruleName" Type = " string">
        /// Input Containing Rule Name.
        /// </param>
        /// <returns> Boolean</returns>

        public static bool IsValidCommonReference(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathReferenceCode,
            string xPathRate,
            string errorCode,
            string policyName,
            ErrorCollection errorObject,
            string ruleName)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCommonReference" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPathReferenceCode == null ||
                    xPathRate == null ||
                    xPathReferenceCode.Length == 0 ||
                    xPathRate.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNode xReferenceCode = xRoot.SelectSingleNode(xPathReferenceCode.ToString());

                char[] checkReference = new char[4];
                string referenceCode1 = string.Empty;
                int digitCount = 4;
                bool flag = false;

                if (xReferenceCode != null && xReferenceCode.InnerText != null)
                {
                    XmlNode xRate = xRoot.SelectSingleNode(xPathRate.ToString());

                    if (xRate != null && xRate.InnerText != null)
                    {
                        char[] rate = xRate.InnerText.ToCharArray();
                        string referenceCode = xReferenceCode.InnerText;

                        for (int i = rate.Length - 1; (i >= 0 && digitCount > 0); i--)
                        {
                            if (rate[i].CompareTo(Constants.CHR0) != 0 || flag == true)
                            {
                                if (rate[i].CompareTo(Constants.CHRCOMMA) != 0 && rate[i].CompareTo(Constants.NEGATIVESIGN) != 0)
                                {

                                    checkReference[digitCount - 1] = rate[i];
                                    digitCount--;
                                    if (!flag)
                                    {
                                        flag = true;
                                    }

                                }
                            }
                        }

                        if (digitCount > 0)
                        {
                            for (int i = 0; i < digitCount; i++)
                            {
                                checkReference[digitCount - i - 1] = '0';

                            }

                        }
                        // Concatenate the characters in checkReference array and save it as string in referenceCode1.
                        for (int nCount = 0; nCount < checkReference.Length; nCount++)
                        {
                            referenceCode1 = referenceCode1 + checkReference[nCount].ToString();
                        }

                        if (referenceCode.CompareTo(referenceCode1) != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, xReferenceCode.Name, referenceCode);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }

        /// <method>
        ///		IsValidCommonReference
        /// </method>
        /// <summary>
        ///		This field consists of the bank and location codes (Error code(s): T95) (from the ISO Bank Identifier Code) of both the
        ///		Sender and the Receiver of the MT 360. These codes must appear in alphabetical order (letters take precedence over numbers)
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag22C">
        ///		Input reference of the element 22C to be validated.// for e.g. //CommonReference_A_22C/CommonReference
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidCommonReference(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag22C,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCommonReference" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPathTag22C == null ||
                    xPathTag22C.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList22C = xRoot.SelectNodes(xPathTag22C.ToString());

                //Check for the existence of Tag 22C
                if (xList22C.Count != 0)
                {

                    //If Tag 22C exists then take Bank code1, Location code1, Bank code2 and Location code2
                    XmlNode xListCode1 = xList22C.Item(0).FirstChild;

                    string bankCode1 = xListCode1.InnerText;
                    string locationCode1 = xListCode1.NextSibling.InnerText;
                    XmlNode xListCode2 = xList22C.Item(0).LastChild;
                    string locationCode2 = xListCode2.InnerText;
                    string bankCode2 = xListCode2.PreviousSibling.InnerText;

                    //Check for the alphabetical order
                    isValid = CheckAlphabeticalOrder(bankCode1, locationCode1,
                        bankCode2, locationCode2, xList22C.Item(0).Name, errorCode,
                        policyName, ruleName, errorObject);
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule220
        /// </method>
        /// <summary>
        ///		If field 29a is present, the following fields must not be present ,
        /// 	field 58a Issuers Account Number/Code
        ///		 field 21D Cheque Number
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence B.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of the Element 23E in Sequence A.
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of the Element 29a in Sequence B.
        /// </param>
        /// <param name ="xPath3" type = "string">
        ///		Input reference of the Element 21D in Sequence B.
        /// </param>
        /// <param name ="xPath4" type = "string">
        ///		Input reference of the Element 58a in Sequence B.
        /// </param>
        /// <param name ="code" type = "string">
        ///		Reference containing the value of the Type for xPath1.
        ///	</param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool SWIFTNetworkRule220(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence,
        //    string xPath1,
        //    string xPath2,
        //    string xPath3,
        //    string xPath4,
        //    string code,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)

        //{
        //    bool isValid = true;

        //    if(xDocument == null ||
        //        xPath1 == null ||
        //        xPath2 == null ||
        //        xPath3 == null ||
        //        xPath4 == null ||
        //        xPathSequence == null ||
        //        xPath1.Length == 0 ||
        //        xPath2.Length == 0 ||
        //        xPath3.Length == 0 ||
        //        xPath4.Length == 0 ||
        //        xPathSequence.Length == 0 ||
        //        code == null ||
        //        code.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        ruleName == null ||
        //        ruleName.Length == 0 ||
        //        messageType == null ||
        //        messageType.Length == 0 ||
        //        conditionalRuleName == null ||
        //        conditionalRuleName.Length == 0 ||
        //        conditionalRuleNumber == null ||
        //        conditionalRuleNumber.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    XmlNode xRoot = xDocument.Document;

        //    XmlNodeList xList = xRoot.SelectNodes(xPathSequence);
        //    XmlNode xNode1 = xRoot.SelectSingleNode(xPath1);
        //    string[] xPathArray2 = xPath2.Split(Constants.CHRCOMMA);
        //    string[] xPathArray4 = xPath4.Split(Constants.CHRCOMMA);
        //    string[] codeArray = code.Split(Constants.CHRCOMMA);

        //    if(xNode1 != null)
        //    {
        //        if(xNode1.FirstChild != null)
        //        {
        //            if(xNode1.FirstChild.InnerText != null)
        //            {
        //                for(int j=0 ; j<codeArray.Length ; j++)
        //                {
        //                    if(xNode1.FirstChild.InnerText.CompareTo(codeArray[j])== 0)
        //                    {
        //                        foreach(XmlNode xNode in xList)
        //                        {
        //                            for(int i=0 ;i <xPathArray2.Length ; i++)
        //                            {
        //                                if(xNode.SelectSingleNode(xPathArray2[i]) != null)
        //                                {
        //                                    if(xNode.SelectSingleNode(xPath3) != null)
        //                                    {
        //                                        errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                                        isValid = false;
        //                                    }
        //                                    for(int k=0 ;k <xPathArray4.Length ; k++)
        //                                    {
        //                                        if(xNode.SelectSingleNode(xPathArray4[k]) != null)
        //                                        {
        //                                            errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                                            isValid = false;
        //                                        }
        //                                    }
        //                                }
        //                            }

        //                        }
        //                    }
        //                }
        //            }
        //        }
        //    }

        //    return isValid;
        //}

        /// <method>
        ///		ReturnXPathValueList
        /// </method>
        /// <summary>
        ///		This method returns the string values seperated by comma of the node being accessed using the xPath.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <returns type = "string">
        ///		Returns the List of values.
        /// </returns>
        public static string ReturnXPathValueList(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function ReturnXPathValueList:");
            string elementList = string.Empty;
            string strValue = string.Empty;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0)
                {
                    return strValue;
                }
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);
                foreach (XmlNode xNode in xList)
                {
                    if (xNode.InnerText != null)
                    {
                        elementList = elementList + xNode.InnerText + Constants.COMMA;
                    }

                }
                if (elementList.Length > 0)
                {
                    strValue = elementList.Substring(0, elementList.Length - 1);
                }

                return strValue;
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        /// <method>
        ///		IsValidProprietaryMessage
        /// </method>
        /// <summary>
        ///		This method performs validation for the Tag 77E.
        ///		The maximum size of this field is limited to 9800 characters.
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag77E">
        ///		Input reference of the element 77E to be validated.
        /// </param>
        /// <param name="valueTag77EMaxLength">
        ///		Reference containing the Max length value of Tag 77E.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidProprietaryMessage(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag77E,
            int valueTag77EMaxLength,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidProprietaryMessage" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;

            if (xDocument == null ||
                xPathTag77E == null ||
                xPathTag77E.Length == 0 ||
                errorCode == null ||
                errorCode.Length == 0 ||
                errorObject == null)
            {
                return false;
            }

            try
            {
                XmlNode xRoot = xDocument.Document;
                XmlNode xNode77E = xRoot.SelectSingleNode(xPathTag77E);

                if (xNode77E != null)
                {
                    int childCount = xNode77E.ChildNodes.Count;
                    XmlNode xNode = xNode77E.FirstChild;

                    string strLine = xNode.InnerText;
                    string strLine1 = null;

                    for (int nCount = 1; nCount <= childCount - 2; nCount++)
                    {
                        xNode = xNode.NextSibling;
                        strLine1 = xNode.InnerText;

                        strLine = strLine + Constants.CHRCARRIAGERETURN + Constants.CHRLINEFEED + strLine1;
                    }

                    if (strLine.Length > valueTag77EMaxLength)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode77E.Name, strLine);
                        isValid = false;
                    }

                }

            }
            catch (ApplicationException _appException)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}", _appException.StackTrace + "Reason" + _appException.Message);
                throw _appException;
            }

            return isValid;
        }


        /// <method>
        /// 	IsValidPartyIdentification
        /// </method>
        /// <summary>
        ///		This method performs validation for Tag J(SwiftNetworkRuleT78). Following validations are taken care
        ///		- More than one code word may be used in a line. i.e. the maximum number of characters number of lines in a field, another code word may follow the previous code word format text field.
        ///		- The information relating to a code word may be split across lines.
        ///		- A code word itself must not be split across lines.
        ///		- the special character / is not allowed in any of the X, Y or Z character sets that is permitted to follow a code word. This exception is necessary because the character/ indicates always the beginning of a code word.
        ///		- a code word must not be duplicated within a field.
        ///
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTagJ">
        ///		Input reference of the element J to be validated.
        /// </param>
        /// <param name="valueCodesFormat">
        ///		List of valid Codes-format pair separated by comma. Code and format should be separated by Pipe character.
        ///		for e.g /ABIC/|11c,/NAME/|34x,/USFW/|9!n,/USCH/|6!n
        /// </param>
        /// <param name="valueMandatoryCodes">
        ///		List of Mandatory codes separated by comma
        ///		/ABIC/,/NAME/
        /// </param>
        /// <param name="sortFlag">
        ///		Input containing either true or false. True indicates that code in the xDocument has to be in order.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidPartyIdentification(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTagJ,
            string valueCodesFormat,
            string valueMandatoryCodes,            
            bool sortFlag,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject
            )
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidPartyIdentification" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPathTagJ == null ||
                    valueCodesFormat == null ||
                    valueMandatoryCodes == null ||
                    xPathTagJ.Length == 0 ||
                    valueCodesFormat.Length == 0 ||
                    valueMandatoryCodes.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListJ = xRoot.SelectNodes(xPathTagJ.ToString());

                //Check the existence of Tag J
                if (xListJ.Count != 0)
                {
                    //Split the Code-format pair into Array variable
                    string[] strArray = valueCodesFormat.Split(Constants.CHRCOMMA);
                    int nArrayCount = strArray.Length;

                    string strMandatoryCodes = string.Empty;
                    string strCodes = string.Empty;

                    //Put code and its format into Hashtable.
                    Hashtable htCodeFormat = new Hashtable();

                    for (int nCount = 0; nCount <= nArrayCount - 1; nCount++)
                    {
                        string[] strTagFormat = strArray[nCount].Split(Constants.CHRPIPE);
                        htCodeFormat.Add(strTagFormat[0].ToString(), strTagFormat[1].ToString());
                        strCodes = strCodes + strTagFormat[0].ToString() + Constants.COMMA;
                    }

                    string strCodeExists = string.Empty;
                    foreach (XmlNode xNodeJ in xListJ)
                    {

                        strMandatoryCodes = valueMandatoryCodes;
                        strCodeExists = strCodes;

                        //Get the first child of Tag J
                        int nChildCount = xNodeJ.ChildNodes.Count;
                        XmlNode xNode = xNodeJ.FirstChild;

                        string strLine = xNode.InnerText;

                        //If the first character of first line does not starts with Slash then raise error
                        if (!strLine.StartsWith(Constants.SLASH))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                xNode.Name, strLine);
                            return false;
                        }

                        //If there are odd no. of slashes in first child of Tag J then throw error
                        if (CheckSlashes(strLine) == false)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                xNode.Name, strLine);
                            return false;
                        }

                        //Check for the next siblings of first child of Tag J and do the same operation.
                        //Join all the string value of each line of Tag J into one string variable
                        string strLine1 = string.Empty;

                        for (int nCount = 1; nCount <= nChildCount - 1; nCount++)
                        {
                            xNode = xNode.NextSibling;
                            strLine1 = xNode.InnerText;
                            if (CheckSlashes(strLine1) == false)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNode.Name, strLine1);
                                return false;
                            }

                            strLine = strLine + strLine1;
                        }

                        //Form a code-value pair of XML Document into two set of array variables
                        string[] strResult = strLine.Split(Constants.CHRSLASH);
                        int nResultCount = strResult.Length;

                        string[] strResultCodeArray = new string[nResultCount / 2];
                        string[] strResultValueArray = new string[nResultCount / 2];

                        int nResultCode = 0;
                        int nResultValue = 0;

                        for (int nCount = 1; nCount <= nResultCount - 1; nCount++)
                        {
                            if ((nCount % 2) != 0)
                            {
                                strResultCodeArray[nResultCode] = Constants.SLASH + strResult[nCount].ToString() + Constants.SLASH;

                                nResultCode++;
                            }
                            else
                            {
                                strResultValueArray[nResultValue] = strResult[nCount].ToString();
                                nResultValue++;
                            }
                        }

                        //Check if the input Mandatory codes ends with comma. If not, add comma at the end.
                        string strFormat = string.Empty;
                        if (!strMandatoryCodes.EndsWith(Constants.COMMA))
                        {
                            strMandatoryCodes = strMandatoryCodes.ToString() + Constants.COMMA;
                        }

                        //For each code of Xml document, check the corresponding format from Hash table
                        // Check the data type and max length of value of each code of xml doc
                        for (int nCount = 0; nCount <= strResultCodeArray.Length - 1; nCount++)
                        {

                            //Get the format of code from hash table
                            strFormat = GetFormatValue(htCodeFormat, strResultCodeArray[nCount]);


                            if (strFormat == string.Empty)
                            {
                                //Raise error if code in xml doc does not exist in hash table
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNodeJ.Name, strResultCodeArray[nCount]);
                                return false;
                            }

                            //check non-repititiveness of codes
                            if (strCodeExists.IndexOf(strResultCodeArray[nCount]) == -1)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNodeJ.Name, strResultCodeArray[nCount]);
                                return false;
                            }
                            else
                            {
                                string strCodeCheck = strResultCodeArray[nCount].ToString();

                                strCodeCheck = strCodeCheck + Constants.COMMA;

                                if (sortFlag == false)
                                {
                                    strCodeExists = strCodeExists.Replace(strCodeCheck, Constants.BLANK);
                                }
                                else
                                {
                                    int nPosition = strCodeExists.IndexOf(strCodeCheck, 0, strCodeExists.Length);
                                    strCodeExists = strCodeExists.Replace(strCodeExists.Substring(0, nPosition) + strCodeCheck, Constants.BLANK);
                                }

                            }

                            if (strResultCodeArray[nCount].CompareTo(Constants.CODENETS) != 0)
                            {

                                if (IsValidCodeFormatData(strResultValueArray[nCount], strFormat) == false)
                                {
                                    //Raise error if value of code does not satisfy the format.
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        strResultCodeArray[nCount], strResultValueArray[nCount]);
                                    return false;
                                }
                            }
                            else
                            {
                                if (strResultValueArray[nCount].Length != 0)
                                {
                                    //Raise error if value of code does not satisfy the format.
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        strResultCodeArray[nCount], strResultValueArray[nCount]);
                                    return false;
                                }
                            }


                            if (strMandatoryCodes.IndexOf(strResultCodeArray[nCount]) != -1)
                            {
                                //Remove code from Mandatory list of codes, if exist
                                strResultCodeArray[nCount] = strResultCodeArray[nCount].ToString() + Constants.COMMA;
                                strMandatoryCodes = strMandatoryCodes.Replace(strResultCodeArray[nCount], Constants.BLANK);
                            }
                        }

                        if (strMandatoryCodes.Length != 0)
                        {
                            //Raise error if Mandatory codes not exist in Xml doc code list.
                            errorObject.AddError(errorCode, policyName, ruleName,
                                xNodeJ.Name, strMandatoryCodes);
                            return false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }
        /// <method>
        /// 	IsValidPartyIdentificationCodes
        /// </method>
        /// <summary>
        ///     Added this method for Srg 2019
        ///		This method performs validation for Tag J(SwiftNetworkRuleT78). Following validations are taken care
        ///		- More than one code word may be used in a line. i.e. the maximum number of characters number of lines in a field, another code word may follow the previous code word format text field.
        ///		- The information relating to a code word may be split across lines.
        ///		- A code word itself must not be split across lines.
        ///		- the special character / is not allowed in any of the X, Y or Z character sets that is permitted to follow a code word. This exception is necessary because the character/ indicates always the beginning of a code word.
        ///		- a code word must not be duplicated within a field.
		///		- ABIC must not be the only code present for fields with option J
        ///
        /// </summary>
        /// <param name="xDocument">
        ///     Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTagJ">
        ///     Input reference of the element J to be validated.
        /// </param>
        /// <param name="valueCodesFormat">
        ///  	List of valid Codes-format pair separated by comma. Code and format should be separated by Pipe character.
        ///		for e.g /ABIC/|11c,/NAME/|34x,/USFW/|9!n,/USCH/|6!n
        /// </param>
        /// <param name="strCodeValues">
        ///  List of Codes sepatated by comma 
        /// for e.g., CLRD,NDFS,NETS,NONE,SSIS,UKWN
        /// </param>
        /// <param name="sortFlag">
        ///      Input containing either true or false. True indicates that code in the xDocument has to be in order.
        /// </param>
        /// <param name="errorCode">
        ///      Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///     Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///     Input containing the rule name.
        /// </param>
        /// <param name="errorObject">
        ///     Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns>
        ///     True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidPartyIdentificationCodes(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTagJ,
            string valueCodesFormat,
            string strCodeValues,
            bool sortFlag,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject
           )
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidPartyIdentificationCodes" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPathTagJ == null ||
                    valueCodesFormat == null ||
                    xPathTagJ.Length == 0 ||
                    valueCodesFormat.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListJ = xRoot.SelectNodes(xPathTagJ.ToString());

                //Check the existence of Tag J
                if (xListJ.Count != 0)
                {
                    //Split the Code-format pair into Array variable
                    string[] strArray = valueCodesFormat.Split(Constants.CHRCOMMA);
                    int nArrayCount = strArray.Length;

                    string strMandatoryCodes = string.Empty;
                    string strCodes = string.Empty;

                    //Put code and its format into Hashtable.
                    Hashtable htCodeFormat = new Hashtable();

                    for (int nCount = 0; nCount <= nArrayCount - 1; nCount++)
                    {
                        string[] strTagFormat = strArray[nCount].Split(Constants.CHRPIPE);
                        htCodeFormat.Add(strTagFormat[0].ToString(), strTagFormat[1].ToString());
                        strCodes = strCodes + strTagFormat[0].ToString() + Constants.COMMA;
                    }

                    string strCodeExists = string.Empty;
                    foreach (XmlNode xNodeJ in xListJ)
                    {
                        strCodeExists = strCodes;

                        //Get the first child of Tag J
                        int nChildCount = xNodeJ.ChildNodes.Count;
                        XmlNode xNode = xNodeJ.FirstChild;

                        string strLine = xNode.InnerText;

                        //If the first character of first line does not starts with Slash then raise error
                        if (!strLine.StartsWith(Constants.SLASH))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                xNode.Name, strLine);
                            return false;
                        }

                        //If there are odd no. of slashes in first child of Tag J then throw error
                        if (CheckSlashes(strLine) == false)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                xNode.Name, strLine);
                            return false;
                        }

                        //Check for the next siblings of first child of Tag J and do the same operation.
                        //Join all the string value of each line of Tag J into one string variable
                        string strLine1 = string.Empty;

                        for (int nCount = 1; nCount <= nChildCount - 1; nCount++)
                        {
                            xNode = xNode.NextSibling;
                            strLine1 = xNode.InnerText;
                            if (CheckSlashes(strLine1) == false)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNode.Name, strLine1);
                                return false;
                            }

                            strLine = strLine + strLine1;
                        }

                        //Form a code-value pair of XML Document into two set of array variables
                        string[] strResult = strLine.Split(Constants.CHRSLASH);
                        int nResultCount = strResult.Length;

                        string[] strResultCodeArray = new string[nResultCount / 2];
                        string[] strResultValueArray = new string[nResultCount / 2];

                        int nResultCode = 0;
                        int nResultValue = 0;

                        for (int nCount = 1; nCount <= nResultCount - 1; nCount++)
                        {
                            if ((nCount % 2) != 0)
                            {
                                strResultCodeArray[nResultCode] = Constants.SLASH + strResult[nCount].ToString() + Constants.SLASH;

                                nResultCode++;
                            }
                            else
                            {
                                strResultValueArray[nResultValue] = strResult[nCount].ToString();
                                nResultValue++;
                            }
                        }

                        //Check if the input Mandatory codes ends with comma. If not, add comma at the end.
                        string strFormat = string.Empty;
                        
                        //For each code of Xml document, check the corresponding format from Hash table
                        // Check the data type and max length of value of each code of xml doc
                        for (int nCount = 0; nCount <= strResultCodeArray.Length - 1; nCount++)
                        {

                            //Get the format of code from hash table
                            strFormat = GetFormatValue(htCodeFormat, strResultCodeArray[nCount]);


                            if (strFormat == string.Empty)
                            {
                                //Raise error if code in xml doc does not exist in hash table
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNodeJ.Name, strResultCodeArray[nCount]);
                                return false;
                            }

                            //check non-repititiveness of codes
                            if (strCodeExists.IndexOf(strResultCodeArray[nCount]) == -1)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNodeJ.Name, strResultCodeArray[nCount]);
                                return false;
                            }
                            else
                            {
                                string strCodeCheck = strResultCodeArray[nCount].ToString();

                                strCodeCheck = strCodeCheck + Constants.COMMA;

                                if (sortFlag == false)
                                {
                                    strCodeExists = strCodeExists.Replace(strCodeCheck, Constants.BLANK);
                                }
                                else
                                {
                                    int nPosition = strCodeExists.IndexOf(strCodeCheck, 0, strCodeExists.Length);
                                    strCodeExists = strCodeExists.Replace(strCodeExists.Substring(0, nPosition) + strCodeCheck, Constants.BLANK);
                                }

                            }

                            if (strResultCodeArray[nCount].CompareTo(Constants.CODENETS) != 0)
                            {

                                if (IsValidCodeFormatData(strResultValueArray[nCount], strFormat) == false)
                                {
                                    //Raise error if value of code does not satisfy the format.
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        strResultCodeArray[nCount], strResultValueArray[nCount]);
                                    return false;
                                }
                                else
                                {
                                    //For SVBY and NOSI code values
                                    if (!string.IsNullOrEmpty(strCodeValues) && (strResultCodeArray[nCount] == Constants.CODENOSI || strResultCodeArray[nCount] == Constants.CODESVBY))
                                    {
                                        string[] strArrayCodeValues = strCodeValues.Split(Constants.CHRCOMMA);
                                       if(!strArrayCodeValues.Contains(strResultValueArray[nCount]))
                                        {
                                            //Raise error if strCodeValues does not contains in the strResultValueArray
                                           errorObject.AddError(errorCode, policyName, ruleName,
                                            strResultCodeArray[nCount], strResultValueArray[nCount]); 
                                           return false;
                                       }  
                                    }  
									if(strResultCodeArray.Length == 1	&& strResultCodeArray[nCount] == Constants.CODEABIC)
									{
										//Raise T79 error if only ABIC is present
										errorObject.AddError(Constants.ERRORT79,Constants.SWIFTNETWORKRULET79,ruleName,
										strResultCodeArray[nCount], strResultValueArray[nCount]);
										return false;
									}
                                }
                            }
                            else
                            {
                                if (strResultValueArray[nCount].Length != 0)
                                {
                                    //Raise error if value of code does not satisfy the format.
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        strResultCodeArray[nCount], strResultValueArray[nCount]);
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        /// 	IsValidContactInformation
        /// </method>
        /// <summary>
        /// 	This method performs validation for tag 29A.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag29A">
        ///		Input reference of the element 29A to be validated.
        /// </param>
        /// <param name="valueCodeList">
        ///		Input containing the list of valid codes
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool IsValidContactInformation(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathTag29A,
        //    string valueCodeList,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{
        //    bool isValid = true;

        //    isValid = IsValidContactInformation2(xDocument,
        //                                    xPathTag29A,
        //                                    valueCodeList,
        //                                    errorCode,
        //                                    policyName,
        //                                    ruleName,
        //                                    errorObject);

        //    /*bool isValid = true;

        //    if(xDocument == null ||
        //        xPathTag29A == null ||
        //        valueCodeList == null ||
        //        xPathTag29A.Length == 0 ||
        //        valueCodeList.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    XmlNode xRoot = xDocument.Document;
        //    XmlNodeList xList29A = xRoot.SelectNodes(xPathTag29A.ToString());

        //    //Check the existence of Tag 29A
        //    if (xList29A.Count !=0)
        //    {

        //        //check for the code-list ending with comma. If it does not exist then add comma to it.
        //        if (!valueCodeList.EndsWith(Constants.COMMA))
        //        {
        //            valueCodeList = valueCodeList.ToString() + Constants.COMMA;
        //        }

        //        //Get the first child of Tag 29A
        //        int nChildCount = xList29A.Item(0).ChildNodes.Count;
        //        XmlNode xNode = xList29A.Item(0).FirstChild;

        //        //If there are odd no. of slashes in first child of Tag 29A then throw error
        //        string strLine = xNode.InnerText;

        //        //If the first character of first line does not starts with Slash then raise error
        //        if (!strLine.StartsWith(Constants.SLASH))
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                xNode.Name, strLine);
        //            return false;
        //        }

        //        if (CheckSlashes(strLine)==false)
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                xNode.Name, strLine);
        //            return false;
        //        }

        //        //Check for the next siblings of first child of Tag 29A and do the same operation.
        //        //Join all the string value of each line of Tag 29A into one string variable
        //        string strLine1 = string.Empty;

        //        for(int nCount = 1;nCount<= nChildCount - 1;nCount++)
        //        {
        //            xNode = xNode.NextSibling;
        //            strLine1 = xNode.InnerText;
        //            if (CheckSlashes(strLine1)==false)
        //            {
        //                errorObject.AddError(errorCode, policyName, ruleName,
        //                    xNode.Name, strLine1);
        //                return false;
        //            }

        //            strLine = strLine + strLine1;
        //        }


        //        //Check non-repetitiveness of the code
        //        string [] strResult = strLine.Split(Constants.CHRSLASH);
        //        int nResultCount = strResult.Length;

        //        string strDocCode = string.Empty;


        //        for(int nCount = 1;nCount<= nResultCount-1;nCount++)
        //        {
        //            if ((nCount%2)!=0)
        //            {
        //                strDocCode = Constants.SLASH + strResult[nCount].ToString()+ Constants.SLASH;

        //                if (valueCodeList.IndexOf(strDocCode)== -1)
        //                {
        //                    errorObject.AddError(errorCode, policyName, ruleName,
        //                        xNode.Name, strDocCode);
        //                    isValid = false;
        //                    break;
        //                }
        //                else
        //                {
        //                    //Remove code from Code list, if exist
        //                    strDocCode = strDocCode + Constants.COMMA;
        //                    valueCodeList=valueCodeList.Replace(strDocCode,Constants.BLANK);
        //                }
        //            }
        //        }
        //    }*/

        //    return isValid;
        //}

        /// <method>
        /// 	IsValidContactInformation2
        /// </method>
        /// <summary>
        /// 	This method performs validation for tag 29A.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag29A">
        ///		Input reference of the element 29A to be validated.
        /// </param>
        /// <param name="valueCodeList">
        ///		Input containing the list of valid codes
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //private static bool IsValidContactInformation2(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathTag29A,
        //    string valueCodeList,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{
        //    if (xDocument == null ||
        //        xPathTag29A == null ||
        //        valueCodeList == null ||
        //        xPathTag29A.Length == 0 ||
        //        valueCodeList.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    bool isValid = false;
        //    string data29A = null;
        //    string[] codeListArray = valueCodeList.Split(Constants.CHRCOMMA);

        //    XmlNode xRoot = xDocument.Document;
        //    XmlNodeList xList29A = xRoot.SelectNodes(xPathTag29A.ToString());
        //    int count = xList29A.Count;

        //    if (count > 0)
        //    {
        //        foreach (XmlNode xContactInfoNode in xList29A)
        //        {
        //            if (xContactInfoNode.HasChildNodes)
        //            {
        //                for (int i = 0; i < xContactInfoNode.ChildNodes.Count; i++)
        //                {
        //                    data29A += xContactInfoNode.ChildNodes[i].InnerText;
        //                }
        //            }

        //            // for each of the codes, lookup the string. Even if one of
        //            // the codes is found, we're golden - else add an error.
        //            for (int i = 0; i < codeListArray.Length; i++)
        //            {
        //                if (data29A.IndexOf(codeListArray[i]) != -1)
        //                    return true;
        //                else
        //                    continue;
        //            }

        //            if (!isValid)
        //            {
        //                errorObject.AddError(errorCode, policyName, ruleName, xPathTag29A, data29A);
        //                return false;
        //            }
        //        }
        //    }


        //    return isValid;
        //}

        /// <method>
        /// 	CheckSlashes
        /// </method>
        /// <summary>
        ///		This function returns true if the given data has even no. of slashes else false
        /// </summary>
        /// <param name="data">
        ///		input containing the data
        /// </param>
        /// <returns>
        ///		returns true if it has even no. of slashes else false.
        /// </returns>
        static bool CheckSlashes(string data)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckSlashes:");
            try
            {

                //Checks if the string is null
                if (data.Trim().Length < 1)
                    return false;

                //Splits the data by new line
                string[] dataArray = data.Split((char[])Environment.NewLine.ToCharArray());

                //Checks for number of slashes in each line
                for (int i = 0; i < dataArray.Length; i++)
                    if ((InString(dataArray[i], Constants.CHRSLASH) % 2) != 0)
                        return false;
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;
        }

        /// <method>
        /// 	GetFormatValue
        /// </method>
        /// <summary>
        ///		This function gets the format for the given code from hashtable
        /// </summary>
        /// <param name="htCodeFormat">
        ///		Input containing the hash table
        /// </param>
        /// <param name="strCode">
        ///		Input containing Code
        /// </param>
        /// <returns type = "boolean">
        ///		Format value for the input code if exist else it return blank value
        /// </returns>
        static string GetFormatValue(Hashtable htCodeFormat, string strCode)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function GetFormatValue:");
            try
            {
                if (!htCodeFormat.ContainsKey(strCode))
                    return string.Empty;

                IDictionaryEnumerator myEnumerator = htCodeFormat.GetEnumerator();

                while (myEnumerator.MoveNext())
                {
                    if (myEnumerator.Key.ToString().CompareTo(strCode) == 0)
                    {
                        return myEnumerator.Value.ToString();

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return string.Empty;
        }

        /// <method>
        /// 	IsValidCodeFormatData
        /// </method>
        /// <summary>
        ///		This function validates the value of code against the format given.
        /// </summary>
        /// <param name="strCodeValue">
        ///		input containing the code value
        /// </param>
        /// <param name="strFormat">
        ///		input containing format for the code
        /// </param>
        /// <returns>
        ///		returns true if Value of code satisfies the format else false
        /// </returns>
        static bool IsValidCodeFormatData(string strCodeValue, string strFormat)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCodeFormatData:");
            string strType = string.Empty;

            if (strFormat.Length == 7 && strFormat.Contains(Constants.ALPHAc) && strFormat.Contains(Constants.ALPHAn))
                strType = Constants.ALPHAcn;
            else if (strFormat.Length == 8 && strFormat.Contains(Constants.ALPHAa)&&strFormat.Contains(Constants.ALPHAx)) //Added to check 2!a[32x] for Srg 2019
                strType = Constants.ALPHAax; 
            else
                strType = strFormat.Substring(strFormat.Length - 1, 1);
            string strSWIFTtype = string.Empty;

            try
            {
                if (strType.CompareTo(Constants.ALPHAcn) == 0)
                {
                    Regex reg = new Regex(Constants.CNLEICPATTERN);
                    if (reg.IsMatch(strCodeValue))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                    
                }
                else if (strType.CompareTo(Constants.ALPHAax) == 0) //Added to check 2!a[32x]  for Srg 2019
                {
                    Regex clrcreg = new Regex(Constants.CLRCPATTERN);
                    if (clrcreg.IsMatch(strCodeValue))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    if (strType.CompareTo(Constants.ALPHAx) == 0)
                    {
                        strSWIFTtype = Constants.XPATTERN;
                    }
                    else if (strType.CompareTo(Constants.ALPHAn) == 0)
                    {
                        strSWIFTtype = Constants.NPATTERN;
                    }
                    else if (strType.CompareTo(Constants.ALPHAc) == 0)
                    {
                        strSWIFTtype = Constants.BICPATTERN;
                    }
                    else if (strType.CompareTo(Constants.ALPHAd) == 0)
                    {
                        strSWIFTtype = Constants.DPATTERN;
                    }
                    else if (strType.CompareTo(Constants.ALPHAa) == 0) //Added to check 4!a type  for Srg 2019
                    {
                        strSWIFTtype = Constants.ALPHAaPATTERN;
                    }

                    Regex reg = new Regex(strSWIFTtype);
                    if (reg.IsMatch(strCodeValue))
                    {
                        string strFixed = strFormat.Substring(strFormat.Length - 2, 1);
                        string strLength = string.Empty;
                        if (strFixed.CompareTo(Constants.EXCLAMATION) == 0)
                        {
                            strLength = strFormat.Substring(0, strFormat.Length - 2);
                            if (strCodeValue.Length != Convert.ToInt32(strLength, CultureInfo.InvariantCulture))
                                return false;
                        }
                        else
                        {
                            strLength = strFormat.Substring(0, strFormat.Length - 1);
                            if ((strCodeValue.Length == 0) ||
                                (strCodeValue.Length > Convert.ToInt32(strLength, CultureInfo.InvariantCulture)))
                                return false;
                        }
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


        }

        /// <method>
        /// 	InString
        /// </method>
        /// <summary>
        ///		The function gives the no. of slashes in a string
        /// </summary>
        /// <param name="string1">
        ///		Input containing the string value
        /// </param>
        /// <param name="char1">
        ///		Input containing the delimiter (slash)
        /// </param>
        /// <returns>
        ///		It returns no. of occurence of slashes in a given string
        /// </returns>
        static int InString(string string1, char char1)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function InString:");
            int occurence = 0;
            try
            {
                for (int i = 0; i < string1.Length; i++)
                    if (string1[i].Equals(char1))
                        occurence++;
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return occurence;
        }

        /// <method>
        ///		SWIFTNetworkRule75
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 75.
        ///		If field 23E is present in sequence A and contains RFDD
        ///		then field 23E must be present in all occurrences of sequence B.
        ///		If field 23E is present in sequence A and does not contain
        ///		RFDD then field 23E must not be present in any occurrence of
        ///		sequence B. If field 23E is	not present in sequence A then field
        ///		23E must be present in all occurrences of sequence B.
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSeqATag23E" type = "string">
        ///		Input reference of the element 23E in Sequence A.
        ///	</param>
        /// <param name="valueTag23EType" type = "string">
        ///		Reference containing the qualifier.
        ///	</param>
        /// <param name="xPathSequenceB" type = "string">
        ///		Input reference of the Sequence B.
        ///	</param>
        /// <param name="xPathSeqBTag23E" type = "string">
        ///		Input reference of the element 23E in Sequence B.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule75(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSeqATag23E,
            string valueTag23EType,
            string xPathSequenceB,
            string xPathSeqBTag23E,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule75" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSeqATag23E == null ||
                    valueTag23EType == null ||
                    xPathSequenceB == null ||
                    xPathSeqBTag23E == null ||
                    xPathSeqATag23E.Length == 0 ||
                    valueTag23EType.Length == 0 ||
                    xPathSequenceB.Length == 0 ||
                    xPathSeqBTag23E.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList23E = xRoot.SelectNodes(xPathSeqATag23E);
                XmlNodeList xListSeqB = xRoot.SelectNodes(xPathSequenceB);
                if (xList23E.Count != 0)
                {
                    if (xList23E.Item(0).FirstChild.InnerText.CompareTo(valueTag23EType) == 0)
                    {
                        // Condition 1
                        foreach (XmlNode xNode in xListSeqB)
                        {
                            if (xNode.SelectSingleNode(xPathSeqBTag23E) == null)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    messageType, conditionalRuleName,
                                    conditionalRuleNumber);
                                isValid = false;
                                break;
                            }
                        }
                    }
                    else
                    {
                        // Condition 2
                        foreach (XmlNode xNode in xListSeqB)
                        {
                            if (xNode.SelectSingleNode(xPathSeqBTag23E) !=
                                null)
                            {
                                errorObject.AddError(errorCode, policyName,
                                    ruleName, messageType, conditionalRuleName,
                                    conditionalRuleNumber);
                                isValid = false;
                                break;
                            }
                        }
                    }
                }
                else
                {
                    // Condition 3
                    foreach (XmlNode xNode in xListSeqB)
                    {
                        if (xNode.SelectSingleNode(xPathSeqBTag23E) == null)
                        {
                            errorObject.AddError(errorCode, policyName,
                                ruleName, messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            isValid = false;
                            break;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	SWIFTNetworkRule76
        /// </method>
        /// <summary>
        ///		Field 50a (option A or K), must be present in either sequence A
        ///		(index 8) or in each occurrence of sequence B (index 21), but
        ///		must never be present in both sequences, nor be absent from
        ///		both sequences.
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequenceB" type = "string">
        ///		Input reference of the SequenceB.
        ///	</param>
        /// <param name="xPathNonRepetitiveFieldSequenceA" type = "string">
        ///		Input reference of the elements in SequenceA.
        /// </param>
        /// <param name="xPathNonRepetitiveFieldSequenceB" type = "string">
        ///		Input reference of the elements in SequenceB.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule76(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathNonRepetitiveFieldSequenceA,
            string xPathNonRepetitiveFieldSequenceB,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule76" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceB == null ||
                    xPathNonRepetitiveFieldSequenceA == null ||
                    xPathNonRepetitiveFieldSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPathNonRepetitiveFieldSequenceA.Length == 0 ||
                    xPathNonRepetitiveFieldSequenceB.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                bool isNodeA = false;
                bool isNodeB = false;
                XmlNode xRoot = xDocument.Document;

                // If multiple parameters passed Collect list of parameters
                // in sequence A
                string[] arrNonRepetitiveFieldSequenceA =
                    xPathNonRepetitiveFieldSequenceA.Split
                    (Constants.COMMA.ToCharArray());

                // If multiple parameters passed Collect list of parameters
                // in sequence B
                XmlNodeList xListB = xRoot.SelectNodes(xPathSequenceB);
                string[] arrNonRepetitiveFieldSequenceB =
                    xPathNonRepetitiveFieldSequenceB.Split
                    (Constants.COMMA.ToCharArray());

                // Checking for sequence A
                foreach (string NonRepetitiveField in
                    arrNonRepetitiveFieldSequenceA)
                {
                    XmlNode xNode_A = xRoot.SelectSingleNode
                        (NonRepetitiveField);
                    if (xNode_A != null)
                    {
                        Console.WriteLine(xNode_A.Name.ToString());
                        isNodeA = true;
                        break;
                    }
                }
                // Checking for sequence B
                foreach (XmlNode xNodeB in xListB)
                {
                    isNodeB = false;
                    foreach (string NonRepetitiveField in
                        arrNonRepetitiveFieldSequenceB)
                    {
                        XmlNode xNode_B = xNodeB.SelectSingleNode
                            (NonRepetitiveField);
                        if (xNode_B != null)
                        {
                            Console.WriteLine(xNode_B.Name.ToString());
                            isNodeB = true;
                            break;
                        }

                    }
                    if ((isNodeA && isNodeB) ||
                        (!isNodeA && !isNodeB))
                    {
                        errorObject.AddError(errorCode, policyName,
                            ruleName, messageType, conditionalRuleName,
                            conditionalRuleNumber);
                        isValid = false;
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule82
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 82.
        ///		In sequence A, if field 23E is present and contains RTND
        ///		then field 72 must be present, in all other cases
        ///		i.e. field 23E not present, or field 23E does not contain
        ///		RTND) field 72 is not allowed.
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag23E" type = "string">
        ///		Input reference of the element 23E in Sequence A.
        ///	</param>
        /// <param name="valueTag23EType" type = "string">
        ///		Reference containing the qualifier.
        ///	</param>
        /// <param name="xPathTag72" type = "string">
        ///		Input reference of the element 72 in Sequence A.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule82(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag23E,
            string valueTag23EType,
            string xPathTag72,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule82" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag23E == null ||
                    valueTag23EType == null ||
                    xPathTag72 == null ||
                    xPathTag23E.Length == 0 ||
                    valueTag23EType.Length == 0 ||
                    xPathTag72.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                // Get the Tag23E node
                XmlNodeList xList23E = xRoot.SelectNodes(xPathTag23E);
                // Get the Tag72 node
                XmlNodeList xList72 = xRoot.SelectNodes(xPathTag72);

                if (xList23E.Count != 0)
                {
                    if (xList23E.Item(0).FirstChild.InnerText.CompareTo(valueTag23EType) == 0)
                    {
                        // Condition 1
                        // If Tag 23E is present and value is in code list
                        // and Tag72 is not present then it is invalid
                        if (xList72.Count == 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                    else
                    {
                        // Condition 2
                        // If Tag 23E is present and value not in code list
                        // and Tag72 is present then it is invalid
                        if (xList72.Count != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
                else
                {
                    // Condition 3
                    // If Tag 23E is not present and Tag72 is present
                    // then it is invalid
                    if (xList72.Count != 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule179
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 179.
        ///		If field 71F is present in one or more occurrence of Sequence B,
        ///		then it must also be present in Sequence C,
        ///		and vice-versa {Error Code D79}:
        ///		If field 71G is present in one or more occurrence of Sequence B,
        ///		then it must also be present in Sequence C, and vice-versa
        ///		{Error Code D79}:
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSeqBSendRcvChargesTag" type = "string">
        ///		Input reference of the element SendRcvCharges in Sequence B.
        ///	</param>
        /// <param name="xPathSeqCSendRcvChargesTag" type = "string">
        ///		Input reference of the element SendRcvCharges in Sequence C.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will
        ///		be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule179(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSeqBSendRcvChargesTag,
            string xPathSeqCSendRcvChargesTag,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule179" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSeqBSendRcvChargesTag == null ||
                    xPathSeqCSendRcvChargesTag == null ||
                    xPathSeqBSendRcvChargesTag.Length == 0 ||
                    xPathSeqCSendRcvChargesTag.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                bool isPresentSeqBSendRcvChargesTag = false;
                bool isPresentSeqCSendRcvChargesTag = false;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSeqB =
                    xRoot.SelectNodes(xPathSeqBSendRcvChargesTag);
                XmlNodeList xListSeqC =
                    xRoot.SelectNodes(xPathSeqCSendRcvChargesTag);

                if (xListSeqB != null && xListSeqB.Count != 0)
                    isPresentSeqBSendRcvChargesTag = true;

                if (xListSeqC != null && xListSeqC.Count != 0)
                    isPresentSeqCSendRcvChargesTag = true;

                if (isPresentSeqCSendRcvChargesTag ^
                    isPresentSeqBSendRcvChargesTag)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType,
                        conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule175
        /// </method>
        /// <summary>
        ///		In Sequence B, If field 33B is present and the currency code is
        ///		different from the currency code in field 32A, field 36 must be
        ///		present,otherwise field 36 is not allowed (Error code(s): D75).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequenceB" type = "string">
        ///		Input reference of the Sequence B.
        ///	</param>
        /// <param name ="xPath32B" type = "string">
        ///		Input reference of the Element 32A.
        /// </param>
        /// <param name ="xPath33B" type = "string">
        ///		Input reference of the Element 33B.
        /// </param>
        /// <param name ="xPath36" type = "string">
        ///		Input reference of the Element 36.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be
        ///		added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule175(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPath32B,
            string xPath33B,
            string xPath36,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule175" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPath32B == null ||
                    xPath32B.Length == 0 ||
                    xPath33B == null ||
                    xPath33B.Length == 0 ||
                    xPath36 == null ||
                    xPath36.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListB = xRoot.SelectNodes(xPathSequenceB);
                // Checking for sequence B
                foreach (XmlNode xNodeB in xListB)
                {
                    // Select the Currency element of Tag 33B
                    XmlNode xNode33B = xNodeB.SelectSingleNode(xPath33B);
                    // Select the Currency element of Tag 32B
                    XmlNode xNode32B = xNodeB.SelectSingleNode(xPath32B);
                    // Select the Tag 36
                    XmlNode xNode36 = xNodeB.SelectSingleNode(xPath36);

                    //Check if Tag 33B is present
                    if (xNode33B != null)
                    {
                        if (xNode32B != null)
                        {
                            // If Currency Codes are equal and Tag 36 is present
                            // (or) If Currency Codes are not equal and Tag 36
                            // is not present, throw an error
                            if ((xNode33B.InnerText.CompareTo(xNode32B.InnerText) == 0 &&
                                xNode36 != null) ||
                                (xNode33B.InnerText.CompareTo(xNode32B.InnerText) != 0 &&
                                xNode36 == null))
                            {
                                errorObject.AddError(errorCode, policyName,
                                    ruleName, messageType, conditionalRuleName,
                                    conditionalRuleNumber);
                                isValid = false;
                                break;
                            }
                        }
                    }
                    else
                    {
                        //If Tag 33B is not present and Tag 36 is present,
                        // throw an error
                        if (xNode36 != null)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            isValid = false;
                            break;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule96
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 96.
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSeqATag23E" type = "string">
        ///		Input reference of the element 23E in Sequence A.
        ///	</param>
        /// <param name="valueTag23EType" type = "string">
        ///		Reference containing the qualifier.
        ///	</param>
        ///	<param name="xPathSeqATag21R" type = "string">
        ///		Input reference of the element 21R in Sequence A.
        /// </param>
        ///	<param name="xPathSeqBNotAllowedTags" type = "string">
        ///		Comma deliemted SequenceB Tags from root node.
        /// </param>
        /// <param name="xPathSequenceC" type = "string">
        ///		Input reference of the Sequence C.
        ///	</param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will
        ///		be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule96(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSeqATag23E,
            string valueTag23EType,
            string xPathSeqATag21R,
            string xPathSeqBNotAllowedTags,
            string xPathSequenceC,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule96" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSeqATag23E == null ||
                    valueTag23EType == null ||
                    xPathSequenceC == null ||
                    xPathSeqATag21R == null ||
                    xPathSeqBNotAllowedTags == null ||
                    xPathSeqATag23E.Length == 0 ||
                    valueTag23EType.Length == 0 ||
                    xPathSequenceC.Length == 0 ||
                    xPathSeqATag21R.Length == 0 ||
                    xPathSeqBNotAllowedTags.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                string[] arrSeqBNotAllowedTags =
                    xPathSeqBNotAllowedTags.Split
                    (Constants.COMMA.ToCharArray());
                XmlNodeList xListSeqC = xRoot.SelectNodes(xPathSequenceC);

                if (xRoot.SelectSingleNode(xPathSeqATag23E) == null ||
                    xRoot.SelectSingleNode(xPathSeqATag23E).InnerText.CompareTo(valueTag23EType) != 0
                    )
                {
                    // Condition 2 & Condtion 3
                    // If SeqA23E is (not present or present and not equals the
                    // code) then SeqA_21R is not allowed and SeqC is mandatory
                    if ((xRoot.SelectSingleNode(xPathSeqATag21R) != null) ||
                        (xRoot.SelectSingleNode(xPathSequenceC) == null))
                    {
                        errorObject.AddError(errorCode, policyName,
                            ruleName, messageType, conditionalRuleName,
                            conditionalRuleNumber);
                        isValid = false;
                    }

                }
                else
                {
                    bool isSeqBNotAllowedTagsPresent = false;
                    foreach (string notAllowedTag in arrSeqBNotAllowedTags)
                    {
                        if (xRoot.SelectNodes(notAllowedTag).Count != 0)
                        {
                            isSeqBNotAllowedTagsPresent = true;
                            break;
                        }
                    }
                    // Condition 1
                    if ((xRoot.SelectSingleNode(xPathSequenceC) != null) ||
                        isSeqBNotAllowedTagsPresent
                        )
                    {
                        errorObject.AddError(errorCode, policyName,
                            ruleName, messageType, conditionalRuleName,
                            conditionalRuleNumber);
                        isValid = false;
                    }


                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule94
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 94.
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xHeaderDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml Header document to be validated.
        /// </param>
        /// <param name="xPathSeqATag23E" type = "string">
        ///		Input reference of the element 23E in Sequence A.
        ///	</param>
        /// <param name="valueTag23EType" type = "string">
        ///		Reference containing the qualifier.
        ///	</param>
        ///	<param name="xPathHeaderTag119" type = "string">
        ///		Input reference of the element 119 in Header.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule94(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            Microsoft.RuleEngine.TypedXmlDocument xHeaderDocument,
            string xPathSeqATag23E,
            string valueTag23EType,
            string xPathHeaderTag119,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule94" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xHeaderDocument == null ||
                    xPathSeqATag23E == null ||
                    valueTag23EType == null ||
                    xPathHeaderTag119 == null ||
                    xPathSeqATag23E.Length == 0 ||
                    valueTag23EType.Length == 0 ||
                    xPathHeaderTag119.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNode xHeader = xHeaderDocument.Document;

                if (xRoot.SelectSingleNode(xPathSeqATag23E) == null ||
                    xRoot.SelectSingleNode(xPathSeqATag23E).InnerText.CompareTo(valueTag23EType) != 0
                    )
                {
                    // Condition 2 & Condition 3
                    // If SeqA23E is (not present or present and not equals the
                    // code) then Tag119 is not allowed in Header
                    if ((xHeader.SelectSingleNode(xPathHeaderTag119) != null))
                    {
                        errorObject.AddError(errorCode, policyName,
                            ruleName, messageType, conditionalRuleName,
                            conditionalRuleNumber);
                        isValid = false;
                    }
                }
                else
                {
                    XmlNode xHeaderTag119 =
                        xHeader.SelectSingleNode(xPathHeaderTag119);
                    if ((xHeaderTag119 == null) ||
                        (xHeaderTag119.InnerText.CompareTo(valueTag23EType) != 0))
                    {
                        errorObject.AddError(errorCode, policyName,
                            ruleName, messageType, conditionalRuleName,
                            conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule181
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 181.
        ///		Subfield 2 of field 23E is only allowed when subfield 1
        ///		of this field consists of OTHR(TypeCodetoCompare).
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence" type = "string">
        ///		Input reference of the Sequence.
        ///	</param>
        /// <param name="xPathTag23E" type = "string">
        ///		Input reference of the element 23E in Sequence.
        /// </param>
        /// <param name="typeCodeToCompare" type = "string">
        ///		Code Value to compare.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be
        ///		added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule181(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag23E,
            string typeCodeToCompare,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule181" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathTag23E == null ||
                    typeCodeToCompare == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag23E.Length == 0 ||
                    typeCodeToCompare.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSeqB = xRoot.SelectNodes(xPathSequence);
                // Get the Tag23E node
                XmlNodeList xList23E = xRoot.SelectNodes(
                    xPathTag23E.Replace(Constants.XPATH,
                    Constants.DOUBLESLASH));

                if (xList23E != null && xList23E.Count != 0)
                {
                    foreach (XmlNode xNode in xListSeqB)
                    {
                        // Get the Tag23E from the Sequence
                        XmlNode xNode23E =
                            xNode.SelectSingleNode(xPathTag23E);
                        // Check if 23E tag is present and it has additional
                        // info
                        if (xNode23E != null && xNode23E.ChildNodes.Count > 1)
                        {
                            if (typeCodeToCompare.IndexOf
                                (xNode23E.FirstChild.InnerText) == -1)
                            {
                                errorObject.AddError(errorCode, policyName,
                                    ruleName, messageType, conditionalRuleName,
                                    conditionalRuleNumber);
                                isValid = false;
                                break;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	SWIFTNetworkRule34
        /// </method>
        /// <summary>
        /// 	This function performs Network Rule 34 Validation which ensures that either
        /// 	sequence B3 or Sequence B4 must be present but not both in each occurrence of SequenceB.
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPathSequence1" type = "string">
        /// 	Input containing the xpathSequence data to identify //SequenceB
        /// </param>
        /// <param name="xPathSequence2" type = "string">
        /// 	Input containing the xpathSequence data to identify repetitive sequences SubSequenceB3 and
        /// 	 SubSequenceB4
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Input containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Input containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule34(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence1,
            string xPathSequence2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule34" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence1 == null ||
                    xPathSequence1.Length == 0 ||
                    xPathSequence2 == null ||
                    xPathSequence2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                bool isPresent = false;

                string[] arrxPath = xPathSequence2.Split(Constants.CHRCOMMA);
                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence1);

                foreach (XmlNode xNode in xListSequence)
                {
                    isPresent = false;
                    for (int i = 0; i < arrxPath.Length; i++)
                    {
                        if (xNode.SelectNodes(arrxPath[i]).Count != 0)
                        {
                            if (isPresent == true)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                            else
                            {
                                isPresent = true;
                            }
                        }
                    }
                    if (isPresent == false)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///			SWIFTSRG2001NetworkRule112
        /// </method>
        /// <summary>
        /// 	This function performs Conditional Rule D12 Validation(for messages MT572) which ensures that , field 83a must be present in either SequenceA or
        /// 	every occurrence of the repetitive sequence B
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPathSequenceA">
        ///		Input containing the xpath of Sequence A
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Input containing the xpath of Sequence B
        /// </param>
        /// <param name="xPathSequenceA83a">
        ///		Input containing the xpath of Tag 83A,83C,83D of Sequence A
        /// </param>
        /// <param name="xPathSequenceB83a">
        ///		Input containing the xpath of Tag 83A,83C,83D of Sequence B
        /// </param>
        /// <param name="xPathCheckRepetitive">
        ///		Input containing the xpath of Field to identify the inner repetitive sequence
        ///		For Message MT572, It is Field 60B of Sequence B
        ///		For Message MT573, It is Field 20 of Sequence B
        ///		For Message MT573, It is Field 20 of Sequence C
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Multiple Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Inutput containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule112(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequenceA,
        //    string xPathSequenceB,
        //    string xPathSequenceA83a,
        //    string xPathSequenceB83a,
        //    string xPathCheckRepetitive,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{

        //    if(xDocument == null ||
        //        xPathSequenceA == null ||
        //        xPathSequenceA.Length == 0 ||
        //        xPathSequenceB == null ||
        //        xPathSequenceB.Length == 0 ||
        //        xPathSequenceA83a == null ||
        //        xPathSequenceA83a.Length == 0 ||
        //        xPathSequenceB83a == null ||
        //        xPathSequenceB83a.Length == 0 ||
        //        xPathCheckRepetitive == null ||
        //        xPathCheckRepetitive.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    else
        //    {
        //        if (null == conditionalRuleName) throw new ArgumentNullException("conditionalRuleName");

        //        bool isValid = true;
        //        int nCount83a = 0;
        //        int nCountCheckRepetitiveField =0;
        //        bool isFoundSequenceA = false;
        //        bool isFoundSequenceB = false;
        //        bool isPairMatch = false;
        //        int nCount83aSequenceB = 0;

        //        XmlNode xRoot = xDocument.Document;

        //        // Split string based on ","
        //        string [] xPathSequenceA83aList = xPathSequenceA83a.Split(Constants.COMMA.ToCharArray());
        //        string [] xPathSequenceB83aList = xPathSequenceB83a.Split(Constants.COMMA.ToCharArray());

        //        //Multiple Conditional Rules C1,C2
        //        string [] xConditionalRuleNameList = conditionalRuleName.Split(Constants.COMMA.ToCharArray());

        //        //Select Node Sequence A
        //        XmlNode xNodeSequenceA = xRoot.SelectSingleNode(xPathSequenceA);
        //        //Select Nodes Sequence B
        //        XmlNodeList xListSequenceB = xRoot.SelectNodes(xPathSequenceB);

        //        //loop to check if 83a is present in sequence A
        //        //begin loop
        //        foreach(string xPathA83a in xPathSequenceA83aList)
        //        {
        //            if(!(isFoundSequenceA))
        //            {
        //                XmlNode xNodeSequenceA83a = xNodeSequenceA.SelectSingleNode(xPathA83a);
        //                if(xNodeSequenceA83a != null && xNodeSequenceA83a.InnerText != null && xNodeSequenceA83a.InnerText.Length != 0)
        //                    isFoundSequenceA = true;
        //            }
        //        }
        //        //end loop

        //        //loop to check if 83a is present in sequence B

        //        if(xListSequenceB.Count != 0)
        //        {
        //            //begin outer loop for Sequence B
        //            foreach (XmlNode xNodeSequenceB in xListSequenceB)
        //            {
        //                //begin inner loop for Tag 83a
        //                foreach(string xPathB83a in xPathSequenceB83aList)
        //                {
        //                    XmlNodeList xListSequenceB83a = xNodeSequenceB.SelectNodes(xPathB83a);
        //                    if(xListSequenceB83a.Count!=0)
        //                    {
        //                        foreach(XmlNode xNodeSequenceB83a in xListSequenceB83a)
        //                        {
        //                            if(xNodeSequenceB83a.InnerText != null && xNodeSequenceB83a.InnerText.Length != 0)
        //                            {
        //                                nCount83a++;
        //                            }
        //                        }
        //                    }
        //                }
        //                //end inner loop

        //                //Is 83a in sequence B found
        //                if(nCount83a != 0)
        //                {
        //                    isFoundSequenceB = true;
        //                    nCount83aSequenceB++;
        //                }
        //                if(isFoundSequenceB)
        //                {
        //                    XmlNodeList xListCheckRepetitive = xNodeSequenceB.SelectNodes(xPathCheckRepetitive);
        //                    if(xListCheckRepetitive.Count!=0)
        //                    {
        //                        foreach(XmlNode xNodeCheckRepetitive in xListCheckRepetitive)
        //                        {
        //                            if(xNodeCheckRepetitive.InnerText != null && xNodeCheckRepetitive.InnerText.Length != 0)
        //                            {
        //                                nCountCheckRepetitiveField++;
        //                                foreach(string xPath in xPathSequenceB83aList)
        //                                {
        //                                    if(xNodeCheckRepetitive.PreviousSibling.Name.CompareTo(xPath.Substring(2))==0)
        //                                        isPairMatch = true;
        //                                }
        //                            }
        //                        }
        //                    }
        //                    if(nCountCheckRepetitiveField != 0)
        //                    {
        //                        if(nCountCheckRepetitiveField > nCount83a)
        //                        {
        //                            errorObject.AddError(errorCode,policyName,ruleName,messageType,xConditionalRuleNameList[1],conditionalRuleNumber);
        //                            isValid = false;

        //                        }
        //                        else if((nCountCheckRepetitiveField.CompareTo(nCount83a) == 0)&& (!(isPairMatch)))
        //                        {
        //                            errorObject.AddError(errorCode,policyName,ruleName,messageType,xConditionalRuleNameList[1],conditionalRuleNumber);
        //                            isValid = false;

        //                        }
        //                    }
        //                }
        //                if(!(isFoundSequenceA) && !(isFoundSequenceB))
        //                {
        //                    errorObject.AddError(errorCode,policyName,ruleName,messageType,xConditionalRuleNameList[0],conditionalRuleNumber);
        //                    isValid = false;
        //                }
        //                else if((nCount83aSequenceB > 0) && !(isFoundSequenceB))
        //                {
        //                    errorObject.AddError(errorCode,policyName,ruleName,messageType,xConditionalRuleNameList[0],conditionalRuleNumber);
        //                    isValid = false;
        //                }

        //                nCount83a = 0;
        //                nCountCheckRepetitiveField = 0;
        //                isPairMatch = false;
        //                isFoundSequenceB = false;
        //            }
        //            //end outer loop
        //        }
        //        else
        //        {
        //            //Then Sequence A must have the 83a Field
        //            if(!(isFoundSequenceA))
        //            {
        //                errorObject.AddError(errorCode,policyName,ruleName,messageType,xConditionalRuleNameList[0],conditionalRuleNumber);
        //                isValid = false;

        //            }

        //        }
        //        return isValid;
        //    }

        //}

        /// <method>
        /// 	SWIFTNetworkRule121
        /// </method>
        /// <summary>
        /// 	In each occurrence of sequence B, if field 33B is present, then the currency code or the amount, or both, must be different
        /// 	between fields 33B and 32B(Error code(s): D21)
        /// </summary>
        /// <param name="xDocument">
        /// 	parameter value for xDocument
        /// </param>
        /// <param name="xPathSequenceB">
        /// 	parameter value for repetitive sequence B
        /// </param>
        /// <param name="xPathNonRepetitiveFieldSequenceB">
        /// 	parameter value for field in seq B separated by comma
        /// </param>
        /// <param name="errorCode">
        /// 	parameter for error code
        /// </param>
        /// <param name="policyName">
        /// 	parameter for policy name
        /// </param>
        /// <param name="ruleName">
        /// 	parameter for rule name
        /// </param>
        /// <param name="messageType">
        /// 	parameter for message type
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	parameter for conditional rulename
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	parameter for conditional rulenumber
        /// </param>
        /// <param name="errorObject">
        /// 	parameter for error object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool SWIFTNetworkRule121(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathNonRepetitiveFieldSequenceB,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule121" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xDocument) throw new ArgumentNullException("xDocument");
                if (null == errorObject) throw new ArgumentNullException("errorObject");
                if (null == xPathSequenceB) throw new ArgumentNullException("xPathSequenceB");
                if (null == xPathNonRepetitiveFieldSequenceB) throw new ArgumentNullException("xPathNonRepetitiveFieldSequenceB");


                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListB = xRoot.SelectNodes(xPathSequenceB.ToString());
                // Sequence B 32B and 33B
                string[] arrNonRepetitiveFieldSequenceB = xPathNonRepetitiveFieldSequenceB.Split(Constants.COMMA.ToCharArray());


                foreach (XmlNode xNodeB in xListB)
                {
                    XmlNode xNode_A = xNodeB.SelectSingleNode(arrNonRepetitiveFieldSequenceB[0].ToString());
                    if (xNode_A != null)
                    {
                        XmlNode xNode_B = xNodeB.SelectSingleNode(arrNonRepetitiveFieldSequenceB[1].ToString());
                        if (xNode_B != null)
                        {
                            //check currency or currency code or both are different

                            if ((xNode_A.FirstChild.InnerText.ToString().CompareTo(xNode_B.FirstChild.InnerText.ToString()) == 0) &&
                                (Convert.ToDecimal((xNode_A.LastChild.InnerText.Replace(Constants.COMMA, decimalSeparator)), CultureInfo.InvariantCulture))
                                == (Convert.ToDecimal((xNode_B.LastChild.InnerText.Replace(Constants.COMMA, decimalSeparator)), CultureInfo.InvariantCulture)))
                            {
                                isValid = false;
                                errorObject.AddError(errorCode, policyName,
                                    ruleName, messageType, conditionalRuleName,
                                    conditionalRuleNumber);
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	SWIFTNetworkRule173
        /// </method>
        /// <summary>
        /// 	When present in sequence A, fields 21E, 26T, 77B, 71A, 52a and 50a (option C or L) must,
        /// 	independently of each other, not be present in any occurrence of sequence B.
        /// 	When present in one or more occurrences of sequence B, fields 21E, 26T, 77B, 71A, 52a and 50a (option C or L)
        /// 	must not be present in sequence A (Error code(s): D73):
        /// </summary>
        /// <param name="xDocument">
        /// Parameter for TypedXmlDocument xDocument
        /// </param>
        /// <param name="xPathSequenceA">
        /// Parameter value for xpath of sequence A
        /// </param>
        /// <param name="xPathSequenceB">
        /// Parameter value for xpath of sequence B
        /// </param>
        /// <param name="xPathNonRepetitiveFieldSequenceA">
        /// parameter values for xpath of tag in sequence A
        /// </param>
        /// <param name="xPathNonRepetitiveFieldSequenceB">
        /// parameter values for xpath of tag in sequence B
        /// </param>
        /// <param name="errorCode">
        /// paramter value for errorCode
        /// </param>
        /// <param name="policyName">
        /// parameter value for policy name
        /// </param>
        /// <param name="ruleName">
        /// parameter value for rule name
        /// </param>
        /// <param name="messageType">
        /// parameter value for messagetype
        /// </param>
        /// <param name="conditionalRuleName">
        /// parameter value for conditional rule name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// parameter value for contitional rule number
        /// </param>
        /// <param name="errorObject">
        /// parameter for error object
        /// </param>
        /// <returns></returns>

        public static bool SWIFTNetworkRule173(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceA,
            string xPathSequenceB,
            string xPathNonRepetitiveFieldSequenceA,
            string xPathNonRepetitiveFieldSequenceB,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule173" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xDocument) throw new ArgumentNullException("xDocument");
                if (null == errorObject) throw new ArgumentNullException("errorObject");
                if (null == xPathNonRepetitiveFieldSequenceB) throw new ArgumentNullException("xPathNonRepetitiveFieldSequenceB");
                if (null == xPathNonRepetitiveFieldSequenceA) throw new ArgumentNullException("xPathNonRepetitiveFieldSequenceA");
                if (null == xPathSequenceA) throw new ArgumentNullException("xPathSequenceA");
                if (null == xPathSequenceB) throw new ArgumentNullException("xPathSequenceB");


                bool isNodeA = false;
                bool isNodeB = false;

                XmlNode xRoot = xDocument.Document;

                // If multiple parameters passed Collect list of parameters in sequence A
                XmlNodeList xListA = xRoot.SelectNodes(xPathSequenceA.ToString());
                string[] arrNonRepetitiveFieldSequenceA = xPathNonRepetitiveFieldSequenceA.Split(Constants.COMMA.ToCharArray());

                // If multiple parameters passed Collect list of parameters in sequence B
                XmlNodeList xListB = xRoot.SelectNodes(xPathSequenceB.ToString());
                string[] arrNonRepetitiveFieldSequenceB = xPathNonRepetitiveFieldSequenceB.Split(Constants.COMMA.ToCharArray());

                // Checking for sequence A
                foreach (XmlNode xNodeA in xListA)
                {
                    for (int i = 0; i < arrNonRepetitiveFieldSequenceA.Length; i++)
                    {
                        XmlNode xNode_A = xNodeA.SelectSingleNode(arrNonRepetitiveFieldSequenceA[i].ToString());
                        if (xNode_A != null)
                        {
                            isNodeA = true;
                            break;
                        }
                    }
                }

                // Checking for sequence B
                foreach (XmlNode xNodeB in xListB)
                {
                    for (int i = 0; i < arrNonRepetitiveFieldSequenceB.Length; i++)
                    {
                        XmlNode xNode_B = xNodeB.SelectSingleNode(arrNonRepetitiveFieldSequenceB[i].ToString());
                        if (xNode_B != null)
                        {
                            isNodeB = true;
                            break;
                        }
                    }
                    if (isNodeA == true && isNodeB == true)
                    {
                        isValid = false;
                        errorObject.AddError(errorCode, policyName,
                            ruleName, messageType, conditionalRuleName,
                            conditionalRuleNumber);
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	SWIFTNetworkRule177
        /// </method>
        /// <summary>
        /// 	If field 21E is present in sequence A, then field 50a (option A or K), must also be present in sequence A. In each occurrence
        /// 	of sequence B, if field 21E is present, then field 50a (option A or K) must also be present in the same occurrence
        /// 	(Error code(s): D77):
        /// </summary>
        /// <param name="xDocument">
        /// 	parameter for xDocument
        /// </param>
        /// <param name="xPathSequence">
        /// 	parameter value for xpathsequence (A or B)
        /// </param>
        /// <param name="xPathNonRepetitiveFieldSequence">
        /// 	parameter value for fieds in respective sequence separated by comma
        /// </param>
        /// <param name="errorCode">
        /// 	parameter for error code
        /// </param>
        /// <param name="policyName">
        /// 	parameter for policy name
        /// </param>
        /// <param name="ruleName">
        /// 	parameter value for rule name
        /// </param>
        /// <param name="messageType">
        /// 	parameter value for message type
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	parameter value for conditional rule name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	parameter value for conditional rule number
        /// </param>
        /// <param name="errorObject">
        /// 	parameter value for error object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool SWIFTNetworkRule177(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathNonRepetitiveFieldSequence,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule177" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xDocument) throw new ArgumentNullException("xDocument");
                if (null == errorObject) throw new ArgumentNullException("errorObject");
                if (null == xPathNonRepetitiveFieldSequence) throw new ArgumentNullException("xPathNonRepetitiveFieldSequence");


                XmlNode xRoot = xDocument.Document;

                XmlNodeList xList = xRoot.SelectNodes(xPathSequence);
                // 21E and 50a
                string[] arrNonRepetitiveFieldSequence = xPathNonRepetitiveFieldSequence.Split(Constants.COMMA.ToCharArray());

                foreach (XmlNode xNode in xList)
                {
                    int i = 0;
                    XmlNode Node = xNode.SelectSingleNode(arrNonRepetitiveFieldSequence[i++].ToString());
                    if (Node != null)
                    {
                        XmlNode xNode50A = xNode.SelectSingleNode(arrNonRepetitiveFieldSequence[i++].ToString());
                        XmlNode xNode50K = xNode.SelectSingleNode(arrNonRepetitiveFieldSequence[i++].ToString());
                        if (xNode50A == null && xNode50K == null)
                        {
                            isValid = false;
                            errorObject.AddError(errorCode, policyName,
                                ruleName, messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            break;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        /// 	SWIFTNetworkRule180
        /// </method>
        /// <summary>
        /// 	The sum of the amounts of fields 32B in sequence B must be put either in field 32B of sequence C
        /// 	when no charges are included, or be put in field 19 of sequence C. In the former case,
        /// 	field 19 must not be present (Error code(s): D80). In the latter case, Field 19 must equal the sum of the amounts in all occurrences of field 32B in sequence B (error code(s): C01).
        /// </summary>
        /// <param name="xDocument">
        /// 	parameter for xDocument
        /// </param>
        /// <param name="xPathSequenceB">
        /// 	parameter value for xpath of sequence B
        /// </param>
        /// <param name="xPathSequenceC">
        /// 	parameter value for xpath of sequence C
        /// </param>
        /// <param name="xPathNonRepetitiveFieldSequenceB">
        /// 	parameter for value of 32B and 33B in sequence B
        /// </param>
        /// <param name="xPathNonRepetitiveFieldSequenceC">
        /// 	parameter for value of 32B and 33B in sequence C
        /// </param>
        /// <param name="errorCode">
        /// 	parameter for errorCode
        /// </param>
        /// <param name="policyName">
        /// 	parameter for policy name
        /// </param>
        /// <param name="ruleName">
        /// 	parameter for rule name
        /// </param>
        /// <param name="messageType">
        /// 	parameter for message type
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	parameter for conditional rule name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	parameter for conditional rulenumber
        /// </param>
        /// <param name="errorObject">
        /// 	parameter for errorObject
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool SWIFTNetworkRule180(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathSequenceC,
            string xPathNonRepetitiveFieldSequenceB,
            string xPathNonRepetitiveFieldSequenceC,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule180" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            decimal sumOfAmounts = 0;
            try
            {
                if (null == xDocument) throw new ArgumentNullException("xDocument");
                if (null == errorObject) throw new ArgumentNullException("errorObject");
                if (null == xPathNonRepetitiveFieldSequenceC) throw new ArgumentNullException("xPathNonRepetitiveFieldSequenceC");
                if (null == xPathNonRepetitiveFieldSequenceB) throw new ArgumentNullException("xPathNonRepetitiveFieldSequenceB");
                if (null == xPathSequenceB) throw new ArgumentNullException("xPathSequenceB");
                if (null == xPathSequenceC) throw new ArgumentNullException("xPathSequenceC");

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListB = xRoot.SelectNodes(xPathSequenceB.ToString());
                // Sequence B 32B
                string[] arrNonRepetitiveFieldSequenceB = xPathNonRepetitiveFieldSequenceB.Split(Constants.COMMA.ToCharArray());

                XmlNodeList xListC = xRoot.SelectNodes(xPathSequenceC.ToString());
                // Sequence C 32B and 19
                string[] arrNonRepetitiveFieldSequenceC = xPathNonRepetitiveFieldSequenceC.Split(Constants.COMMA.ToCharArray());

                // SumOFAmounts of 32B in Sequence B
                foreach (XmlNode xNodeB in xListB)
                {
                    for (int i = 0; i < arrNonRepetitiveFieldSequenceB.Length; i++)
                    {
                        XmlNode xNode = xNodeB.SelectSingleNode(arrNonRepetitiveFieldSequenceB[i].ToString());
                        if (xNode != null)
                        {
                            decimal Amount32B = Convert.ToDecimal(xNode.LastChild.InnerText.Replace(Constants.COMMA, decimalSeparator), CultureInfo.InvariantCulture);
                            sumOfAmounts = sumOfAmounts + Amount32B;
                            //break;
                        }
                    }
                }

                foreach (XmlNode NodeC in xListC)
                {
                    // field 32B of Seq C
                    XmlNode xNode32 = NodeC.SelectSingleNode
                        (arrNonRepetitiveFieldSequenceC[0].ToString());

                    // field 19 of Seq C
                    XmlNode xNode19 = NodeC.SelectSingleNode
                        (arrNonRepetitiveFieldSequenceC[1].ToString());

                    if (Convert.ToDecimal(xNode32.LastChild.InnerText.Replace(Constants.COMMA, decimalSeparator), CultureInfo.InvariantCulture) == sumOfAmounts)
                    {
                        if (xNode19 != null)
                        {
                            isValid = false;
                            errorObject.AddError(errorCode, policyName,
                                ruleName, messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            break;
                        }
                    }
                    else
                    {
                        if (xNode19 == null)
                        {
                            isValid = false;
                            errorObject.AddError(errorCode, policyName,
                                ruleName, messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            break;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		IsValidFlag
        /// </method>
        /// <summary>
        ///		This method performs validation for fields where validation is,Flag is only to be used in a sequence D3 with settlement amount field 19A::SETT//[N]3!a15d as it indicates whether the
        ///		concerned settlement amount includes the accrued interest and/or the stamp duty amount.(Error code 'Not Defined').
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the sequence to be validated.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the qualifier of Amount field in the same sequence to be validated.
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Reference containing the value (SETT) of the Qualifier for the Amount field element's qualifier.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        ///	</param>
        ///	<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="sequenceName" type = "string">
        ///		Input containing the sequence Name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message Type.
        /// </param>
        /// <param name ="elementName" type = "string">
        ///		Input containing the element Name.
        /// </param>
        /// <param name ="elementValue" type = "string">
        ///		Input containing the element Value.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidFlag(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathQualifier,
            string qualifierValue,
            string errorCode,
            string policyName,
            string ruleName,
            string sequenceName,
            string messageType,
            string elementName,
            string elementValue,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidFlag" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //declarations of variables used in the method
            bool isValid = true;
            bool isPresent = false;
            try
            {


                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    qualifierValue == null ||
                    qualifierValue.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //get a list of repeating tags
                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        XmlNodeList xListTag = xNodeSequence.SelectNodes(xPathQualifier);

                        foreach (XmlNode xNode in xListTag)
                        {
                            if (xNode.InnerText != null && xNode.InnerText.CompareTo(qualifierValue) == 0)
                            {//check if the Settlement Amount has SETT qaulifier
                                isPresent = true;
                                break;
                            }
                        }

                        if (isPresent == false)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, sequenceName, elementName, elementValue);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        /// 	InvokeAddError
        /// </method>
        /// <summary>
        /// 	An Overloaded function of SWIFTSRG2001NetworkRule112 (D12 SRG2001) is calling the
        /// 	sealed error class (For Message MT573 only)
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="errorCode">
        /// 	Error Code
        /// </param>
        /// <param name="policyName">
        /// 	Policy Name
        /// </param>
        /// <param name="ruleName">
        /// 	Rule Name
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Input containing Conditional Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input containing Conditional Rule Number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns>
        /// 	Always returns true so that it can be called in BR Composer
        ///	</returns>
        public static bool InvokeAddError(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function InvokeAddError" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (null == errorObject) throw new ArgumentNullException("errorObject");

                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return false;
        }

        ///<method>
        ///		IsValidCodeRequestedMessageType
        ///</method>
        /// <summary>
        /// 	It is applicable for MT549
        /// 	If statement requested is MT535, Qualifier is STTY,STBA and Data Source Scheme is not present,
        /// 	Indicator must contain one of the specified codes
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated
        /// </param>
        /// <param name ="xPathField" type = "string">
        ///		Input reference of the field element which should not be present to be validated.
        /// </param>
        /// <param name ="xPathCode" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the field element (Qualifier) to be validated.
        /// </param>
        /// <param name ="qualifier" type = "string">
        ///		Reference containing the list of the codes in qualifier.
        /// </param>
        /// <param name ="codeList" type = "string">
        ///		Reference containing the list of the codes for QuantityTypeCode.
        /// </param>
        /// <param name="xPathNumberIdentification">
        ///		Input containing the xPath of Number Identification Field
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidCodeRequestedMessageType(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathField,
            string xPathCode,
            string xPathQualifier,
            string qualifier,
            string codeList,
            string xPathNumberIdentification,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCodeRequestedMessageType" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xPathNumberIdentification == null || xPathNumberIdentification.Length == 0)
                {
                    return false;
                }
                else
                {
                    if (null == xDocument) throw new ArgumentNullException("xDocument");

                    XmlNode xRoot = xDocument.Document;
                    XmlNode xNode = xRoot.SelectSingleNode(xPathNumberIdentification);

                    //Check if Field 13A exists
                    if (xNode != null && xNode.InnerText != null && xNode.InnerText.Length != 0)
                    {
                        string messageType = null;
                        messageType = xNode.LastChild.InnerText;

                        if (Convert.ToInt16(messageType, CultureInfo.InvariantCulture) == Constants.REQUESTEDMESSAGETYPE)
                        {
                            isValid = CommonFunctions.IsValidCode(xDocument, xPathTag, xPathField,
                                xPathCode, xPathQualifier, qualifier, codeList, errorCode, policyName, ruleName, errorObject);
                        }
                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        /// <method>
        ///		SWIFTNetworkRule149
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 149.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xHeaderDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the header xml data of the instance to be validated.
        /// </param>
        /// <param name ="xPathSequenceB" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathSendersBIC" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathReceiversBIC" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath33B" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="countryCodeList" type = "string">
        ///		Input containing the list of country codes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule149(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            Microsoft.RuleEngine.TypedXmlDocument xHeaderDocument,
            string xPathSequenceB,
            string xPathSendersBIC,
            string xPathReceiversBIC1,
            string xPathReceiversBIC2,
            string xPath33B,
            string countryCodeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule149" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                bool isCountryCodePresent = false;
                int count = 0;
                if (xDocument == null ||
                    xPathSendersBIC == null ||
                    xPathSendersBIC.Length == 0 ||
                    xPath33B == null ||
                    xPath33B.Length == 0 ||
                    countryCodeList == null ||
                    countryCodeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");
                if (null == xHeaderDocument) throw new ArgumentNullException("xHeaderDocument");

                //SequenceB cannot be null for MT102 or MT102 PLUS -
                // MT103/MT103PLUS do nto have SequenceB.
                if ((messageType == Constants.MT102 || messageType == Constants.MT102PLUS) &&
                    (xPathSequenceB == null || xPathSequenceB.Length == 0))
                {
                    return false;
                }

                if (xPathReceiversBIC1 == null && xPathReceiversBIC2 == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNode xHeaderRoot = xHeaderDocument.Document;

                XmlNode xNodeSenderBIC = xHeaderRoot.SelectSingleNode(xPathSendersBIC);

                // The senders BIC is either in the "Input Application Header" or the "Output Application Header"
                // depending on whether the msg is going to SWIFt or coming from SWIFT. Hence find the correct
                // ReceiverBIC node.
                XmlNode xNodeReceiverBIC = xHeaderRoot.SelectSingleNode(xPathReceiversBIC1);
                if (xNodeReceiverBIC == null)
                {
                    xNodeReceiverBIC = xHeaderRoot.SelectSingleNode(xPathReceiversBIC2);
                    if (xNodeReceiverBIC == null)
                    {
                        return false;
                    }
                }

                if (xNodeSenderBIC != null && xNodeSenderBIC.InnerText != null && xNodeSenderBIC.InnerText.Length != 0 &&
                    xNodeReceiverBIC != null && xNodeReceiverBIC.InnerText != null && xNodeReceiverBIC.InnerText.Length != 0)
                {
                    //Checking the CountryCodes Of Sender And Receiver
                    if (countryCodeList.IndexOf(xNodeReceiverBIC.InnerText.Substring(4, 2)) != -1 &&
                        countryCodeList.IndexOf(xNodeSenderBIC.InnerText.Substring(4, 2)) != -1)
                    {
                        isCountryCodePresent = true;
                    }
                }

                // Need to check the field 33B only if "required" country code from the list is present
                // in both the sender's and the receivers BIC. Else need not check for 33B - rule is valid.
                if (isCountryCodePresent)
                {
                    switch (messageType)
                    {
                        case Constants.MT102:
                        case Constants.MT102PLUS:
                            {
                                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequenceB);
                                foreach (XmlNode xNodeSequenceB in xListSequence)
                                {
                                    XmlNode xNode33B = xNodeSequenceB.SelectSingleNode(xPath33B);
                                    if (xNode33B != null)
                                    {
                                        count++;
                                    }

                                }

                                //Checking the number of occurrences of Tag 33B
                                if (count != xListSequence.Count)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                            }
                            break;

                        case Constants.MT103:
                        case Constants.MT103PLUS:
                        // Changes in SWIFTNetworkRule149 for MT103REMIT
                        case Constants.MT103REMIT:
                            {
                                XmlNode xNode33B = xRoot.SelectSingleNode(xPath33B);
                                if (xNode33B == null)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                            }
                            break;

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	CheckPresence
        /// </method>
        /// <summary>
        /// 	This method checks the presence of Tag2 with specified value of
        /// 	Field1 in particular occurance of SeqeunceX when Tag1 with
        /// 	Specified values of field1 and field2 is present in SAME
        /// 	OCCURANCE of SequenceX. The check performed depends on
        /// 	value Of isPresent, which is passed as boolean parameter.
        /// 	if isPresent is true then check is performed for tag2 being
        /// 	MANDATORY in Sequence X and when isPresent is false check is
        /// 	performed for tag2 being NOT ALLOWED in SequenceX
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the sequence in which validation is to
        ///		performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        /// 	Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        /// 	Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field1" type = "string">
        /// 	Value of Field1 of Tag1
        /// </param>
        /// <param name="xPathTag1Field2" type = "string">
        /// 	Input Reference of Field2 of Tag1
        /// </param>
        /// <param name="valueTag1Field2" type = "string">
        /// 	Value of Field2 of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// 	Comma separated Input References of the List of Tag2
        /// </param>
        /// <param name="xPathTag2Field1" type = "string">
        /// 	Input Reference of Field1 of Tag2
        /// </param>
        /// <param name="valueTag2Field1" type = "string">
        /// 	Value of Field1 of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        /// 	Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// 	boolean whose value depends upon the success of check performed.
        ///</returns>
        public static bool CheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag1List,
            string xPathTag1Field1,
            string valueTag1Field1,
            string xPathTag1Field2,
            string valueTag1Field2,
            string xPathTag2List,
            string xPathTag2Field1,
            string valueTag2Field1,
            bool isPresent)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckPresence:");
            try
            {
                if (xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0 ||
                    xPathTag1Field1 == null ||
                    xPathTag1Field1.Length == 0 ||
                    valueTag1Field1 == null ||
                    valueTag1Field1.Length == 0 ||
                    xPathTag1Field2 == null ||
                    xPathTag1Field2.Length == 0 ||
                    valueTag1Field2 == null ||
                    valueTag1Field2.Length == 0 ||
                    xPathTag2Field1 == null ||
                    xPathTag2Field1.Length == 0 ||
                    valueTag2Field1 == null ||
                    valueTag2Field1.Length == 0
                    )
                {
                    return false;
                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;

                foreach (XmlNode xSequenceNode in xListSequence)
                {
                    isTag1ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag1List, xPathTag1Field1, valueTag1Field1, xPathTag1Field2, valueTag1Field2);

                    isTag2ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag2List, xPathTag2Field1, valueTag2Field1);

                    if (isTag1ConditionValid & (isTag2ConditionValid ^ isPresent))
                    {
                        return false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;
        }


        /// <method>
        /// CheckPresence
        /// </method>
        /// <summary>
        /// 	This method checks the presence of Tag2 with specified value of
        /// 	Field1 in SeqeunceX when Tag1 with Specified values of field1
        /// 	and field2 is present in SequenceY.
        /// 	The check performed depends on value Of isPresent, which
        /// 	is passed as boolean parameter. if isPresent is true then
        /// 	check is performed for tag2 being MANDATORY in Sequence Y
        /// 	and when isPresent is false check is performed for tag2
        /// 	being NOT ALLOWED in SequenceY
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///	Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence1" type = "string">
        ///	Input reference of the sequence1 in which validation is to
        ///	performed.
        /// </param>
        /// <param name ="xPathSequence2" type = "string">
        ///	Input reference of the sequence2 in which validation is to
        ///	performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        /// Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        /// Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field1" type = "string">
        /// Value of Field1 of Tag1
        /// </param>
        /// <param name="xPathTag1Field2" type = "string">
        /// Input Reference of Field2 of Tag1
        /// </param>
        /// <param name="valueTag1Field2" type = "string">
        /// Value of Field2 of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="xPathTag2Field1" type = "string">
        /// Input Reference of Field1 of Tag2
        /// </param>
        /// <param name="valueTag2Field1" type = "string">
        /// Value of Field1 of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        /// Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// boolean whose value depends upon the success of check performed.
        ///</returns>
        public static bool CheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence1,
            string xPathSequence2,
            string xPathTag1List,
            string xPathTag1Field1,
            string valueTag1Field1,
            string xPathTag1Field2,
            string valueTag1Field2,
            string xPathTag2List,
            string xPathTag2Field1,
            string valueTag2Field1,
            bool isPresent)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckPresence:");
            try
            {

                if (xPathSequence1 == null ||
                    xPathSequence1.Length == 0 ||
                    xPathSequence2 == null ||
                    xPathSequence2.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0 ||
                    xPathTag1Field1 == null ||
                    xPathTag1Field1.Length == 0 ||
                    valueTag1Field1 == null ||
                    valueTag1Field1.Length == 0 ||
                    xPathTag1Field2 == null ||
                    xPathTag1Field2.Length == 0 ||
                    valueTag1Field2 == null ||
                    valueTag1Field2.Length == 0 ||
                    xPathTag2Field1 == null ||
                    xPathTag2Field1.Length == 0 ||
                    valueTag2Field1 == null ||
                    valueTag2Field1.Length == 0
                    )
                {
                    return false;

                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence1 = xRoot.SelectNodes(xPathSequence1);
                XmlNodeList xListSequence2 = xRoot.SelectNodes(xPathSequence2);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;

                foreach (XmlNode xSequenceNode1 in xListSequence1)
                {
                    foreach (XmlNode xSequenceNode2 in xListSequence2)
                    {
                        isTag1ConditionValid = IsConditionSatisfied(xSequenceNode1, xPathTag1List, xPathTag1Field1, valueTag1Field1, xPathTag1Field2, valueTag1Field2);

                        isTag2ConditionValid = IsConditionSatisfied(xSequenceNode2, xPathTag2List, xPathTag2Field1, valueTag2Field1);
                        if (isTag1ConditionValid & (isTag2ConditionValid ^ isPresent))
                        {
                            return false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;
        }


        /// <method>
        /// IsConditionSatisfied
        /// </method>
        /// <summary>
        /// This Function checks presence of Tag1 with particular value of
        /// Field1 and Field2.
        /// </summary>
        /// <param name="xSequenceNode" type = "str`ing">
        /// Input Reference of Sequence in which validation is to be performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string">
        /// Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        /// Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field1" type = "string">
        /// Value of Field1 of Tag1
        /// </param>
        /// <param name="xPathTag1Field2" type = "string">
        /// Input Reference of Field2 of Tag1
        /// </param>
        /// <param name="valueTag1Field2" type = "string">
        /// Value of Field2 of Tag1
        /// </param>
        /// <returns></returns>
        private static bool IsConditionSatisfied(XmlNode xSequenceNode,
            string xPathTag1List,
            string xPathTag1Field1,
            string valueTag1Field1,
            string xPathTag1Field2,
            string valueTag1Field2)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsConditionSatisfied:");
            try
            {
                string[] xPathTag1ListArray = xPathTag1List.Split(Constants.CHRCOMMA);
                XmlNodeList xNodeListTag1;
                foreach (string qualifier in xPathTag1ListArray)
                {
                    xNodeListTag1 = xSequenceNode.SelectNodes(qualifier);
                    foreach (XmlNode xNode in xNodeListTag1)
                    {
                        if (xNode.SelectSingleNode(xPathTag1Field1) != null
                            && valueTag1Field1.IndexOf(xNode.SelectSingleNode(xPathTag1Field1).InnerText) != -1
                            && xNode.SelectSingleNode(xPathTag1Field2) != null
                            && valueTag1Field2.IndexOf(xNode.SelectSingleNode(xPathTag1Field2).InnerText) != -1)
                        {
                            return true;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return false;

        }

        /// <method>
        /// CheckPresence
        /// </method>
        /// <summary>
        /// This method checks the presence of Tag2 with specified value of
        /// Field1 in particular occurance of SeqeunceX when Tag1 with
        /// Specified values of field1 and field2 is present in SAME
        /// OCCURANCE of SequenceX. The check performed depends on
        /// value Of isPresent, which is passed as boolean parameter.
        /// if isPresent is true then check is performed for tag2 being
        /// MANDATORY in Sequence X and when isPresent is false check is
        /// performed for tag2 being NOT ALLOWED in SequenceX
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///	Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///	Input reference of the sequence in which validation is to
        ///	performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        /// Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        /// Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field1" type = "string">
        /// Value of Field1 of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="xPathTag2Field1" type = "string">
        /// Input Reference of Field1 of Tag2
        /// </param>
        /// <param name="valueTag2Field1" type = "string">
        /// Value of Field1 of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        /// Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// boolean whose value depends upon the success of check performed.
        ///</returns>
        public static bool CheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag1List,
            string xPathTag1Field1,
            string valueTag1Field1,
            string xPathTag2List,
            string xPathTag2Field1,
            bool isPresent,
            string valueTag2Field1)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckPresence:");
            try
            {
                if (xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0 ||
                    xPathTag1Field1 == null ||
                    xPathTag1Field1.Length == 0 ||
                    valueTag1Field1 == null ||
                    valueTag1Field1.Length == 0 ||
                    xPathTag2Field1 == null ||
                    xPathTag2Field1.Length == 0 ||
                    valueTag2Field1 == null ||
                    valueTag2Field1.Length == 0
                    )
                {
                    return false;
                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;

                foreach (XmlNode xSequenceNode in xListSequence)
                {
                    isTag1ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag1List, xPathTag1Field1, valueTag1Field1);

                    isTag2ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag2List, xPathTag2Field1, valueTag2Field1);

                    if (isTag1ConditionValid & (isTag2ConditionValid ^ isPresent))
                    {
                        return false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return true;
        }


        /// <method>
        /// CheckPresence
        /// </method>
        /// <summary>
        /// This method checks the presence of Tag2 with specified value of
        /// Field1 in SeqeunceX when Tag1 with Specified values of field1
        /// and field2 is present in SequenceY.
        /// The check performed depends on value Of isPresent, which
        /// is passed as boolean parameter. if isPresent is true then
        /// check is performed for tag2 being MANDATORY in Sequence Y
        /// and when isPresent is false check is performed for tag2
        /// being NOT ALLOWED in SequenceY
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///	Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence1" type = "string">
        ///	Input reference of the sequence1 in which validation is to
        ///	performed.
        /// </param>
        /// <param name ="xPathSequence2" type = "string">
        ///	Input reference of the sequence2 in which validation is to
        ///	performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        /// Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        /// Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field1" type = "string">
        /// Value of Field2 of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="xPathTag2Field1" type = "string">
        /// Input Reference of Field1 of Tag2
        /// </param>
        /// <param name="valueTag2Field1" type = "string">
        /// Value of Field1 of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        /// Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// boolean whose value depends upon the success of check performed.
        ///</returns>
        public static bool CheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence1,
            string xPathSequence2,
            string xPathTag1List,
            string xPathTag1Field1,
            string valueTag1Field1,
            string xPathTag2List,
            string xPathTag2Field1,
            bool isPresent,
            string valueTag2Field1)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckPresence:");
            try
            {
                if (xPathSequence1 == null ||
                    xPathSequence1.Length == 0 ||
                    xPathSequence2 == null ||
                    xPathSequence2.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0 ||
                    xPathTag1Field1 == null ||
                    xPathTag1Field1.Length == 0 ||
                    valueTag1Field1 == null ||
                    valueTag1Field1.Length == 0 ||
                    xPathTag2Field1 == null ||
                    xPathTag2Field1.Length == 0 ||
                    valueTag2Field1 == null ||
                    valueTag2Field1.Length == 0
                    )
                {
                    return false;
                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence1 = xRoot.SelectNodes(xPathSequence1);
                XmlNodeList xListSequence2 = xRoot.SelectNodes(xPathSequence2);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;


                foreach (XmlNode xSequenceNode1 in xListSequence1)
                {
                    foreach (XmlNode xSequenceNode2 in xListSequence2)
                    {
                        isTag1ConditionValid = IsConditionSatisfied(xSequenceNode1, xPathTag1List, xPathTag1Field1, valueTag1Field1);

                        isTag2ConditionValid = IsConditionSatisfied(xSequenceNode2, xPathTag2List, xPathTag2Field1, valueTag2Field1);

                        if (isTag1ConditionValid & (isTag2ConditionValid ^ isPresent))
                        {
                            return false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;

        }

        /// <method>
        /// 	CheckPresence
        /// </method>
        /// <summary>
        /// 	This method checks the presence of Tag2 with specified value of
        /// 	Field1 in particular occurance of SeqeunceX when Tag1 with
        /// 	Specified values of field1 and field2 is present in SAME
        /// 	OCCURANCE of SequenceX. The check performed depends on
        /// 	value Of isPresent, which is passed as boolean parameter.
        /// 	if isPresent is true then check is performed for tag2 being
        /// 	MANDATORY in Sequence X and when isPresent is false check is
        /// 	performed for tag2 being NOT ALLOWED in SequenceX
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the sequence in which validation is to
        ///		performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        /// 	Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        /// 	Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field1" type = "string">
        /// 	Value of Field1 of Tag1
        /// </param>
        /// <param name="xPathTag1Field2" type = "string">
        /// 	Input Reference of Field1 of Tag2
        /// </param>
        /// <param name="valueTag1Field2" type = "string">
        /// 	Value of Field1 of Tag2
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// 	Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        /// 	Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// 	boolean whose value depends upon the success of check performed.
        ///</returns>
        public static bool CheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag1List,
            string xPathTag1Field1,
            string valueTag1Field1,
            string xPathTag1Field2,
            string valueTag1Field2,
            string xPathTag2List,
            bool isPresent)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckPresence:");
            try
            {
                if (xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag1Field1 == null ||
                    xPathTag1Field1.Length == 0 ||
                    valueTag1Field1 == null ||
                    valueTag1Field1.Length == 0 ||
                    xPathTag1Field2 == null ||
                    xPathTag1Field2.Length == 0 ||
                    valueTag1Field2 == null ||
                    valueTag1Field2.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0
                    )
                {
                    return false;
                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;
                foreach (XmlNode xSequenceNode in xListSequence)
                {
                    isTag1ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag1List, xPathTag1Field1, valueTag1Field1, xPathTag1Field2, valueTag1Field2);

                    isTag2ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag2List);

                    if (isTag1ConditionValid & (isTag2ConditionValid ^ isPresent))
                    {
                        return false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;
        }



        /// <method>
        /// CheckPresence
        /// </method>
        /// <summary>
        /// This method checks the presence of Tag2 in SequenceX when Tag1
        /// with Specified values of field1 and field2 is present in SequenceY.
        /// The check performed depends on value Of isPresent, which
        /// is passed as boolean parameter. if isPresent is true then
        /// check is performed for tag2 being MANDATORY in Sequence Y
        /// and when isPresent is false check is performed for tag2
        /// being NOT ALLOWED in SequenceY
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///	Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence1" type = "string">
        ///	Input reference of the sequence1 in which validation is to
        ///	performed.
        /// </param>
        /// <param name ="xPathSequence2" type = "string">
        ///	Input reference of the sequence2 in which validation is to
        ///	performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        /// Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        /// Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field1" type = "string">
        /// Value of Field2 of Tag1
        /// </param>
        /// <param name="xPathTag1Field2" type = "string">
        /// Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field2" type = "string">
        /// Value of Field2 of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        /// Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// boolean whose value depends upon the success of check performed.
        ///</returns>
        public static bool CheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence1,
            string xPathSequence2,
            string xPathTag1List,
            string xPathTag1Field1,
            string valueTag1Field1,
            string xPathTag1Field2,
            string valueTag1Field2,
            string xPathTag2List,
            bool isPresent)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckPresence:");
            try
            {
                if (xPathSequence1 == null ||
                    xPathSequence1.Length == 0 ||
                    xPathSequence2 == null ||
                    xPathSequence2.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag1Field1 == null ||
                    xPathTag1Field1.Length == 0 ||
                    valueTag1Field1 == null ||
                    valueTag1Field1.Length == 0 ||
                    xPathTag1Field2 == null ||
                    xPathTag1Field2.Length == 0 ||
                    valueTag1Field2 == null ||
                    valueTag1Field2.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0
                    )
                {
                    return false;

                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence1 = xRoot.SelectNodes(xPathSequence1);
                XmlNodeList xListSequence2 = xRoot.SelectNodes(xPathSequence2);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;

                foreach (XmlNode xSequenceNode1 in xListSequence1)
                {
                    foreach (XmlNode xSequenceNode2 in xListSequence2)
                    {


                        isTag1ConditionValid = IsConditionSatisfied(xSequenceNode1, xPathTag1List, xPathTag1Field1, valueTag1Field1, xPathTag1Field2, valueTag1Field2);

                        isTag2ConditionValid = IsConditionSatisfied(xSequenceNode2, xPathTag2List);


                        if (isTag1ConditionValid & (isTag2ConditionValid ^ isPresent))
                        {
                            return false;

                        }
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;

        }


        /// <method>
        /// CheckPresence
        /// </method>
        /// <summary>
        /// This method checks the presence of Tag2 with specified value of
        /// Field1 in particular occurance of SeqeunceX when Tag1 with
        /// Specified values of field1 and field2 is present in SAME
        /// OCCURANCE of SequenceX. The check performed depends on
        /// value Of isPresent, which is passed as boolean parameter.
        /// if isPresent is true then check is performed for tag2 being
        /// MANDATORY in Sequence X and when isPresent is false check is
        /// performed for tag2 being NOT ALLOWED in SequenceX
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///	Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///	Input reference of the sequence in which validation is to
        ///	performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        /// Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        /// Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field1" type = "string">
        /// Value of Field1 of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        /// Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// boolean whose value depends upon the success of check performed.
        ///</returns>



        public static bool CheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag1List,
            string xPathTag1Field1,
            string valueTag1Field1,
            string xPathTag2List,
            bool isPresent)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckPresence:");

            try
            {
                if (xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag1Field1 == null ||
                    xPathTag1Field1.Length == 0 ||
                    valueTag1Field1 == null ||
                    valueTag1Field1.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0
                    )
                {
                    return false;

                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;


                foreach (XmlNode xSequenceNode in xListSequence)
                {


                    isTag1ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag1List, xPathTag1Field1, valueTag1Field1);

                    isTag2ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag2List);


                    if (isTag1ConditionValid & (isTag2ConditionValid ^ isPresent))
                    {
                        return false;

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return true;

        }


        /// <method>
        /// CheckPresence
        /// </method>
        /// <summary>
        /// This method checks the presence of Tag2 with specified value of
        /// Field1 in SequenceX when Tag1 with Specified values of field1
        /// is present in SequenceY.
        /// The check performed depends on value Of isPresent, which
        /// is passed as boolean parameter. if isPresent is true then
        /// check is performed for tag2 being MANDATORY in Sequence Y
        /// and when isPresent is false check is performed for tag2
        /// being NOT ALLOWED in SequenceY
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///	Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence1" type = "string">
        ///	Input reference of the sequence1 in which validation is to
        ///	performed.
        /// </param>
        /// <param name ="xPathSequence2" type = "string">
        ///	Input reference of the sequence2 in which validation is to
        ///	performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        /// Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        /// Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field1" type = "string">
        /// Value of Field2 of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        /// Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// boolean whose value depends upon the success of check performed.
        ///</returns>


        public static bool CheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence1,
            string xPathSequence2,
            string xPathTag1List,
            string xPathTag1Field1,
            string valueTag1Field1,
            string xPathTag2List,
            bool isPresent)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckPresence:");
            try
            {


                if (xPathSequence1 == null ||
                    xPathSequence1.Length == 0 ||
                    xPathSequence2 == null ||
                    xPathSequence2.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag1Field1 == null ||
                    xPathTag1Field1.Length == 0 ||
                    valueTag1Field1 == null ||
                    valueTag1Field1.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0
                    )
                {
                    return false;

                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence1 = xRoot.SelectNodes(xPathSequence1);
                XmlNodeList xListSequence2 = xRoot.SelectNodes(xPathSequence2);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;

                foreach (XmlNode xSequenceNode1 in xListSequence1)
                {
                    foreach (XmlNode xSequenceNode2 in xListSequence2)
                    {


                        isTag1ConditionValid = IsConditionSatisfied(xSequenceNode1, xPathTag1List, xPathTag1Field1, valueTag1Field1);

                        isTag2ConditionValid = IsConditionSatisfied(xSequenceNode2, xPathTag2List);


                        if (isTag1ConditionValid & (isTag2ConditionValid ^ isPresent))
                        {
                            return false;

                        }
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;

        }


        /// <method>
        /// CheckPresence
        /// </method>
        /// <summary>
        /// This method checks the presence of Tag2 with specified value of
        /// Field1 in SeqeunceX when Tag1 with Specified values of field1
        /// and field2 is present in SequenceY.
        /// The check performed depends on value Of isPresent, which
        /// is passed as boolean parameter. if isPresent is true then
        /// check is performed for tag2 being MANDATORY in Sequence Y
        /// and when isPresent is false check is performed for tag2
        /// being NOT ALLOWED in SequenceY
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///	Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence1" type = "string">
        ///	Input reference of the sequence1 in which validation is to
        ///	performed.
        /// </param>
        /// <param name ="xPathSequence2" type = "string">
        ///	Input reference of the sequence2 in which validation is to
        ///	performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        /// Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        /// Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// boolean whose value depends upon the success of check performed.
        ///</returns>

        //public static bool CheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence1,
        //    string xPathSequence2,
        //    string xPathTag1List,
        //    string xPathTag2List,
        //    bool isPresent)

        //{

        //    if(	xPathSequence1 == null ||
        //        xPathSequence1.Length == 0 ||
        //        xPathSequence2 == null ||
        //        xPathSequence2.Length == 0 ||
        //        xPathTag1List == null ||
        //        xPathTag1List.Length == 0 ||
        //        xPathTag2List == null ||
        //        xPathTag2List.Length == 0
        //        )

        //    {
        //        return false;

        //    }

        //    if (null == xDocument) throw new ArgumentNullException("xDocument");

        //    XmlNode xRoot = xDocument.Document;
        //    XmlNodeList xListSequence1 = xRoot.SelectNodes(xPathSequence1);
        //    XmlNodeList xListSequence2 = xRoot.SelectNodes(xPathSequence2);
        //    bool isTag1ConditionValid = false;
        //    bool isTag2ConditionValid = false;

        //    foreach( XmlNode xSequenceNode1 in xListSequence1)
        //    {
        //        foreach( XmlNode xSequenceNode2 in xListSequence2)
        //        {


        //            isTag1ConditionValid = IsConditionSatisfied(xSequenceNode1
        //                ,xPathTag1List);

        //            isTag2ConditionValid = IsConditionSatisfied(xSequenceNode2,
        //                xPathTag2List);


        //            if( isTag1ConditionValid & ( isTag2ConditionValid ^ isPresent ) )
        //            {
        //                return false;

        //            }
        //        }

        //    }
        //    return true;

        //}



        /// <method>
        /// IsConditionSatisfied
        /// </method>
        /// <summary>
        /// This Function checks presence of Tag2 with particular value of
        /// Field1.
        /// </summary>
        /// <param name="xSequenceNode" type = "string">
        /// Input Reference of Sequence in which validation is to be performed.
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag2Field1" type = "string">
        /// Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag2Field1" type = "string">
        /// Value of Field1 of Tag1
        /// </param>
        /// <returns> Boolean</returns>


        private static bool IsConditionSatisfied(XmlNode xSequenceNode,
            string xPathTag2List,
            string xPathTag2Field1,
            string valueTag2Field1)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsConditionSatisfied:");
            try
            {
                string[] xPathTag2ListArray = xPathTag2List.Split(
                    Constants.CHRCOMMA);
                XmlNodeList xNodeListTag2;
                string[] strArray = valueTag2Field1.Split(Constants.CHRCOMMA);

                foreach (string qualifier in xPathTag2ListArray)
                {
                    xNodeListTag2 = xSequenceNode.SelectNodes(qualifier);
                    foreach (XmlNode xNode in xNodeListTag2)
                    {
                        foreach (string code in strArray)
                        {
                            if (xNode.SelectSingleNode(xPathTag2Field1) != null &&

                                xNode.SelectSingleNode(xPathTag2Field1).InnerText.IndexOf(code) != -1)
                            {
                                return true;
                            }


                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return false;

        }



        /// <method>
        /// IsConditionSatisfied
        /// </method>
        /// <summary>
        /// This Function checks presence of Tag1 with particular value of
        /// Field1 and Field2.
        /// </summary>
        /// <param name="xSequenceNode" type = "string">
        /// Input Reference of Sequence in which validation is to be performed.
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// Comma seperated Input References of the List of Tag1
        /// </param>
        /// <returns>Boolean</returns>

        private static bool IsConditionSatisfied(XmlNode xSequenceNode,
            string xPathTag2List)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsConditionSatisfied:");
            try
            {
                string[] xPathTag2ListArray = xPathTag2List.Split(
                    Constants.CHRCOMMA);

                foreach (string xPathTag2 in xPathTag2ListArray)
                {
                    XmlNodeList xNodeListTag2 = xSequenceNode.SelectNodes(xPathTag2);
                    foreach (XmlNode xNode in xNodeListTag2)
                    {
                        if (xNode != null)
                        {
                            return true;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return false;

        }

        /// <method>
        ///		IsValidCurrencyInSignCodeAmount
        /// </method>
        /// <summary>
        ///		This method performs a check on the Currencies of all tags specified in xPath and xPath1.
        ///		This is an overloaded function which takes into account the structure of signcodeamount
        ///		and then performs validation for currency for tags using this structure.
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPath" type = "string">
        ///		List of Comma Separated xPaths which contain Currency as seperate Field
        /// </param>
        /// <param name="xPath1" type = "string">
        ///		List of Comma Separated xPath which contain Currency Clubbed with other fields i.e. SignCodeAmount.
        ///		Here Code part Contains Currency.
        /// </param>
        /// <param name="errorCode" type = "string">
        ///		Error code to be displayed.
        /// </param>
        /// <param name="policyName" type = "string">
        ///		Input Containing PolicyName
        /// </param>
        /// <param name="ruleName" type = "string">
        ///		Input Containing Rule Name
        /// </param>
        ///	<param name="messageType" type = "string">
        ///		Input Containing MessageType.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        ///		Input Containing Conditional Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber" type = "string">
        ///		Input containing Conditional Rule number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing Object Of ErrorCollection Class.
        /// </param>
        /// <returns>
        ///		boolean
        ///	</returns>

        public static bool IsValidCurrencyInSignCodeAmount(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xPath1,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCurrencyInSignCodeAmount" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);

            bool isValid = true;
            int lengthxPath = 0;
            int lengthxPath1 = 0;
            string currency = string.Empty;
            string tempValue = string.Empty;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                string currencyCode = string.Empty;


                XmlNode xRoot = xDocument.Document;

                if (xPath != null)
                {
                    string[] xPathArray = xPath.Split(Constants.CHRCOMMA);
                    lengthxPath = xPathArray.Length;

                    for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                    {
                        XmlNodeList xList = xRoot.SelectNodes(xPathArray[nCount].ToString());
                        if (xList.Count != 0)
                        {
                            if (currencyCode.CompareTo(Constants.BLANK) == 0)
                            {
                                currencyCode = xList.Item(0).InnerText.ToString().Trim();
                            }

                            foreach (XmlNode xNode in xList)
                            {
                                if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                                {
                                    if (xNode.InnerText.CompareTo(currencyCode) != 0)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                    }
                                }
                                else
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        xNode.ParentNode.ParentNode.Name, Constants.NOCONTENT);
                                    isValid = false;
                                }
                            }
                        }
                    }
                }

                if (xPath1 != null)
                {
                    string[] xPath1Array = xPath1.Split(Constants.CHRCOMMA);
                    lengthxPath1 = xPath1Array.Length;

                    for (int nCount = 0; nCount <= lengthxPath1 - 1; nCount++)
                    {
                        XmlNodeList xList = xRoot.SelectNodes(xPath1Array[nCount].ToString());

                        foreach (XmlNode xNode in xList)
                        {
                            if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                            {
                                int startPositionOfCurrency = 0;
                                currency = string.Empty;
                                tempValue = xNode.InnerText.Substring(3, 1);

                                if (Constants.ALPHASET.IndexOf(tempValue) == -1)
                                {
                                    startPositionOfCurrency = 0;
                                }

                                else
                                {
                                    startPositionOfCurrency = 1;
                                }

                                currency = xNode.InnerText.Substring(startPositionOfCurrency, 3);

                                if (currencyCode.CompareTo(Constants.BLANK) == 0)
                                {
                                    currencyCode = currency;
                                }

                                if (currency.CompareTo(currencyCode) != 0)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                            }
                            else
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNode.ParentNode.ParentNode.Name, Constants.NOCONTENT);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }


        /// <method>
        ///		CheckMandatoryField
        /// </method>
        /// <summary>
        ///		In a particular sequence,if a particular field with a certain qualifier is Present ,
        /// 	then another field with a certain qualifier is mandatory.Else not Present, the other field is optional.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath20C" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="qualifier1" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="qualifier2" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message Type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckMandatoryField(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath20C,
            string qualifier1,
            string qualifier2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckMandatoryField" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool bln1 = false;
            try
            {

                if (xDocument == null ||
                    xPath20C == null ||
                    xPath20C.Length == 0 ||
                    qualifier1 == null ||
                    qualifier1.Length == 0 ||
                    qualifier2 == null ||
                    qualifier2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequence = xRoot.SelectNodes(xPath20C);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        if (xNodeSequence.FirstChild != null)
                        {
                            if (xNodeSequence.FirstChild.InnerText.CompareTo(qualifier1) == 0 || xNodeSequence.FirstChild.InnerText.CompareTo(qualifier2) == 0)
                            {
                                bln1 = true;
                            }
                        }
                    }
                }

                if (bln1 == false)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		CheckTagPresence
        /// </method>
        /// <summary>
        ///		This method checks for the presence of a tag with particular field values.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		xPath of the Sequence in which Tag is present
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		xPath of the Tag
        /// </param>
        /// <param name ="xPathField1" type = "string">
        ///		xPath of the Field1
        /// </param>
        /// <param name ="valueField1" type = "string">
        ///		Value of Field1
        /// </param>
        /// <param name ="xPathField2" type = "string">
        ///		xPath of the Field2
        /// </param>
        /// <param name ="valueField2" type = "string">
        ///		Value of Field2
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckTagPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag,
            string xPathField1,
            string valueField1,
            string xPathField2,
            string valueField2)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckTagPresence:");
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathField1 == null ||
                    xPathField1.Length == 0 ||
                    valueField1 == null ||
                    xPathField2 == null ||
                    xPathField2.Length == 0 ||
                    valueField2 == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    XmlNodeList xList = xNodeSequence.SelectNodes(xPathTag);

                    foreach (XmlNode xNode in xList)
                    {
                        XmlNode xNodeField1 = xNode.SelectSingleNode(xPathField1);
                        XmlNode xNodeField2 = xNode.SelectSingleNode(xPathField2);

                        if (xNodeField1 != null && xNodeField2 != null &&
                            xNodeField1.InnerText.CompareTo(valueField1) == 0 &&
                            xNodeField2.InnerText.CompareTo(valueField2) == 0)
                        {
                            return true;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return false;
        }


        /// <method>
        ///		SWIFTNetworkRule63_SRG2006
        /// </method>
        /// <summary>
        ///		In sequence A, if field 99B is present, then all qualifiers must be present (MT321).
        ///
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of element 99B of A Sequence to be validated.
        /// </param>
        /// <param name ="codeList1" type = "string">
        ///		Reference containing the list of the codes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the Conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>

        public static bool SWIFTNetworkRule63_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string codeList1,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule63_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int all99BQualifier = 0;
            try
            {

                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);
                // array contains total number of qualifiers
                string[] str99BQualifier = codeList1.Split(Constants.CHRCOMMA);

                foreach (XmlNode xNode in xList)
                {
                    //checking for 99B node.
                    if (xNode != null && xNode.FirstChild != null && xNode.FirstChild.InnerText != null)
                    {
                        //checking for qualifiers against array
                        for (int i = 0; i < str99BQualifier.Length; i++)
                        {
                            if (xNode.FirstChild.InnerText.CompareTo(str99BQualifier[i]) == 0)
                            {
                                all99BQualifier += 1;
                            }
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode.ParentNode.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
                if (all99BQualifier != str99BQualifier.Length)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        ///<method>
        ///		SWIFTNetworkRule60
        ///</method>
        /// <summary>
        /// 	In sequence B, the presence of the Currency and Amount to be Settled
        /// 	(field :19B::SETT) and the presence of the Next	Interest Due Date (field :98A::INTR)
        /// 	depend on the Type of Loan/Deposit Event (field :22H::TLDE) in sequence A as
        /// 	follows (Error code(s): C60). Message Number MT321
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPath22H">
        /// 	Input xPath of Field 22H
        /// </param>
        /// <param name="xPath19B">
        /// 	Input xPath of Field 19B
        /// </param>
        /// <param name="xPath98A">
        /// 	Input xPath of Field 98A
        /// </param>
        /// <param name="qualifier22H">
        /// 	Qualifier codelist of field 22H
        /// </param>
        /// <param name="qualifier19B">
        /// 	Qualifier codelist of field 19B
        /// </param>
        /// <param name="qualifier98A">
        /// 	Qualifier codelist of field 98A
        /// </param>
        /// <param name="xPathQualifier">
        /// 	Input xPath of Qualifier
        /// </param>
        /// <param name="xPathIndicator22H">
        /// 	Input Indicator of field 22H in comma separated list
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="codeList">
        ///		Input containing the code list.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        /// 	The Message Type that callls the function
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	ConditionalRule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	ConditionalRule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule60(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath22H,
            string xPath19B,
            string xPath98A,
            string qualifier22H,
            string qualifier19B,
            string qualifier98A,
            string xPathQualifier,
            string xPathIndicator22H,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule60" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPath22H == null ||
                    xPath22H.Length == 0 ||
                    xPath19B == null ||
                    xPath19B.Length == 0 ||
                    xPath98A == null ||
                    xPath98A.Length == 0 ||
                    qualifier22H == null ||
                    qualifier22H.Length == 0 ||
                    qualifier19B == null ||
                    qualifier19B.Length == 0 ||
                    qualifier98A == null ||
                    qualifier98A.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathIndicator22H == null ||
                    xPathIndicator22H.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    //Declare and Initialize all the function specific variables
                    bool isValid = true;
                    bool isFound = false;
                    bool isError = false;
                    int int19B = 0;
                    int int98A = 0;

                    XmlNode xRoot = xDocument.Document;
                    //Select the nodeSequence A, field 22H
                    XmlNode xNode22H = xRoot.SelectSingleNode(xPath22H);
                    //Select the Qualifier of field 22H
                    XmlNode xNode22HQualifier = xNode22H.SelectSingleNode(xPathQualifier);

                    if (xNode22HQualifier != null && xNode22HQualifier.InnerText.Length != 0)
                    {
                        if (xNode22HQualifier.InnerText.CompareTo(qualifier22H) == 0)
                        {
                            //Store the comma separated list codeList in an string array
                            string[] codeListArray = codeList.Split(Constants.COMMA.ToCharArray());
                            //Store the number of field 19B::SETT occurings in int19B
                            XmlNodeList xListNode19B = xRoot.SelectNodes(xPath19B);
                            if (xListNode19B.Count != 0)
                            {
                                foreach (XmlNode xNode19B in xListNode19B)
                                {
                                    XmlNode xNode19BQualifier = xNode19B.SelectSingleNode(xPathQualifier);
                                    if (xNode19BQualifier != null && xNode19BQualifier.InnerText.Length != 0 &&
                                        xNode19BQualifier.InnerText.CompareTo(qualifier19B) == 0)
                                        int19B++;
                                }
                            }
                            //Store the number of field 98A::INTR occurings in int98A
                            XmlNodeList xListNode98A = xRoot.SelectNodes(xPath98A);
                            if (xListNode98A.Count != 0)
                            {
                                foreach (XmlNode xNode98A in xListNode98A)
                                {
                                    XmlNode xNode98AQualifier = xNode98A.SelectSingleNode(xPathQualifier);
                                    if (xNode98AQualifier != null && xNode98AQualifier.InnerText.Length != 0 && xNode98AQualifier.InnerText.CompareTo(qualifier98A) == 0)
                                        int98A++;
                                }
                            }
                            //Select the node Indicator, field 22H
                            XmlNode xNode22HIndicator = xNode22H.SelectSingleNode(xPathIndicator22H);
                            //loop through all the codelist values
                            for (int count = 0; count <= codeListArray.Length - 1; count++)
                            {
                                if (codeListArray[count] == xNode22HIndicator.InnerText)
                                    isFound = true;
                                if (isFound)
                                {
                                    if (count == 0 && (int19B > 0 || int98A == 0))

                                        isError = true;

                                    else if (count == 1 && (int19B == 0 || int98A > 0))

                                        isError = true;

                                    else if (count == 2 && (int19B == 0 || int98A == 0))

                                        isError = true;
                                }

                                isFound = false;
                                if (isError)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                    isError = false;

                                }
                            }
                        }
                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        ///<method>
        ///		SWIFTNetworkRule61
        ///</method>
        /// <summary>
        /// 	In sequence B, the presence of the Last Day of the First Interest Period (field :98A::LDFP)
        /// 	depends on the value of the Indicator of Type of Loan/Deposit Event (field :22H::TLDE)
        /// 	as follows (Error code(s): C61):
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPath22H">
        /// 	Input xPath of Field 22H
        /// </param>
        /// <param name="xPath98A">
        /// 	Input xPath of Field 98A
        /// </param>
        /// <param name="qualifier22H">
        /// 	Qualifier codelist of field 22H
        /// </param>
        /// <param name="qualifier98A">
        /// 	Qualifier codelist of field 98A
        /// </param>
        /// <param name="xPathQualifier">
        /// 	Input xPath of Qualifier
        /// </param>
        /// <param name="xPathIndicator22H">
        /// 	Input Indicator of field 22H in comma separated list
        /// </param>
        /// <param name="codeList">
        ///		Input containing the code list.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        /// 	The Message Type that calls the function
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	ConditionalRule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	ConditionalRule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule61(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath22H,
            string xPath98A,
            string qualifier22H,
            string qualifier98A,
            string xPathQualifier,
            string xPathIndicator22H,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule61" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPath22H == null ||
                    xPath22H.Length == 0 ||
                    xPath98A == null ||
                    xPath98A.Length == 0 ||
                    qualifier22H == null ||
                    qualifier22H.Length == 0 ||
                    qualifier98A == null ||
                    qualifier98A.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathIndicator22H == null ||
                    xPathIndicator22H.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    bool isValid = true;

                    XmlNode xRoot = xDocument.Document;
                    //Select the nodeSequence A, field 22H
                    XmlNode xNode22H = xRoot.SelectSingleNode(xPath22H);
                    XmlNode xNode22HQualifier = xNode22H.SelectSingleNode(xPathQualifier);

                    if (xNode22HQualifier != null && xNode22HQualifier.InnerText.Length != 0 && xNode22HQualifier.InnerText.CompareTo(qualifier22H) == 0)
                    {
                        //Select the node Indicator, field 22H
                        XmlNode xNode22HIndicator = xNode22H.SelectSingleNode(xPathIndicator22H);
                        if (xNode22HIndicator != null && xNode22HIndicator.InnerText.Length != 0)
                        {
                            if (xNode22HIndicator.InnerText.CompareTo(codeList) == 0)
                            {
                                XmlNodeList xListNode98A = xRoot.SelectNodes(xPath98A);
                                if (xListNode98A.Count != 0)
                                {
                                    foreach (XmlNode xNode98A in xListNode98A)
                                    {
                                        XmlNode xNode98AQualifier = xNode98A.SelectSingleNode(xPathQualifier);
                                        if (xNode98AQualifier != null && xNode98AQualifier.InnerText.Length != 0 && xNode98AQualifier.InnerText.CompareTo(qualifier98A) == 0)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isValid = false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        /// <method>
        ///			SWIFTNetworkRule62
        /// </method>
        /// <summary>
        /// In sequence B, the presence of the Number of Days Accrued (field :99B::DAAC) depends on the presence of the Last
        /// Day of the First Interest Period (field :98A::LDFP) as follows (Error code(s): C62
        /// </summary>
        /// <param name="xDocument">Input containing the xml document to be validated.</param>
        /// <param name="xPathSequence">xPath of Sequence B</param>
        /// <param name="xPath98A">Input xPath of Field 98A</param>
        /// <param name="xPath99B">Input xPath of Field 22H</param>
        /// <param name="qualifier98A">Qualifier codelist of field 98A</param>
        /// <param name="qualifier99B">Qualifier codelist of field 99B</param>
        /// <param name="xPathQualifier">Input xPath of Qualifier</param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">The Message Type that callls the function</param>
        /// <param name="conditionalRuleName">ConditionalRule Name</param>
        /// <param name="conditionalRuleNumber">ConditionalRule Number</param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule62(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath98A,
            string xPath99B,
            string qualifier98A,
            string qualifier99B,
            string xPathQualifier,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule62" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath98A == null ||
                    xPath98A.Length == 0 ||
                    xPath99B == null ||
                    xPath99B.Length == 0 ||
                    qualifier98A == null ||
                    qualifier98A.Length == 0 ||
                    qualifier99B == null ||
                    qualifier99B.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    bool is98APresent = false;
                    bool is99BPresent = false;
                    XmlNode xRoot = xDocument.Document;
                    //Select the nodeSequence B
                    XmlNode xNodeSequence = xRoot.SelectSingleNode(xPathSequence);
                    if (xNodeSequence != null && xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        XmlNodeList xListNode98A = xNodeSequence.SelectNodes(xPath98A);
                        XmlNode xNode99B = xNodeSequence.SelectSingleNode(xPath99B);

                        foreach (XmlNode xNode98A in xListNode98A)
                        {

                            XmlNode xNode98AQualifier = xNode98A.SelectSingleNode(xPathQualifier);
                            if (xNode98AQualifier != null &&
                                xNode98AQualifier.InnerText.Length != 0
                                && xNode98AQualifier.InnerText.CompareTo(qualifier98A) == 0)
                            {
                                is98APresent = true;

                            }
                        }
                        if (xNode99B != null)
                        {
                            XmlNode xNode99BQualifier = xNode99B.SelectSingleNode(xPathQualifier);
                            if (xNode99BQualifier.InnerText.Length != 0 &&
                                xNode99BQualifier.InnerText.CompareTo(qualifier99B) == 0)
                            {
                                is99BPresent = true;
                            }
                        }

                        if (is99BPresent ^ is98APresent)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            isValid = false;
                        }

                    }


                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule64
        /// </method>
        /// <summary>
        ///			In each occurrence of sequence C, the following party fields must be present exactly once (Error code(s): C64):
        /// </summary>
        /// <param name="xDocument">Input containing the xml document to be validated.</param>
        /// <param name="xPathSequence">xPath of Sequence C</param>
        /// <param name="xPathSubSequence">xPath of Sequence C1</param>
        /// <param name="xPath95a">xPath of 95a Fields in comma separated list</param>
        /// <param name="xPathQualifier95a">xPath of Qualifier</param>
        /// <param name="codeList">codelist value</param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">The Message Type that callls the function</param>
        /// <param name="conditionalRuleName">ConditionalRule Name</param>
        /// <param name="conditionalRuleNumber">ConditionalRule Number</param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule64(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPath95a,
            string xPathQualifier95a,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule64" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath95a == null ||
                    xPath95a.Length == 0 ||
                    xPathQualifier95a == null ||
                    xPathQualifier95a.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    bool isValid = true;
                    int intcount95a = 0;
                    XmlNode xRoot = xDocument.Document;
                    //Select the nodeSequence C
                    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                    string[] xPath95aList = xPath95a.Split(Constants.COMMA.ToCharArray());

                    if (xListSequence.Count != 0)
                    {
                        foreach (XmlNode xNodeSequence in xListSequence)
                        {
                            XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);
                            if (xListSubSequence.Count != 0)
                            {
                                foreach (XmlNode xNodeSubSequence in xListSubSequence)
                                {
                                    foreach (string xPath in xPath95aList)
                                    {
                                        XmlNode xNode95a = xNodeSubSequence.SelectSingleNode(xPath);
                                        if (xNode95a != null && xNode95a.InnerText.Length != 0)
                                        {
                                            XmlNode xNodeQualifier95a = xNode95a.SelectSingleNode(xPathQualifier95a);
                                            if (xNodeQualifier95a != null && xNodeQualifier95a.InnerText.Length != 0)
                                            {
                                                if (xNodeQualifier95a.InnerText.CompareTo(codeList) == 0)
                                                    intcount95a++;
                                            }
                                        }
                                    }
                                }
                            }

                        }
                    }
                    if (intcount95a != 1)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        ///<method>
        ///	SWIFTNetworkRule290
        ///</method>
        /// <summary>
        /// In a message, One occurrence of sequence C must have the following value (Error code(s): E90):And the
        /// combinations of qualifier and indicator is given
        /// </summary>
        /// <param name="xDocument">Input containing the xml document to be validated.</param>
        /// <param name="xPathSequence">xPath of Sequence C</param>
        /// <param name="xPath22H">xPath of Field 22H</param>
        /// <param name="xPathQualifier22H">xPath of Qualifier</param>
        /// <param name="xPathIndicator22H">xPath of Indicator</param>
        /// <param name="codeListQualifier">codelist of qualifier</param>
        /// <param name="codeListIndicator">codelist of indicator</param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">The Message Type that callls the function</param>
        /// <param name="conditionalRuleName">ConditionalRule Name</param>
        /// <param name="conditionalRuleNumber">ConditionalRule Number</param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule290(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath22H,
            string xPathQualifier22H,
            string xPathIndicator22H,
            string codeListQualifier,
            string codeListIndicator,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule290" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath22H == null ||
                    xPath22H.Length == 0 ||
                    xPathQualifier22H == null ||
                    xPathQualifier22H.Length == 0 ||
                    xPathIndicator22H == null ||
                    xPathIndicator22H.Length == 0 ||
                    codeListQualifier == null ||
                    codeListQualifier.Length == 0 ||
                    codeListIndicator == null ||
                    codeListIndicator.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    bool isValid = true;
                    bool isFound = false;
                    XmlNode xRoot = xDocument.Document;
                    //Select the nodeSequence C
                    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                    if (xListSequence.Count != 0)
                    {
                        foreach (XmlNode xNodeSequence in xListSequence)
                        {
                            XmlNode xNode22H = xNodeSequence.SelectSingleNode(xPath22H);
                            if (xNode22H != null && xNode22H.InnerText != null && xNode22H.InnerText.Length != 0)
                            {
                                XmlNode xNodeQualifier22H = xNode22H.SelectSingleNode(xPathQualifier22H);
                                XmlNode xNodeIndicator22H = xNode22H.SelectSingleNode(xPathIndicator22H);
                                if (xNodeQualifier22H.InnerText.CompareTo(codeListQualifier) == 0 && xNodeIndicator22H.InnerText.CompareTo(codeListIndicator) == 0)
                                {
                                    isFound = true;
                                }
                            }

                        }
                    }
                    if (!(isFound))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }


        ///<method>
        ///	SWIFTNetworkRule292
        ///</method>
        /// <summary>
        /// In a message, the sequence C fields cannot appear more than once (Error code(s): E92):And the
        /// combinations of qualifier and indicator is given
        /// </summary>
        /// <param name="xDocument">Input containing the xml document to be validated.</param>
        /// <param name="xPathSequence">xPath of Sequence C</param>
        /// <param name="xPath22H">xPath of Field 22H</param>
        /// <param name="xPathQualifier22H">xPath of Qualifier</param>
        /// <param name="xPathIndicator22H">xPath of Indicator</param>
        /// <param name="codeListQualifier">codelist of qualifier </param>
        /// <param name="codeListIndicator">codelist of indicator in a comma separated string</param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">The Message Type that callls the function</param>
        /// <param name="conditionalRuleName">ConditionalRule Name</param>
        /// <param name="conditionalRuleNumber">ConditionalRule Number</param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule292(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath22H,
            string xPathQualifier22H,
            string xPathIndicator22H,
            string codeListQualifier,
            string codeListIndicator,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule292" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath22H == null ||
                    xPath22H.Length == 0 ||
                    xPathQualifier22H == null ||
                    xPathQualifier22H.Length == 0 ||
                    xPathIndicator22H == null ||
                    xPathIndicator22H.Length == 0 ||
                    codeListQualifier == null ||
                    codeListQualifier.Length == 0 ||
                    codeListIndicator == null ||
                    codeListIndicator.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    bool isValid = true;
                    int int22HCount = 0;
                    //Store the comma separated list codeList in an array
                    string[] codeListIArray = codeListIndicator.Split(Constants.COMMA.ToCharArray());

                    XmlNode xRoot = xDocument.Document;
                    //Select the nodeSequence C
                    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                    if (xListSequence.Count != 0)
                    {
                        for (int count = 0; count <= codeListIArray.Length - 1; count++)
                        {
                            foreach (XmlNode xNodeSequence in xListSequence)
                            {
                                XmlNode xNode22H = xNodeSequence.SelectSingleNode(xPath22H);
                                if (xNode22H != null && xNode22H.InnerText.Length != 0)
                                {
                                    XmlNode xNodeQualifier22H = xNode22H.SelectSingleNode(xPathQualifier22H);
                                    XmlNode xNodeIndicator22H = xNode22H.SelectSingleNode(xPathIndicator22H);
                                    if (xNodeQualifier22H.InnerText.CompareTo(codeListQualifier) == 0 && xNodeIndicator22H.InnerText.CompareTo(codeListIArray[count]) == 0)
                                    {
                                        int22HCount++;
                                    }
                                }
                            }
                            if (int22HCount > 1)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                            int22HCount = 0;
                        }
                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        /// <method>
        ///		SWIFTNetworkRule284
        /// </method>
        /// <summary>
        /// In each occurrence of sequence C, the following party fields for subsequence C1 cannot appear more than once (Error
        /// code(s): E84):
        /// </summary>
        /// <param name="xDocument">Input containing the xml document to be validated.</param>
        /// <param name="xPathSequence">xPath of Sequence</param>
        /// <param name="xPathSubSequence">xPath of SubSequence </param>
        /// <param name="xPath95a">xPaths of Field 95a</param>
        /// <param name="xPathQualifier">xPath of Qualifier</param>
        /// <param name="codeList">Qualifier list in comma separated string</param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">The Message Type that callls the function</param>
        /// <param name="conditionalRuleName">ConditionalRule Name</param>
        /// <param name="conditionalRuleNumber">ConditionalRule Number</param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule284(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPath95a,
            string xPathQualifier,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule284" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    xPath95a == null ||
                    xPath95a.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    bool isValid = true;
                    int intcount95a = 0;

                    //Store the comma separated list codeList in an array
                    string[] codeListArray = codeList.Split(Constants.COMMA.ToCharArray());
                    string[] xPath95aList = xPath95a.Split(Constants.COMMA.ToCharArray());
                    XmlNode xRoot = xDocument.Document;
                    //Select the nodeSequence
                    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                    if (xListSequence.Count != 0)
                    {
                        foreach (XmlNode xNodeSequence in xListSequence)
                        {
                            for (int count = 0; count <= codeListArray.Length - 1; count++)
                            {
                                XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);
                                if (xListSubSequence.Count != 0)
                                {
                                    foreach (XmlNode xNodeSubSequence in xListSubSequence)
                                    {
                                        foreach (string xPath in xPath95aList)
                                        {
                                            XmlNode xNode95a = xNodeSubSequence.SelectSingleNode(xPath);
                                            if (xNode95a != null && xNode95a.InnerText.Length != 0)
                                            {
                                                XmlNode xNodeQualifier95a = xNode95a.SelectSingleNode(xPathQualifier);
                                                if (xNodeQualifier95a != null && xNodeQualifier95a.InnerText.Length != 0 && xNodeQualifier95a.InnerText.CompareTo(codeListArray[count]) == 0)
                                                {
                                                    intcount95a++;
                                                }
                                            }
                                        }
                                    }
                                }
                                if (intcount95a > 1)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                                intcount95a = 0;
                            }
                        }
                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        /// <method>
        ///		SWIFTNetworkRule284_2011
        /// </method>
        /// <summary>
        ///In each occurrence of sequence B SSI Details, each of the qualifiers ACCW, INT1 and INT2 may only be present in 
        ///one iteration of subsequence B1 Cash Parties (Error code(s): E84)
        /// </summary>
        /// <param name="xDocument">Input containing the xml document to be validated.</param>
        /// <param name="xPathSequence">xPath of Sequence</param>
        /// <param name="xPathSubSequence">xPath of SubSequence </param>
        /// <param name="xPath95a">xPaths of Field 95a</param>
        /// <param name="xPathQualifier">xPath of Qualifier</param>
        /// <param name="codeList">Qualifier list in comma separated string</param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">The Message Type that callls the function</param>
        /// <param name="conditionalRuleName">ConditionalRule Name</param>
        /// <param name="conditionalRuleNumber">ConditionalRule Number</param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule284_2011(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPath95a,
            string xPathQualifier,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule284_2011" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    xPath95a == null ||
                    xPath95a.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                bool isValid = true;
                int loopCount = 0;
                Hashtable hashCodeList = null;

                //Store the comma separated list codeList in an array
                string[] codeListArray = codeList.Split(Constants.COMMA.ToCharArray());
                string[] xPath95aList = xPath95a.Split(Constants.COMMA.ToCharArray());

                XmlNode xRoot = xDocument.Document;

                //Select the nodeSequence
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                if (xListSequence.Count != 0)
                {
                    foreach (XmlNode xNodeSequence in xListSequence)
                    {
                        hashCodeList = new Hashtable();
                        XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);

                        foreach (XmlNode xNodeSubSequence in xListSubSequence)
                        {
                            foreach (string xPath in xPath95aList)
                            {
                                XmlNode xNode95a = xNodeSubSequence.SelectSingleNode(xPath);
                                if (xNode95a != null && xNode95a.InnerText.Length != 0)
                                {
                                    XmlNode xNodeQualifier95a = xNode95a.SelectSingleNode(xPathQualifier);
                                    if (xNodeQualifier95a != null && xNodeQualifier95a.InnerText.Length != 0 && codeList.IndexOf(xNodeQualifier95a.InnerText) != -1)
                                    {
                                        if (hashCodeList[xNodeQualifier95a.InnerText] == null)
                                        {
                                            hashCodeList.Add(xNodeQualifier95a.InnerText, loopCount);
                                        }
                                        else
                                            if (hashCodeList[xNodeQualifier95a.InnerText].ToString() != loopCount.ToString())
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                return isValid = false;
                                            }
                                    }
                                }
                            }
                            loopCount++;
                        }
                    }
                }
                return isValid;

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        /// <method>
        ///		SWIFTNetworkRule99
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 99.
        ///		In each occurrence of Sequence D, the presence of Subsequent
        ///		sequence D3 depends on field 94A of Sequence A, IF value is
        ///		'FORX' then not allowed and value is 'FXOP' then 'D3' is
        ///		mandatory.
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathCheckSequence" type = "string">
        ///		Input reference of the Sequence D.
        ///	</param>
        ///	<param name="xPathCheckSubSequence" type = "string">
        ///		Input reference of the Sequence D3.
        ///	</param>
        /// <param name="xPathNonRepetitiveFieldSequenceA" type = "string">
        ///		Input reference of the element 94A in Sequence A.
        /// </param>
        /// <param name="notAllowedValue" type = "string">
        ///		Value to check for not allowed sub sequence.
        ///	</param>
        ///	<param name="allowedValue" type = "string">
        ///		Value to check for allowed sub sequence.
        ///	</param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be
        ///		added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule99(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathCheckSequence,
            string xPathCheckSubSequence,
            string xPathNonRepetitiveFieldSequenceA,
            string notAllowedValue,
            string allowedValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule99" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathCheckSequence == null ||
                    xPathCheckSubSequence == null ||
                    xPathNonRepetitiveFieldSequenceA == null ||
                    notAllowedValue == null ||
                    allowedValue == null ||
                    xPathCheckSequence.Length == 0 ||
                    xPathCheckSubSequence.Length == 0 ||
                    xPathNonRepetitiveFieldSequenceA.Length == 0 ||
                    notAllowedValue.Length == 0 ||
                    allowedValue.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNode xNode_A = xRoot.SelectSingleNode(xPathNonRepetitiveFieldSequenceA);

                if (xNode_A != null)
                {
                    if (xNode_A.InnerText.CompareTo(notAllowedValue) == 0 &&
                        xRoot.SelectSingleNode(xPathCheckSubSequence) != null)
                    {
                        errorObject.AddError(errorCode, policyName,
                            ruleName, messageType, conditionalRuleName,
                            conditionalRuleNumber);
                        isValid = false;
                    }
                    else if (xNode_A.InnerText.CompareTo(allowedValue) == 0)
                    {

                        XmlNodeList xListD = xRoot.SelectNodes(xPathCheckSequence);
                        foreach (XmlNode xNodeD in xListD)
                        {
                            // suriyan - 2/10/2006 - Presharp warning 56506 -xPathCheckSubSquence can be null. how?

                            if (!IsConditionSatisfied(xNodeD,
                                //#pragma warning suppress 6506
                                xPathCheckSubSequence.Replace(Constants.DOUBLESLASH,
                                Constants.XPATH)))
                            {
                                errorObject.AddError(errorCode, policyName,
                                    ruleName, messageType, conditionalRuleName,
                                    conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		VerifyInstructionCodeOrder
        /// </method>
        /// <summary>
        ///		This method performs validation for Usage Rule of field 23E Instruction code, i.e.,
        ///		If multiple codes are used then Order of the codes must be as follows:
        ///		 i.		Instructions for the receiver of the message (CMSW,CMTO,...)
        ///		 ii.	Codes impacting the routing or composition of the resulting payment message (NETS,RTGS,...)
        ///		 iii.	Codes containing instructions for one of the following parties in the transaction chain (PHON,XYZ,...)
        ///		 iv.	Information Codes (OTHR,...)
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the element to be validated.
        ///		For e.g., //SequenceB
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated.
        ///		For e.g., ./InstructionCode_B_23E/InstructionCode
        /// </param>
        /// <param name ="instructionCodeList" type = "string">
        ///		Input containing the codelist.
        ///		 This list is a combination of the comma-separated codes list for each type.
        ///		 Where codelist for each type is separated by a pipe.
        ///		For e.g,
        ///			"CMSW,CMTO|NETS,RTGS|PHON|OTHR"
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        ///	</param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="sequenceName" type = "string">
        ///		Input containing the sequence Name.
        /// </param>
        /// <param name ="elementName" type = "string">
        ///		Input containing the element Name.
        /// </param>
        /// <param name ="elementValue" type = "string">
        ///		Input containing the element Value.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool VerifyInstructionCodeOrder(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence,
        //    string xPathTag,
        //    string instructionCodeList,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string sequenceName,
        //    string elementName,
        //    string elementValue,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPathSequence == null ||
        //        xPathSequence.Length == 0 ||
        //        xPathTag == null ||
        //        xPathTag.Length == 0 ||
        //        instructionCodeList == null ||
        //        instructionCodeList.Length == 0 ||
        //        policyName == null ||
        //        ruleName == null ||
        //        errorCode == null ||
        //        sequenceName == null ||
        //        elementName == null ||
        //        elementValue == null ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    XmlNode xRoot = xDocument.Document;

        //    string[] xListInstructionCode = instructionCodeList.Split(Constants.CHRPIPE);

        //    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
        //    bool bCodeMatchesTheOrder = true;
        //    foreach(XmlNode xNode in xListSequence)	//	SequenceB
        //    {
        //        XmlNodeList xNodeTagList = xNode.SelectNodes(xPathTag); // InstructionCode_B_23E/InstructionCode

        //        if(xNodeTagList.Count == 1)
        //            continue;

        //        int count = 0;
        //        foreach(XmlNode xNodeTag in xNodeTagList)
        //        {
        //            if(bCodeMatchesTheOrder == true)
        //                bCodeMatchesTheOrder = false;
        //            else
        //                break;

        //            string[] instructionCodes = xListInstructionCode[count].Split(Constants.CHRCOMMA);
        //            for(int j = 0; j < instructionCodes.Length; j++)
        //            {
        //                if(xNodeTag.InnerText.ToString().Equals(instructionCodes[j]))
        //                {
        //                    if(count <= xListInstructionCode.Length)
        //                    {
        //                        count++;
        //                    }
        //                    else
        //                        count = 0;
        //                    bCodeMatchesTheOrder = true;
        //                    break;
        //                }
        //            }
        //        }
        //        if(bCodeMatchesTheOrder == false)
        //        {
        //            //	If the order of the Instruction code does not match then give an error and stops
        //            errorObject.AddError(errorCode,policyName,ruleName,messageType,sequenceName,elementName,elementValue);
        //            return false;
        //        }
        //    }

        //    return true;
        //}

        /// <method>
        /// CheckNoPresence
        /// </method>
        /// <summary>
        /// This method checks the presence of Tag2 with specified value of
        /// Field1 in particular occurance of SeqeunceX when Tag1 with
        /// Specified values of field1 and field2 is NOT present in SAME
        /// OCCURANCE of SequenceX. The check performed depends on
        /// value Of isPresent, which is passed as boolean parameter.
        /// if isPresent is true then check is performed for tag2 being
        /// MANDATORY in Sequence X and when isPresent is false check is
        /// performed for tag2 being NOT ALLOWED in SequenceX
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///	Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///	Input reference of the sequence in which validation is to
        ///	performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        /// Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        /// Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field1" type = "string">
        /// Value of Field1 of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="xPathTag2Field1" type = "string">
        /// Input Reference of Field1 of Tag2
        /// </param>
        /// <param name="valueTag2Field1" type = "string">
        /// Value of Field1 of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        /// Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// boolean whose value depends upon the success of check performed.
        ///</returns>

        public static bool CheckNoPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag1List,
            string xPathTag1Field1,
            string valueTag1Field1,
            string xPathTag2List,
            string xPathTag2Field1,
            bool isPresent,
            string valueTag2Field1)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckNoPresence:");
            try
            {
                if (xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0 ||
                    xPathTag1Field1 == null ||
                    xPathTag1Field1.Length == 0 ||
                    valueTag1Field1 == null ||
                    valueTag1Field1.Length == 0 ||
                    xPathTag2Field1 == null ||
                    xPathTag2Field1.Length == 0 ||
                    valueTag2Field1 == null ||
                    valueTag2Field1.Length == 0
                    )
                {
                    return false;

                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;

                foreach (XmlNode xSequenceNode in xListSequence)
                {


                    isTag1ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag1List, xPathTag1Field1, valueTag1Field1);

                    isTag2ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag2List, xPathTag2Field1, valueTag2Field1);


                    if (!isTag1ConditionValid & (isTag2ConditionValid ^ isPresent))
                    {
                        return false;

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return true;

        }


        /// <method>
        /// CheckNoPresence
        /// </method>
        /// <summary>
        /// This method checks the presence of Tag2 with specified value of
        /// Field1 in particular occurance of SeqeunceX when Tag1 with
        /// Specified values of field1 and field2 is NOT present in SAME
        /// OCCURANCE of SequenceX. The check performed depends on
        /// value Of isPresent, which is passed as boolean parameter.
        /// if isPresent is true then check is performed for tag2 being
        /// MANDATORY in Sequence X and when isPresent is false check is
        /// performed for tag2 being NOT ALLOWED in SequenceX
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///	Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///	Input reference of the sequence in which validation is to
        ///	performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        /// Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        /// Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field1" type = "string">
        /// Value of Field1 of Tag1
        /// </param>
		///<param name="xPathTag1Field2" type = "string">
        /// Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field2" type = "string">
        /// Value of Field1 of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="xPathTag2Field1" type = "string">
        /// Input Reference of Field1 of Tag2
        /// </param>
        /// <param name="valueTag2Field1" type = "string">
        /// Value of Field1 of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        /// Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// boolean whose value depends upon the success of check performed.
        ///</returns>

        public static bool CheckNoPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag1List,
            string xPathTag1Field1,
            string valueTag1Field1,
            string xPathTag1Field2,
            string valueTag1Field2,
            string xPathTag2List,
            string xPathTag2Field1,
            bool isPresent,
            string valueTag2Field1)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckNoPresence:");
            try
            {
                if (xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0 ||
                    xPathTag1Field1 == null ||
                    xPathTag1Field1.Length == 0 ||
                    valueTag1Field1 == null ||
                    valueTag1Field1.Length == 0 ||
                    xPathTag1Field2 == null ||
                    xPathTag1Field2.Length == 0 ||
                    valueTag1Field2 == null ||
                    valueTag1Field2.Length == 0 ||
                    xPathTag2Field1 == null ||
                    xPathTag2Field1.Length == 0 ||
                    valueTag2Field1 == null ||
                    valueTag2Field1.Length == 0
                    )
                {
                    return false;

                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;

                foreach (XmlNode xSequenceNode in xListSequence)
                {


                    isTag1ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag1List, xPathTag1Field1, valueTag1Field1, xPathTag1Field2, valueTag1Field2);

                    isTag2ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag2List, xPathTag2Field1, valueTag2Field1);


                    if (!isTag1ConditionValid & (isTag2ConditionValid ^ isPresent))
                    {
                        return false;

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return true;

        }



        /// <method>
        ///		IsValidSenderInformation
        /// </method>
        /// <summary>
        ///		This method performs validation for the codes used in Sender to Receiver Information.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath72" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathField" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="valueField" type = "string">
        ///		Input Value of the element to be validated.
        /// </param>
        /// <param name ="valueCode" type = "string">
        ///		Input Value of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message Type.
        /// </param>
        /// <param name ="elementName" type = "string">
        ///		Input containing the name of the element.
        /// </param>
        /// <param name ="elementValue" type = "string">
        ///		Input containing the value of the element.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool IsValidSenderInformation(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathTag,
        //    string xPath72,
        //    string xPathField,
        //    string valueField,
        //    string valueCode,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string elementName,
        //    string elementValue,
        //    ErrorCollection errorObject)
        //{

        //    bool isValid = true;

        //    if(xDocument == null ||
        //        xPathTag == null ||
        //        xPathTag.Length == 0 ||
        //        xPath72 == null ||
        //        xPath72.Length == 0 ||
        //        xPathField == null ||
        //        xPathField.Length == 0 ||
        //        valueField == null ||
        //        valueCode == null ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        policyName == null ||
        //        policyName.Length == 0 ||
        //        ruleName == null ||
        //        ruleName.Length == 0 ||
        //        elementName	== null ||
        //        elementName.Length == 0 ||
        //        elementValue == null ||
        //        errorObject == null||
        //        errorObject == null)
        //    {
        //        return false;
        //    }


        //    XmlNode xRoot = xDocument.Document;

        //    XmlNodeList xNodeList = xRoot.SelectNodes(xPathTag);
        //    bool isexists = false;

        //    foreach(XmlNode xNodeTag in xNodeList)
        //    {
        //        isexists = false;
        //        if(xNodeTag.InnerText != null &&
        //            xNodeTag.InnerText.Length != 0 )
        //        {
        //            string child = null;
        //            if(xNodeTag.ChildNodes.Count > 1)
        //            {
        //                child = xNodeTag.FirstChild.InnerText +
        //                    Constants.SLASH + xNodeTag.LastChild.InnerText;
        //            }
        //            else
        //            {
        //                child = xNodeTag.InnerText;
        //            }
        //            if(xNodeTag.SelectSingleNode(xPathField) != null &&
        //                xNodeTag.SelectSingleNode(xPathField).InnerText.
        //                EndsWith(valueField) )
        //            {
        //                XmlNode xNode = xRoot.SelectSingleNode(xPath72);
        //                for(int Count = 0; Count <xNode.ChildNodes.Count ;
        //                    Count++)
        //                {
        //                    string childValue = xNode.ChildNodes[Count].
        //                        InnerText;
        //                    string textToStart = valueCode + child;
        //                    if (childValue.StartsWith(valueCode) &&
        //                        childValue.StartsWith(textToStart))

        //                    {
        //                        isexists = true;
        //                        break ;

        //                    }

        //                }

        //                if(!isexists)
        //                {
        //                    errorObject.AddError(errorCode,policyName,ruleName, messageType,
        //                        elementName, elementValue);
        //                    isValid = false;
        //                }
        //            }
        //        }
        //    }
        //    return isValid;
        //}

        /// <method>
        /// 	CheckPresence
        /// </method>
        /// <summary>
        /// 	This method checks the presence of tag1 and tag2 depending on the isPresent1
        /// 	and isPresent2 values passed inside the sequence.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the sequence in which validation is to
        ///		performed.
        /// </param>
        /// <param name="xPathTagList1" type = "string" >
        /// 	Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTagList2" type = "string">
        /// 	Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="isPresent1" type = "boolean">
        /// 	Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <param name="isPresent2" type = "boolean">
        /// 	Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// 	boolean whose value depends upon the success of check performed.
        ///</returns>
        public static bool CheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTagList1,
            string xPathTagList2,
            bool isPresent1,
            bool isPresent2)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckPresence:");
            try
            {
                if (xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTagList1 == null ||
                    xPathTagList1.Length == 0 ||
                    xPathTagList2 == null ||
                    xPathTagList2.Length == 0
                    )
                {
                    return false;

                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;

                foreach (XmlNode xSequenceNode in xListSequence)
                {

                    isTag1ConditionValid = IsConditionSatisfied(xSequenceNode
                        , xPathTagList1);

                    isTag2ConditionValid = IsConditionSatisfied(xSequenceNode,
                        xPathTagList2);

                    if (!(isPresent1 ^ isTag1ConditionValid) & (isTag2ConditionValid ^ isPresent2))
                    {
                        return false;

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return true;

        }

        /// <method>
        ///		SWIFTNetworkRule283
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 283 to
        ///		be implemented.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathList" type = "string">
        ///		Input containing the comma separated xPaths of the Tag
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Input containing the comma separated Qualifier values
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule283(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathList,
            string qualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule283" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathList == null ||
                    xPathList.Length == 0 ||
                    qualifierList == null ||
                    qualifierList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleNumber == null ||
                    errorObject == null)
                {
                    return false;
                }

                string strQualifier = null;
                int lengthxPath = 0;

                string qualifierListTemp = qualifierList + Constants.COMMA;

                //Put all the xPaths of the Tag in a string array
                string[] xPathArray = xPathList.Split(Constants.CHRCOMMA);
                lengthxPath = xPathArray.Length;

                XmlNode xRoot = xDocument.Document;

                //Check for each xPath
                for (int count = 0; count <= lengthxPath - 1; count++)
                {
                    XmlNodeList xList = xRoot.SelectNodes(xPathArray[count].ToString());

                    foreach (XmlNode xNode in xList)
                    {
                        //If the Qualifier doesn't exist in the list, throw an error
                        if (qualifierListTemp.IndexOf(xNode.InnerText) == -1)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                        strQualifier = xNode.InnerText + Constants.COMMA;
                        qualifierListTemp = qualifierListTemp.Replace(strQualifier, Constants.BLANK);
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule60
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 60 to
        ///		be implemented
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the Sequence
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input containing the xPath of the Tag
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input containing the xPath of the Qualifier
        /// </param>
        /// <param name ="xPathIndicator" type = "string">
        ///		Input containing the xPath of the Indicator
        /// </param>
        /// <param name ="qualifierValueList" type = "string">
        ///		Input containing the comma separated Qualifier values
        /// </param>
        /// <param name ="indicatorValueList" type = "string">
        ///		Input containing the comma separated Indicator values
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule60(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag,
            string xPathQualifier,
            string xPathIndicator,
            string qualifierValueList,
            string indicatorValueList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule60" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathIndicator == null ||
                    xPathIndicator.Length == 0 ||
                    qualifierValueList == null ||
                    qualifierValueList.Length == 0 ||
                    indicatorValueList == null ||
                    indicatorValueList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleNumber == null ||
                    errorObject == null)
                {
                    return false;
                }


                //Put the values of the Qualifier in a string array
                string[] qualifierArray = qualifierValueList.Split(Constants.CHRCOMMA);
                //Put the values of the Indicator in a string array
                string[] indicatorArray = indicatorValueList.Split(Constants.CHRCOMMA);

                if (!(CheckPresence(xDocument, xPathSequence, xPathTag, xPathQualifier,
                    qualifierArray[0], xPathIndicator, indicatorArray[0], xPathTag,
                    xPathQualifier, qualifierArray[1], false)) ||
                    !(CheckPresence(xDocument, xPathSequence, xPathTag, xPathQualifier,
                    qualifierArray[0], xPathIndicator, indicatorArray[1], xPathTag,
                    xPathQualifier, qualifierArray[1], true)) ||
                    !(CheckPresence(xDocument, xPathSequence, xPathTag, xPathQualifier,
                    qualifierArray[0], xPathIndicator, indicatorArray[1], xPathTag,
                    xPathQualifier, qualifierArray[2], true)))
                {
                    errorObject.AddError(errorCode, policyName,
                        ruleName, messageType, conditionalRuleName,
                        conditionalRuleNumber);
                    isValid = false;

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule63
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 63 to
        ///		be implemented
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the Sequence
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input containing the xPath of the Tag
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input containing the xPath of the Qualifier
        /// </param>
        /// <param name ="xPathIndicator" type = "string">
        ///		Input containing the xPath of the Indicator
        /// </param>
        /// <param name ="qualifierValueList" type = "string">
        ///		Input containing the comma separated Qualifier values
        /// </param>
        /// <param name ="indicatorValueList" type = "string">
        ///		Input containing the comma separated Indicator values
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule63(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag,
            string xPathQualifier,
            string xPathIndicator,
            string qualifierValueList,
            string indicatorValueList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule63" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathIndicator == null ||
                    xPathIndicator.Length == 0 ||
                    qualifierValueList == null ||
                    qualifierValueList.Length == 0 ||
                    indicatorValueList == null ||
                    indicatorValueList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleNumber == null ||
                    errorObject == null)
                {
                    return false;
                }


                //Put the values of the Qualifier in a string array
                string[] qualifierArray = qualifierValueList.Split(Constants.CHRCOMMA);
                //Put the values of the Indicator in a string array
                string[] indicatorArray = indicatorValueList.Split(Constants.CHRCOMMA);

                if ((CheckTagPresence(xDocument, xPathSequence, xPathTag, xPathQualifier,
                    qualifierArray[0], xPathIndicator, indicatorArray[0]) ||
                    (CheckTagPresence(xDocument, xPathSequence, xPathTag, xPathQualifier,
                    qualifierArray[0], xPathIndicator, indicatorArray[1]) &&
                    CheckTagPresence(xDocument, xPathSequence, xPathTag, xPathQualifier,
                    qualifierArray[1], xPathIndicator, indicatorArray[2]) &&
                    CheckTagPresence(xDocument, xPathSequence, xPathTag, xPathQualifier,
                    qualifierArray[2], xPathIndicator, indicatorArray[3]))) &&
                    CheckTagPresence(xDocument, xPathSequence, xPathTag, xPathQualifier,
                    qualifierArray[3], xPathIndicator, indicatorArray[4]))
                {

                    errorObject.AddError(errorCode, policyName,
                        ruleName, messageType, conditionalRuleName,
                        conditionalRuleNumber);
                    isValid = false;

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule64
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 64 to
        ///		be implemented
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequenceA" type = "string">
        ///		Input containing the xPath of the Sequence A
        /// </param>
        /// <param name ="xPathSequenceD" type = "string">
        ///		Input containing the xPath of the Sequence D
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input containing the xPath of the Tag
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input containing the xPath of the Qualifier
        /// </param>
        /// <param name ="xPathIndicator" type = "string">
        ///		Input containing the xPath of the Indicator
        /// </param>
        /// <param name ="qualifierValueList" type = "string">
        ///		Input containing the comma separated Qualifier values
        /// </param>
        /// <param name ="indicatorValueList" type = "string">
        ///		Input containing the comma separated Indicator values
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule64(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceA,
            string xPathSequenceD,
            string xPathTag,
            string xPathQualifier,
            string xPathIndicator,
            string qualifierValueList,
            string indicatorValueList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule64" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceA == null ||
                    xPathSequenceA.Length == 0 ||
                    xPathSequenceD == null ||
                    xPathSequenceD.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathIndicator == null ||
                    xPathIndicator.Length == 0 ||
                    qualifierValueList == null ||
                    qualifierValueList.Length == 0 ||
                    indicatorValueList == null ||
                    indicatorValueList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleNumber == null ||
                    errorObject == null)
                {
                    return false;
                }

                int countOptional = 0;
                int countMandatory = 0;

                //Put the values of the Qualifier in a string array
                string[] qualifierArray = qualifierValueList.Split(Constants.CHRCOMMA);
                //Put the values of the Indicator in a string array
                string[] indicatorArray = indicatorValueList.Split(Constants.CHRCOMMA);

                XmlNode xRoot = xDocument.Document;
                //Select all the nodes of Sequence D
                XmlNodeList xListSequenceD = xRoot.SelectNodes(xPathSequenceD);

                //Check if the condition, where Sequence D is optional exists
                if (CheckTagPresence(xDocument, xPathSequenceA, xPathTag, xPathQualifier,
                    qualifierArray[0], xPathIndicator, indicatorArray[0]) &&
                    CheckTagPresence(xDocument, xPathSequenceA, xPathTag, xPathQualifier,
                    qualifierArray[3], xPathIndicator, indicatorArray[4]))
                {
                    countOptional++;
                }

                //Check if the condition, where Sequence D is mandatory exists
                if (CheckTagPresence(xDocument, xPathSequenceA, xPathTag, xPathQualifier,
                    qualifierArray[0], xPathIndicator, indicatorArray[1]) &&
                    CheckTagPresence(xDocument, xPathSequenceA, xPathTag, xPathQualifier,
                    qualifierArray[1], xPathIndicator, indicatorArray[2]) &&
                    CheckTagPresence(xDocument, xPathSequenceA, xPathTag, xPathQualifier,
                    qualifierArray[2], xPathIndicator, indicatorArray[3]) &&
                    CheckTagPresence(xDocument, xPathSequenceA, xPathTag, xPathQualifier,
                    qualifierArray[3], xPathIndicator, indicatorArray[4]))
                {
                    countMandatory++;
                }

                //If both the conditions where Sequence D can be present doesn't
                //exist and Sequence D exists (or) if the mandatory condition
                //exists and Sequence D doesn't exist, throw an error
                if ((countMandatory == 0 && countOptional == 0 && xListSequenceD.Count != 0) ||
                    (countMandatory != 0 && xListSequenceD.Count == 0))
                {
                    errorObject.AddError(errorCode, policyName,
                        ruleName, messageType, conditionalRuleName,
                        conditionalRuleNumber);
                    isValid = false;

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule61
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 61 to
        ///		be implemented
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the Sequence
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input containing the xPath of the Tag
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input containing the xPath of the Qualifier
        /// </param>
        /// <param name ="xPathIndicator" type = "string">
        ///		Input containing the xPath of the Indicator
        /// </param>
        /// <param name ="qualifierValueList" type = "string">
        ///		Input containing the comma separated Qualifier values
        /// </param>
        /// <param name ="indicatorValueList" type = "string">
        ///		Input containing the comma separated Indicator values
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule61(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag,
            string xPathQualifier,
            string xPathIndicator,
            string qualifierValueList,
            string indicatorValueList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule61" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathIndicator == null ||
                    xPathIndicator.Length == 0 ||
                    qualifierValueList == null ||
                    qualifierValueList.Length == 0 ||
                    indicatorValueList == null ||
                    indicatorValueList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleNumber == null ||
                    errorObject == null)
                {
                    return false;
                }

                string qualifierList = null;

                //Put the values of the Qualifier in a string array
                string[] qualifierArray = qualifierValueList.Split(Constants.CHRCOMMA);
                //Put the values of the Indicator in a string array
                string[] indicatorArray = indicatorValueList.Split(Constants.CHRCOMMA);

                //Creating xpath required for the ReturnXPathValueList function
                string xPath = string.Concat(Constants.SLASH, xPathTag.Substring(1), xPathQualifier.Substring(1));
                //Get all the Qualifiers present for the tag
                qualifierList = ReturnXPathValueList(xDocument, xPath);

                if (!(CheckPresence(xDocument, xPathSequence, xPathTag, xPathQualifier,
                    qualifierArray[0], xPathIndicator, indicatorArray[0], xPathTag,
                    xPathQualifier, qualifierArray[1], false)) ||
                    !(CheckPresence(xDocument, xPathSequence, xPathTag, xPathQualifier,
                    qualifierArray[0], xPathIndicator, indicatorArray[1], xPathTag,
                    xPathQualifier, qualifierArray[1], true)) ||
                    (qualifierList.IndexOf(qualifierArray[0]) == -1 &&
                    qualifierList.IndexOf(qualifierArray[1]) != -1))
                {
                    errorObject.AddError(errorCode, policyName,
                        ruleName, messageType, conditionalRuleName,
                        conditionalRuleNumber);
                    isValid = false;

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule62
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 62 to
        ///		be implemented
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequenceA" type = "string">
        ///		Input containing the xPath of the Sequence A
        /// </param>
        /// <param name ="xPathSequenceC" type = "string">
        ///		Input containing the xPath of the Sequence C
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input containing the xPath of the Tag
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input containing the xPath of the Qualifier
        /// </param>
        /// <param name ="xPathIndicator" type = "string">
        ///		Input containing the xPath of the Indicator
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the Qualifier value
        /// </param>
        /// <param name ="indicatorValueList" type = "string">
        ///		Input containing the comma separated Indicator values
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool SWIFTNetworkRule62(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceA,
            string xPathSequenceC,
            string xPathTag,
            string xPathQualifier,
            string xPathIndicator,
            string qualifierValue,
            string indicatorValueList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule62" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceA == null ||
                    xPathSequenceA.Length == 0 ||
                    xPathSequenceC == null ||
                    xPathSequenceC.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathIndicator == null ||
                    xPathIndicator.Length == 0 ||
                    qualifierValue == null ||
                    qualifierValue.Length == 0 ||
                    indicatorValueList == null ||
                    indicatorValueList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleNumber == null ||
                    errorObject == null)
                {
                    return false;
                }

                string qualifierList = null;

                //Put the values of the Indicator in a string array
                string[] indicatorArray = indicatorValueList.Split(Constants.CHRCOMMA);

                //Creating xpath required for the ReturnXPathValueList function
                string xPath = string.Concat(Constants.SLASH, xPathTag.Substring(1), xPathQualifier.Substring(1));
                //Get all the Qualifiers present for the tag
                qualifierList = ReturnXPathValueList(xDocument, xPath);

                XmlNode xRoot = xDocument.Document;
                //Select all the nodes of Sequence C
                XmlNodeList xListSequenceC = xRoot.SelectNodes(xPathSequenceC);

                if (((CheckTagPresence(xDocument, xPathSequenceA, xPathTag, xPathQualifier,
                    qualifierValue, xPathIndicator, indicatorArray[0]) ||
                    qualifierList.IndexOf(qualifierValue) == -1) &&
                    xListSequenceC.Count != 0) ||
                    (CheckTagPresence(xDocument, xPathSequenceA, xPathTag, xPathQualifier,
                    qualifierValue, xPathIndicator, indicatorArray[1]) &&
                    xListSequenceC.Count == 0))
                {
                    errorObject.AddError(errorCode, policyName,
                        ruleName, messageType, conditionalRuleName,
                        conditionalRuleNumber);
                    isValid = false;

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule291
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 291 to
        ///		be implemented
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequenceA" type = "string">
        ///		Input containing the xPath of the Sequence A
        /// </param>
        /// <param name ="xPathSequenceB3" type = "string">
        ///		Input containing the xPath of the Sequence B3
        /// </param>
        /// <param name ="xPathSequenceB3a" type = "string">
        ///		Input containing the xPath of the Sequence B3a
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input containing the xPath of the Tag
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input containing the xPath of the Qualifier
        /// </param>
        /// <param name ="xPathIndicator" type = "string">
        ///		Input containing the xPath of the Indicator
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the Qualifier value
        /// </param>
        /// <param name ="indicatorValueList" type = "string">
        ///		Input containing the comma separated Indicator values
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule291(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceA,
            string xPathSequenceB3,
            string xPathSequenceB3a,
            string xPathTag,
            string xPathQualifier,
            string xPathIndicator,
            string qualifierValue,
            string indicatorValueList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule291" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceA == null ||
                    xPathSequenceA.Length == 0 ||
                    xPathSequenceB3 == null ||
                    xPathSequenceB3.Length == 0 ||
                    xPathSequenceB3a == null ||
                    xPathSequenceB3a.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathIndicator == null ||
                    xPathIndicator.Length == 0 ||
                    qualifierValue == null ||
                    qualifierValue.Length == 0 ||
                    indicatorValueList == null ||
                    indicatorValueList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleNumber == null ||
                    errorObject == null)
                {
                    return false;
                }


                string qualifierList = null;
                int count = 0;

                //Put the values of the Indicator in a string array
                string[] indicatorArray = indicatorValueList.Split(Constants.CHRCOMMA);

                XmlNode xRoot = xDocument.Document;
                //Select all the nodes of Sequence B3
                XmlNodeList xListSequenceB3 = xRoot.SelectNodes(xPathSequenceB3);

                foreach (XmlNode xNodeSequenceB3 in xListSequenceB3)
                {
                    XmlNodeList xListSequenceB3a = xNodeSequenceB3.SelectNodes(xPathSequenceB3a);

                    //If Subsequence is present, increment the count
                    if (xListSequenceB3a.Count != 0)
                        count++;
                }

                //Creating xpath required for the ReturnXPathValueList function
                string xPath = string.Concat(Constants.SLASH, xPathTag.Substring(1), xPathQualifier.Substring(1));
                //Get all the Qualifiers present for the tag
                qualifierList = ReturnXPathValueList(xDocument, xPath);

                if (((CheckTagPresence(xDocument, xPathSequenceA, xPathTag, xPathQualifier,
                    qualifierValue, xPathIndicator, indicatorArray[1]) ||
                    CheckTagPresence(xDocument, xPathSequenceA, xPathTag, xPathQualifier,
                    qualifierValue, xPathIndicator, indicatorArray[2])) && (count != 0)) ||
                    ((CheckTagPresence(xDocument, xPathSequenceA, xPathTag, xPathQualifier,
                    qualifierValue, xPathIndicator, indicatorArray[0]) ||
                    qualifierList.IndexOf(qualifierValue) == -1) && (count != xListSequenceB3.Count)))
                {
                    errorObject.AddError(errorCode, policyName,
                        ruleName, messageType, conditionalRuleName,
                        conditionalRuleNumber);
                    isValid = false;

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule292
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 292 to
        ///		be implemented
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the Sequence
        /// </param>
        /// <param name ="xPathSubSequence" type = "string">
        ///		Input containing the xPath of the Subsequence
        /// </param>
        /// <param name ="xPathTag19B" type = "string">
        ///		Input containing the xPath of the 19B Tag
        /// </param>
        /// <param name ="xPathTagList95a" type = "string">
        ///		Input containing the comma separated xPaths of Tag 95a
        /// </param>
        /// <param name ="qualifierValueList19B" type = "string">
        ///		Input containing the comma separated Qualifier values for Tag 19B
        /// </param>
        /// <param name ="qualifierValueList95a" type = "string">
        ///		Input containing the comma separated Qualifier values for Tag 95a
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool SWIFTNetworkRule292(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPathTag19B,
            string xPathTagList95a,
            string qualifierValueList19B,
            string qualifierValueList95a,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            ErrorCollection errorObject,
            string conditionalRuleNumber)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule292" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    xPathTag19B == null ||
                    xPathTag19B.Length == 0 ||
                    xPathTagList95a == null ||
                    xPathTagList95a.Length == 0 ||
                    qualifierValueList19B == null ||
                    qualifierValueList19B.Length == 0 ||
                    qualifierValueList95a == null ||
                    qualifierValueList95a.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleNumber == null ||
                    errorObject == null)
                {
                    return false;
                }

                //Store all the Qualifier values of Tag 19B in an array
                string[] qualifierArray19B = qualifierValueList19B.Split(Constants.CHRCOMMA);
                //Store all the Qualifier values of Tag 95a in an array
                string[] qualifierArray95a = qualifierValueList95a.Split(Constants.CHRCOMMA);

                //Store all the xPaths of Tag 95a in an array
                string[] xPathArray = xPathTagList95a.Split(Constants.CHRCOMMA);
                int lengthArray = xPathArray.Length;

                XmlNode xRoot = xDocument.Document;
                //Select all the nodes of Sequence
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    string qualifierValue = null;
                    int count1 = 0;
                    int count2 = 0;
                    int count3 = 0;

                    //Select the 19B element in the Sequence
                    XmlNode xNode19B = xNodeSequence.SelectSingleNode(xPathTag19B);

                    //Get the Qualifier associated with the element
                    if (xNode19B != null)
                        qualifierValue = xNode19B.InnerText;

                    //Select all the nodes of Subsequence in Sequence
                    XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);

                    foreach (XmlNode xNodeSubSequence in xListSubSequence)
                    {
                        //Check for each xPath of Tag 95a
                        for (int count = 0; count < lengthArray; count++)
                        {
                            //Select the 95a element in the Subsequence
                            XmlNode xNode = xNodeSubSequence.SelectSingleNode(xPathArray[count].ToString());

                            if (xNode != null)
                            {
                                //Check if the Qualifier value is CDEA
                                if (xNode.InnerText.CompareTo(qualifierArray95a[0]) == 0)
                                    count1++;
                                //Check if the Qualifier value is ACCW
                                if (xNode.InnerText.CompareTo(qualifierArray95a[1]) == 0)
                                    count2++;
                                //Check if the Qualifier value is BENM
                                if (xNode.InnerText.CompareTo(qualifierArray95a[2]) == 0)
                                    count3++;
                            }
                        }
                    }

                    if ((qualifierValue == qualifierArray19B[0] && (count1 == 0 || count3 != 0)) ||
                        (qualifierValue == qualifierArray19B[1] && count2 == 0))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		IsValidCommonReference
        /// </method>
        /// <summary>
        ///		This method performs validation for the Usage Rule to
        ///		 be implemented for Tag 20C in message MT307
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input containing the xPath of the Tag
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing Qualifier value with which the Common Reference occurs
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool IsValidCommonReference(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string qualifierValue,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCommonReference" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    qualifierValue == null ||
                    qualifierValue.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    errorObject == null)
                {
                    return false;

                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.FirstChild != null && xNode.FirstChild.InnerText.CompareTo(qualifierValue) == 0
                        && xNode.LastChild != null)
                    {
                        string reference = xNode.LastChild.InnerText;

                        //If the length of Common reference is not equal to 16, throw an error
                        if (reference.Length != 16)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                xNode.Name, reference);
                            isValid = false;
                        }
                        else
                        {
                            int i, j = 0;

                            //Get all the Codes
                            string bankCode1 = reference.Substring(0, 4);
                            string locationCode1 = reference.Substring(4, 2);
                            string referenceCode = reference.Substring(6, 4);
                            string bankCode2 = reference.Substring(10, 4);
                            string locationCode2 = reference.Substring(14, 2);

                            //Store all the Bank Codes in an array
                            string[] bankCodes = { bankCode1, bankCode2 };
                            //Store all the Location Codes in an array
                            string[] locationCodes = { locationCode1, locationCode2 };
                            //Store each character of the Reference Code in an array
                            char[] numerics = referenceCode.ToCharArray();

                            for (i = 0; i < numerics.Length; i++)
                            {
                                //Check if each character is an numeric
                                if (Constants.NUMBERSET.IndexOf(numerics[i]) == -1)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        xNode.Name, referenceCode);
                                    return false;
                                }
                            }

                            for (j = 0; j < bankCodes.Length; j++)
                            {
                                //Store each character of the bank code in an array
                                char[] alphabets = bankCodes[j].ToCharArray();

                                for (i = 0; i < alphabets.Length; i++)
                                {
                                    //Check if each character is an alphabet
                                    if (Constants.ALPHASET.IndexOf(alphabets[i]) == -1)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName,
                                            xNode.Name, bankCodes[j]);
                                        return false;
                                    }
                                }
                            }

                            for (j = 0; j < locationCodes.Length; j++)
                            {
                                //Store each character of the location code in an array
                                char[] alphanumerics = locationCodes[j].ToCharArray();

                                for (i = 0; i < alphanumerics.Length; i++)
                                {
                                    //Check if each character is an alphanumeric
                                    if (Constants.ALPHANUMBERSET.IndexOf(alphanumerics[i]) == -1)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName,
                                            xNode.Name, locationCodes[j]);
                                        return false;
                                    }
                                }
                            }
                            //Check for the alphabetical order
                            isValid = CheckAlphabeticalOrder(bankCode1, locationCode1,
                                bankCode2, locationCode2, xNode.Name, errorCode,
                                policyName, ruleName, errorObject);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		CheckAlphabeticalOrder
        /// </method>
        /// <summary>
        ///		This method performs check for the alphabetical order among
        ///		 codes of Common Reference
        /// </summary>
        /// <param name ="bankCode1" type = "string">
        ///		Input containing the bankCode1 value
        /// </param>
        /// <param name ="locationCode1" type = "string">
        ///		Input containing the locationCode1 value
        /// </param>
        /// <param name ="bankCode2" type = "string">
        ///		Input containing the bankCode2 value
        /// </param>
        /// <param name ="locationCode2" type = "string">
        ///		Input containing the locationCode2 value
        /// </param>
        /// <param name ="elementName" type = "string">
        ///		Input containing Element name
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool CheckAlphabeticalOrder(string bankCode1,
            string locationCode1,
            string bankCode2,
            string locationCode2,
            string elementName,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckAlphabeticalOrder" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (bankCode1 == null ||
                    bankCode1.Length == 0 ||
                    locationCode1 == null ||
                    locationCode1.Length == 0 ||
                    bankCode2 == null ||
                    bankCode2.Length == 0 ||
                    locationCode2 == null ||
                    locationCode2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    errorObject == null)
                {
                    return false;

                }


                int cmpVal = bankCode1.CompareTo(bankCode2);
                //If Bank code2 is less than Bank code1 then throw an error
                if (cmpVal > 0)
                {
                    errorObject.AddError(errorCode, policyName, ruleName,
                        elementName, bankCode1);
                    isValid = false;
                }
                else if (cmpVal == 0)
                {
                    /*
                     If Bank code2 is equal to Bank code1
                     then check for Location code1 and Location code2
                    */

                    string check1 = null;
                    string check2 = null;

                    for (int count = 0; count <= locationCode1.Length - 1; count++)
                    {
                        //Check for alphabetical order of each letter of Location code1 and Location code 2
                        check1 = locationCode1.Substring(count, 1);
                        check2 = locationCode2.Substring(count, 1);

                        if ((Constants.NUMBERSET.IndexOf(check1) == -1) ^
                            (Constants.NUMBERSET.IndexOf(check2) == -1))
                        {
                            //Check for the letter of each location code that are not both alphabet or numeric
                            int cmpVal1 = check1.CompareTo(check2);
                            if (cmpVal1 < 0)
                            {
                                /* Raise error if letter of Location code 1 is not in ascending order with that of Location code 2
                                            for e.g. If 1st letter of Location code 1 is 1 and that of Location code 2 is A then raise an error
                                        */
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    elementName, locationCode1);
                                isValid = false;
                                break;
                            }
                            else if (cmpVal1 > 0)
                            {
                                //break the loop if letter of location code 1 is in ascending order with that of Location code 2
                                break;
                            }

                        }
                        else
                        {
                            //Check for the letter of each location code that are both alphabet or numeric

                            int cmpVal2 = check1.CompareTo(check2);
                            if (cmpVal2 > 0)
                            {
                                /*
                                Raise error if letter of Location code 1 is not in ascending order with that of Location code 2
                                for e.g. If 1st letter of Location code 1 is B and that of Location code 2 is A then raise an error
                                */
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    elementName, locationCode1);
                                isValid = false;
                                break;
                            }
                            else if (cmpVal2 < 0)
                            {
                                //break the loop if letter of location code 1 is in ascending order with that of Location code 2
                                break;
                            }
                        }

                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        /// 	SWIFTNetworkRule225
        /// </method>
        /// <summary>
        /// 	This function validates that if field 37J is present, then field 71G must also be present.
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        /// 	Input reference of the Sequence.
        /// </param>
        /// <param name="xPathNonRepetitiveFieldSequence">
        /// 	Input reference of the non-repetitive Sequence.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule225(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathNonRepetitiveFieldSequence,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule225" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == errorObject) throw new ArgumentNullException("errorObject");
                if (null == xDocument) throw new ArgumentNullException("xDocument");
                if (null == xPathNonRepetitiveFieldSequence) throw new ArgumentNullException("xPathNonRepetitiveFieldSequence");


                XmlNode Root = xDocument.Document;

                XmlNodeList List = Root.SelectNodes(xPathSequence);
                // 37J,71J
                string[] arrNonRepetitiveFieldSequence =
                    xPathNonRepetitiveFieldSequence.Split(
                    Constants.COMMA.ToCharArray());

                foreach (XmlNode Node in List)
                {
                    XmlNode Node37J =
                        Node.SelectSingleNode(arrNonRepetitiveFieldSequence[0]);

                    if (Node37J != null)
                    {
                        XmlNode Node71G = Node.SelectSingleNode(
                            arrNonRepetitiveFieldSequence[1]);
                        if (Node71G == null)
                        {
                            isValid = false;
                            errorObject.AddError(errorCode, policyName, ruleName,
                                messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            break;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        /// 	SWIFTNetworkRule228
        /// </method>
        /// <summary>
        /// 	Field 21 must be present either in Sequence A or in each occurrence of Sequence B but not in both.
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequenceA">
        /// 	Input reference of the Sequence B.
        /// </param>
        /// <param name="xPathSequenceB">
        /// 	Input reference of the Sequence C.
        /// </param>
        /// <param name="xPathNonRepetitiveFieldSequence">
        /// 	Input reference of the non-repetitive Sequence.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule228(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceA,
            string xPathSequenceB,
            string xPathNonRepetitiveFieldSequence,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule228" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == errorObject) throw new ArgumentNullException("errorObject");
                if (null == xDocument) throw new ArgumentNullException("xDocument");
                if (null == xPathNonRepetitiveFieldSequence) throw new ArgumentNullException("xPathNonRepetitiveFieldSequence");


                XmlNode Root = xDocument.Document;

                XmlNodeList ListA = Root.SelectNodes(xPathSequenceA);

                XmlNodeList ListB = Root.SelectNodes(xPathSequenceB);
                string[] arrNonRepetitiveFieldSequence =
                    xPathNonRepetitiveFieldSequence.Split(
                    Constants.COMMA.ToCharArray());

                foreach (XmlNode NodeB in ListB)
                {
                    // selecting single node from sequence B
                    XmlNode Node_B =
                        NodeB.SelectSingleNode(arrNonRepetitiveFieldSequence[0]);

                    // selecting single node from sequence A
                    XmlNode Node_A =
                        Root.SelectSingleNode(arrNonRepetitiveFieldSequence[1]);

                    if (Node_A != null)
                    {
                        if (Node_B != null)
                        {
                            isValid = false;
                            errorObject.AddError(errorCode, policyName, ruleName,
                                messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            break;
                        }
                    }
                    else
                    {
                        for (int j = 0; j <= ListB.Count; j++)
                        {
                            if (Node_B == null)
                            {
                                isValid = false;
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    messageType, conditionalRuleName,
                                    conditionalRuleNumber);
                                break;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule142
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 142
        ///		If Period From Of Field 38G Contains O,then SequenceE and Field 72 are Mandatory.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag38G">
        ///		Input reference of the element 38G (list separated by comma) to be validated.
        /// </param>
        /// <param name="xPathField">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name="xPathSequence">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name="tagValue">
        ///		Input Value of tag 38G.
        /// </param>
        /// <param name="xPathTag72">
        ///		Input reference of the element 72 to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule142(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag38G,
            string xPathField,
            string xPathSequence,
            string tagValue,
            string xPathTag72,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule142" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag38G == null ||
                    xPathSequence == null ||
                    xPathTag38G == null ||
                    tagValue == null ||
                    xPathTag72 == null ||
                    xPathTag38G.Length == 0 ||
                    xPathSequence.Length == 0 ||
                    tagValue.Length == 0 ||
                    xPathTag72.Length == 0 ||
                    xPathTag38G.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                XmlNode xNode38G = xRoot.SelectSingleNode(xPathTag38G);
                if (xNode38G != null && xNode38G.InnerText != null &&
                    xNode38G.InnerText.Length != 0)
                {

                    if (xNode38G.SelectSingleNode(xPathField) != null &&
                        xNode38G.SelectSingleNode(xPathField).InnerText.
                        EndsWith(tagValue))
                    {
                        if (xRoot.SelectSingleNode(xPathSequence) == null ||
                            xRoot.SelectSingleNode(xPathTag72) == null)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /*
        //
        COMMENTED AS PER CONFIRMATION FROM SWIFT
        BUG: 96563
        //
        /// <method>
        /// 	IsValidAmount
        /// </method>
        /// <summary>
        /// 	This method validates the Amount field.
        /// </summary>
        /// <param name="xNode">
        ///		Input reference of the node.
        /// </param>
        /// <param name="xPathTag33B">
        /// 	Input reference of the Element 33B.
        /// </param>
        /// <param name="xPathTag36">
        /// 	Input reference of the Element 36.
        /// </param>
        /// <param name="xPathTag71A">
        /// 	Input reference of the Element 71A.
        /// </param>
        /// <param name="xPathTag71F">
        /// 	Input reference of the Element 71F.
        /// </param>
        /// <param name="xPathTag71G">
        /// 	Input reference of the Element 71G.
        /// </param>
        /// <param name="xPathTag32">
        /// 	Input reference of the Element 32.
        /// </param>
        /// <param name="xPathCurrency32">
        /// 	Input reference of the Currency element..
        /// </param>
        /// <param name="qualifierValueList">
        /// 	nput containing the qualifier list.
        /// </param>
        /// <param name ="allowableroundoffPercent" type = "int">
        ///		Input containing the allowable difference in percentage between amount in Field 32A
        ///		and the amount calculated using the Field 33B with the applicable charges.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidAmount(XmlNode xNode,
            string xPathTag33B,
            string xPathTag36,
            string xPathTag71A,
            string xPathTag71F,
            string xPathTag71G,
            string xPathTag32,
            string xPathCurrency32,
            string qualifierValueList,
            int		roundoffPercent)
        {
            if(xNode == null ||
                xPathTag33B == null ||
                xPathTag33B.Length == 0 ||
                xPathTag36 == null ||
                xPathTag36.Length == 0 ||
                xPathTag71A == null ||
                xPathTag71A.Length == 0 ||
                xPathTag71F == null ||
                xPathTag71F.Length == 0 ||
                xPathTag71G == null ||
                xPathTag71G.Length == 0 ||
                xPathCurrency32 == null ||
                xPathCurrency32.Length == 0 ||
                xPathTag32 == null ||
                xPathTag32.Length == 0 ||
                qualifierValueList == null ||
                qualifierValueList.Length == 0 ||
                roundoffPercent > 100)
            {
                return false;
            }

            double rate = 0.0;
            double sendersCharges = 0.0;
            double receiversCharges = 0.0;
            double amount = 0.0;
            double finalAmount = 0.0;
            double tempAmount = 0.0;
            double tempAmount2 = 0.0; //Adding this to calculate the amount that is obtained by dividing the rate.


            XmlNode xNode36 = xNode.SelectSingleNode(xPathTag36);
            XmlNode xNode33B = xNode.SelectSingleNode(xPathTag33B);
            XmlNode xNode32 = xNode.SelectSingleNode(xPathTag32);
            XmlNode xNode71A = xNode.SelectSingleNode(xPathTag71A);
            XmlNode xNode71G = xNode.SelectSingleNode(xPathTag71G);
            XmlNodeList xList71F = xNode.SelectNodes(xPathTag71F);

            if(xNode33B != null && xNode33B.FirstChild != null
                && xNode32 != null && xNode32.SelectSingleNode(xPathCurrency32) != null)
            {
                if(xNode33B.FirstChild.InnerText.CompareTo(xNode32.SelectSingleNode(xPathCurrency32).InnerText)== 0)
                {
                    rate = 1.0;
                }

                else
                {
                    if(xNode36 != null && xNode36.FirstChild != null )
                    {
                        rate = Convert.ToDouble(xNode36.FirstChild.InnerText.Replace(Constants.CHRCOMMA,charDecimalSeparator));
                    }

                    else
                    {
                        return false;
                    }
                }
            }

            else
            {
                return false;
            }

            //To prevent overflow exception?
            if(!(rate > 0))
            {
                return false;
            }

            string[] codes = qualifierValueList.Split(Constants.CHRCOMMA);

            bool bIsSameCurrency = true;

            // 71F and 33B can have different currencies provided Field 36 is present.
            foreach(XmlNode xNode71F in xList71F)
            {
                if(xNode71F.FirstChild != null &&
                    xNode71F.FirstChild.InnerText.CompareTo(xNode33B.FirstChild.InnerText) != 0)
                {
                    // If 71F and 33B have different currencies and Field 36 is not present,
                    // then error out!!
                    if(xNode36 == null || xNode36.FirstChild == null)
                    {
                        return false;
                    }

                    // Set Flag, so that the Senders charge for this iteration can be included by
                    // multiplying it with the exchange rate. This flag will be rest after every loop
                    // (this will support specifying 71F with multiple currencies (support at the most two)?)
                    bIsSameCurrency = false;
                }

                if(xNode71F.LastChild != null)
                {
                    // If 71F and 33B have same currency, just add the senders charge to the total
                    if(bIsSameCurrency)
                    {
                        sendersCharges += Convert.ToDouble(xNode71F.LastChild.InnerText.Replace(Constants.CHRCOMMA,charDecimalSeparator));
                    }

                    // Else add to the total charges after multiplying the charge with the rate
                    else
                    {
                        sendersCharges += rate * Convert.ToDouble(xNode71F.LastChild.InnerText.Replace(Constants.CHRCOMMA,charDecimalSeparator));
                    }

                    // Reset flag
                    bIsSameCurrency = true;
                }
            }

            if(xNode71G != null && xNode71G.LastChild != null)
            {
                receiversCharges = Convert.ToDouble(xNode71G.LastChild.InnerText.Replace(Constants.CHRCOMMA,charDecimalSeparator));
            }


            amount = Convert.ToDouble(xNode33B.LastChild.InnerText.Replace(Constants.CHRCOMMA,charDecimalSeparator));

            finalAmount = Convert.ToDouble(xNode32.LastChild.InnerText.Replace(Constants.CHRCOMMA,charDecimalSeparator));

            if(xNode71A != null && xNode71A.FirstChild != null)
            {
                if(xNode71A.FirstChild.InnerText.CompareTo(codes[0])== 0)
                {
                    tempAmount = (amount * rate) + receiversCharges;
                    tempAmount2 = (amount / rate) + receiversCharges;
                }

                if(xNode71A.FirstChild.InnerText.CompareTo(codes[1])== 0)
                {
                    tempAmount = (amount - sendersCharges) * rate;
                    tempAmount2 = (amount - sendersCharges) / rate;
                }

                if(xNode71A.FirstChild.InnerText.CompareTo(codes[2])== 0)
                {
                    tempAmount = amount * rate;
                    tempAmount2 = amount / rate;
                }
            }

            else
            {
                return false;
            }

            // If round off percent is greater than 0, ensure that the calculated
            // amount is between the difference allowed off of the amount in field 32A
            if(roundoffPercent > 0)
            {
                double allowablediff = (roundoffPercent * finalAmount)/100;
                double lowerLimit = finalAmount - allowablediff;
                double upperLimit = finalAmount + allowablediff;

                if((Convert.ToInt64(lowerLimit) <= Convert.ToInt64(tempAmount) && Convert.ToInt64(tempAmount) <= Convert.ToInt64(upperLimit))
                    ||
                    (Convert.ToInt64(lowerLimit) <= Convert.ToInt64(tempAmount2) && Convert.ToInt64(tempAmount2) <= Convert.ToInt64(upperLimit)))
                    return true;
                else
                    return false;

            }

            // If round off is zero, do a direct comparision between the amounts involved
            if(Convert.ToInt64(finalAmount) != Convert.ToInt64(tempAmount))
            {
                return false;
            }

            return true;
        }
        */

        /*
        //
        COMMENTED AS PER CONFIRMATION FROM SWIFT
        BUG: 96563
        // 
        /// <method>
        /// 	IsValidInterbankSettledAmount
        /// </method>
        /// <summary>
        /// 	This method validates for the Interbank Settled Amount.
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag33B">
        /// 	Input reference of the Element 33B.
        /// </param>
        /// <param name="xPathTag36">
        /// 	Input reference of the Element 36.
        /// </param>
        /// <param name="xPathTag71A">
        /// 	Input reference of the Element 71A.
        /// </param>
        /// <param name="xPathTag71F">
        /// 	Input reference of the Element 71F.
        /// </param>
        /// <param name="xPathTag71G">
        /// 	Input reference of the Element 71G.
        /// </param>
        /// <param name="xPathTag32">
        /// 	Input reference of the Element 32.
        /// </param>
        /// <param name="xPathCurrency32">
        /// 	Input reference of the Currency element..
        /// </param>
        /// <param name="qualifierValueList">
        /// 	Input containing the qualifier list.
        /// </param>
        /// <param name ="offsetPercent" type = "int">
        ///		Input containing the allowable difference in percentage between amount in Field 32A
        ///		and the amount calculated using the Field 33B with the applicable charges.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="elementName" type = "string">
        ///		Input containing the element Name.
        /// </param>
        /// <param name ="elementValue" type = "string">
        ///		Input containing the element Value.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidInterbankSettledAmount(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag33B,
            string xPathTag36,
            string xPathTag71A,
            string xPathTag71F,
            string xPathTag71G,
            string xPathTag32,
            string xPathCurrency32,
            string qualifierValueList,
            int	   offsetPercent,
            string errorCode,
            string policyName,
            string ruleName,
            string elementName,
            string elementValue,
            ErrorCollection errorObject)
        {
            if(xDocument == null ||
                xPathTag33B == null ||
                xPathTag33B.Length == 0 ||
                xPathTag36 == null ||
                xPathTag36.Length == 0 ||
                xPathTag71A == null ||
                xPathTag71A.Length == 0 ||
                xPathTag71F == null ||
                xPathTag71F.Length == 0 ||
                xPathTag71G == null ||
                xPathTag71G.Length == 0 ||
                xPathCurrency32 == null ||
                xPathCurrency32.Length == 0 ||
                xPathTag32 == null ||
                xPathTag32.Length == 0 ||
                qualifierValueList == null ||
                qualifierValueList.Length == 0 ||
                errorCode == null ||
                errorCode.Length == 0 ||
                policyName == null ||
                policyName.Length == 0 ||
                ruleName == null ||
                ruleName.Length == 0 ||
                elementName == null ||
                elementValue == null ||
                errorObject == null)
            {
                return false;
            }

            XmlNode xRoot = xDocument.Document;

            if(!(IsValidAmount(xRoot,xPathTag33B,xPathTag36,xPathTag71A,xPathTag71F,xPathTag71G,
                xPathTag32,xPathCurrency32,qualifierValueList, offsetPercent)))
            {
                errorObject.AddError(errorCode, policyName, ruleName,elementName,elementValue);
                return false;
            }
            return true;
        }
*/

        /// <method>
        /// 	IsValidNumericIndicator
        /// </method>
        /// <summary>
        ///		If Qualifier is PRIR and Data Source Scheme is not present, Indicator
        ///		must contain a numerical value in the range 0001 - 9999 where 0001 refers to the highest priority.
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        /// 	xPath of Sequence
        /// </param>
        /// <param name="xPathTag">
        /// 	xPath of 22F Field
        /// </param>
        /// <param name="xPathQualifier">
        /// 	xPath of Qualifier
        /// </param>
        /// <param name="xPathDataSourceScheme">
        /// 	xPath of DataSourceScheme
        /// </param>
        /// <param name="xPathIndicator">
        /// 	xPath of Indicator
        /// </param>
        /// <param name="Qualifier">
        /// 	codelist of qualifier
        /// </param>
        /// <param name="errorCode">
        /// 	Error Code
        /// </param>
        /// <param name="policyName">
        /// 	Name of the Policy
        /// </param>
        /// <param name="ruleName">
        /// 	Name of the Rule
        /// </param>
        /// <param name="messageType">
        /// 	Message Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidNumericIndicator(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag,
            string xPathQualifier,
            string xPathDataSourceScheme,
            string xPathIndicator,
            string Qualifier,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidNumericIndicator" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathIndicator == null ||
                    xPathIndicator.Length == 0 ||
                    Qualifier == null ||
                    Qualifier.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    bool isValid = true;
                    XmlNode xRoot = xDocument.Document;
                    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                    //Check if Sequence is present
                    if (xListSequence.Count != 0)
                    {
                        foreach (XmlNode xNodeSequence in xListSequence)
                        {
                            XmlNodeList xListTag = xNodeSequence.SelectNodes(xPathTag);
                            foreach (XmlNode xNodeTag in xListTag)
                            {
                                //check if the node has an DataSourceScheme tag
                                XmlNode xNodeField = xNodeTag.SelectSingleNode(xPathDataSourceScheme);
                                if (xNodeField == null || xNodeField.InnerText == null || xNodeField.InnerText.Length == 0)
                                {
                                    XmlNode xNodeQualifier = xNodeTag.SelectSingleNode(xPathQualifier);
                                    XmlNode xNodeIndicator = xNodeTag.SelectSingleNode(xPathIndicator);
                                    if (xNodeQualifier != null)
                                    {
                                        if (xNodeQualifier.InnerText.CompareTo(Qualifier) == 0)
                                        {
                                            if (xNodeIndicator == null || xNodeIndicator.InnerText == null || xNodeIndicator.InnerText.Length == 0)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, xNodeTag.Name, xNodeTag.InnerText);
                                                isValid = false;
                                            }
                                            else
                                            {
                                                for (int counter = 0; counter < xNodeIndicator.InnerText.Length; counter++)
                                                {
                                                    string charValue = xNodeIndicator.InnerText.Substring(counter, 1);

                                                    // Check if the attribute is composed only of commas and digits
                                                    if (isValid)
                                                    {
                                                        if (Constants.NUMBERSET.IndexOf(charValue) == -1)
                                                        {
                                                            errorObject.AddError(errorCode, policyName, ruleName, xNodeIndicator.Name, xNodeIndicator.InnerText);
                                                            isValid = false;
                                                        }
                                                    }
                                                }
                                                if (isValid)
                                                {
                                                    int indicatorValue = Convert.ToInt16(xNodeIndicator.InnerText, CultureInfo.InvariantCulture);
                                                    if (!(indicatorValue >= Constants.INT1 && indicatorValue <= Constants.INT9999))
                                                    {
                                                        errorObject.AddError(errorCode, policyName, ruleName, xNodeTag.Name, xNodeTag.InnerText);
                                                        isValid = false;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        /// <method>
        /// 	IsCheckRange
        /// </method>
        /// <summary>
        /// 	This method checks the input value is in range between start and end value
        /// </summary>
        /// <param name="inputValue">
        /// 	Input value for comparison
        /// </param>
        /// <param name="startValue">
        /// 	Start value
        /// </param>
        /// <param name="endValue">
        /// 	End Value
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool IsCheckRange ( string inputValue, string startValue, string endValue)
        //{
        //    if ( inputValue == null ||
        //        startValue == null ||
        //        endValue == null ||
        //        inputValue.Length == 0 ||
        //        startValue.Length == 0 ||
        //        endValue.Length == 0 )
        //    {
        //        return false;
        //    }

        //    if ( startValue.CompareTo(inputValue) > 0 ||
        //        endValue.CompareTo(inputValue) < 0)
        //        return false;
        //    else
        //        return true;
        //}


        /// <method>
        ///		SWIFTNetworkRule1
        /// </method>
        /// <summary>
        ///		The amount in field 19 must equal the sum of the amounts in all occurrences of field 32B
        ///		or 34A.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSumOfAmounts" type = "string">
        ///		Input reference of 'Amount' Element of Tag 19.
        /// </param>
        /// <param name ="xPathAmount" type = "string">
        ///		Input reference of the element 32B to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the messageType.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber.
        /// </param>
        /// <param name ="errorObj" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule1(TypedXmlDocument xDocument,
            string xPathSumOfAmounts,
            string xPathAmount,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObj,
            string conditionalRuleName,
            string conditionalRuleNumber)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule1" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            if (null == errorObj) throw new ArgumentNullException("errorObj");

            bool isValid = true;
            try
            {
                if (xDocument != null)
                {
                    XmlNode xRoot = xDocument.Document;

                    XmlNodeList xListOfAmounts = xRoot.SelectNodes(xPathAmount);
                    XmlNode xSumOfAmounts = xRoot.SelectSingleNode(xPathSumOfAmounts);

                    if (xSumOfAmounts != null)
                    {
                        decimal sumOfAmounts = Convert.ToDecimal(xSumOfAmounts.InnerText.Replace(Constants.COMMA, decimalSeparator), CultureInfo.InvariantCulture);
                        decimal dAmount = 0.0M;
                        decimal dSum = 0.0M;

                        foreach (XmlNode xNodeAmount in xListOfAmounts)
                        {
                            if (xNodeAmount.InnerText != null)
                            {
                                dAmount = Convert.ToDecimal(xNodeAmount.InnerText.Replace(Constants.COMMA, decimalSeparator), CultureInfo.InvariantCulture);
                                dSum = dSum + dAmount;
                            }
                        }
                        if (sumOfAmounts != dSum)
                        {
                            errorObj.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
                else
                {
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <method>
        /// 	SWIFTNetworkRule226
        /// </method>
        /// <summary>
        /// 	This method validates for the condition that if field 71L is present in sequence C,
        /// 	then the amount specified in field 71L must be equal to the sum of all occurrences
        /// 	of field 71F in sequence B.
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSumOfAmounts">
        /// 	Input reference of the Sum Of Amounts tag.
        /// </param>
        /// <param name="xPathAmount">
        /// 	Input reference of the Amounts tag.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObj" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static void SWIFTNetworkRule226(TypedXmlDocument xDocument,
            string xPathSumOfAmounts,
            string xPathAmount,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule226" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                CommonFunctions.SWIFTNetworkRule1(xDocument,
                    xPathSumOfAmounts, xPathAmount, errorCode,
                    policyName, ruleName, messageType,
                    conditionalRuleName, conditionalRuleNumber,
                    errorObj);
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }


        /// <method>
        /// 	SWIFTNetworkRule227
        /// </method>
        /// <summary>
        /// 	This method validates for the condition that if field 71J is present in sequence C,
        /// 	then the amount specified in field 71J must be equal to the sum of all occurrences
        /// 	of field 71G in sequence B.
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSumOfAmounts">
        /// 	Input reference of the Sum Of Amounts tag.
        /// </param>
        /// <param name="xPathAmount">
        /// 	Input reference of the Amounts tag.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObj" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static void SWIFTNetworkRule227(TypedXmlDocument xDocument,
            string xPathSumOfAmounts,
            string xPathAmount,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule227" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                CommonFunctions.SWIFTNetworkRule1(xDocument,
                    xPathSumOfAmounts, xPathAmount, errorCode,
                    policyName, ruleName, messageType,
                    conditionalRuleName, conditionalRuleNumber,
                    errorObj);
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        /// <method>
        /// 	SWIFTNetworkRule232
        /// </method>
        /// <summary>
        /// 	This method validates for the condition that If field 71K is present in sequence C,
        /// 	then the amount specified in field 71K must be equal to the sum of all occurrences
        /// 	of field 71H in sequence B.
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSumOfAmounts">
        /// 	Input reference of the Sum Of Amounts tag.
        /// </param>
        /// <param name="xPathAmount">
        /// 	Input reference of the Amounts tag.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObj" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static void SWIFTNetworkRule232(TypedXmlDocument xDocument,
            string xPathSumOfAmounts,
            string xPathAmount,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule232" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                CommonFunctions.SWIFTNetworkRule1(xDocument,
                    xPathSumOfAmounts, xPathAmount, errorCode,
                    policyName, ruleName, messageType,
                    conditionalRuleName, conditionalRuleNumber,
                    errorObj);
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }


        /// <method>
        /// 	IsValidType
        /// </method>
        /// <summary>
        ///		If value of xPathField1 is equal to any of the values listed in valueField1
        ///		value of xPathField2 has to be equal to any of the values listed in valueField2.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name="xPathField1">
        ///		Input containing the xPath of the Field1
        /// </param>
        /// <param name="xPathField2">
        ///		Input containing the xPath of the Field2
        /// </param>
        /// <param name="valueField1">
        ///		Input containing the list of values of Field1
        /// </param>
        /// <param name="valueField2">
        ///		Input containing the list of values of Field2
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name
        /// </param>
        /// <param name="errorObject">
        /// </param>
        /// <returns>
        ///		True if validation succeeds, False otherwise
        /// </returns>
        //public static bool IsValidType(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathField1,
        //    string xPathField2,
        //    string valueField1,
        //    string valueField2,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{
        //    //declarations of variables used in the method
        //    bool isValid = true;
        //    string code = string.Empty;
        //    if(xDocument == null ||
        //        xPathField1 == null ||
        //        xPathField2 == null ||
        //        valueField1 == null ||
        //        valueField2 == null ||
        //        xPathField1.Length == 0 ||
        //        xPathField2.Length == 0 ||
        //        valueField1.Length == 0 ||
        //        valueField2.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    //get a list of repeating tags
        //    XmlNode xRoot = xDocument.Document;

        //    XmlNode xNodeField1 = xRoot.SelectSingleNode(xPathField1);
        //    XmlNode xNodeField2 = xRoot.SelectSingleNode(xPathField2);

        //    if (valueField1.IndexOf(xNodeField1.InnerText) != -1)
        //    {
        //        if (valueField2.IndexOf(xNodeField2.InnerText) == -1)
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                xNodeField2.Name, code);
        //            isValid = false;
        //        }
        //    }

        //    return isValid;

        //}


        /// <method>
        /// 	IsValidYearRangeType
        /// </method>
        /// <summary>
        ///		If value of xPathField1 is equal to valueField1
        ///		value of xPathField2 has to be greater than or equal to valueField2 and Current Year.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name="xPathField1">
        ///		Input containing the xPath of the Field1
        /// </param>
        /// <param name="xPathField2">
        ///		Input containing the xPath of the Field2
        /// </param>
        /// <param name="valueField1">
        ///		Input containing the list of values of Field1
        /// </param>
        /// <param name="valueField2">
        ///		Input containing the list of values of Field2
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name
        /// </param>
        /// <param name="errorObject">
        /// </param>
        /// <returns>
        ///		True if validation succeeds, False otherwise
        /// </returns>
        //public static bool IsValidYearRangeType(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathField1,
        //    string xPathField2,
        //    string valueField1,
        //    string valueField2,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{
        //    //declarations of variables used in the method
        //    bool isValid = true;
        //    string code = string.Empty;
        //    if(xDocument == null ||
        //        xPathField1 == null ||
        //        xPathField2 == null ||
        //        valueField1 == null ||
        //        valueField2 == null ||
        //        xPathField1.Length == 0 ||
        //        xPathField2.Length == 0 ||
        //        valueField1.Length == 0 ||
        //        valueField2.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    //get a list of repeating tags
        //    XmlNode xRoot = xDocument.Document;

        //    XmlNode xNodeField1 = xRoot.SelectSingleNode(xPathField1);
        //    XmlNode xNodeField2 = xRoot.SelectSingleNode(xPathField2);

        //    if (valueField1.IndexOf(xNodeField1.InnerText) != -1)
        //    {
        //        if (IsCheckRange(xNodeField2.InnerText, valueField2.ToString(), DateTime.Now.Year.ToString(CultureInfo.InvariantCulture))==false)
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                xNodeField2.Name, xNodeField2.InnerText);
        //            isValid = false;
        //        }
        //    }

        //    return isValid;

        //}

        /// <method>
        ///	SWIFTNetworkRule287
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 287.The 19A Amount fields
        ///		enumerated cannot occur in more than one occurrence of Sequence E3.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xpathSequence" type = "string">
        ///		Input reference of the Sequence to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the Sub Sequence B5c to be validated.
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the list of the qualifiers.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule287(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xpathSequence,
            string xPath,
            string qualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule287" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //Variables used
            string qualifierListHold = qualifierList + Constants.COMMA;
            string tempQualifierList = qualifierListHold;
            bool isValidQualifier = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //Check for Number of occurences of the field in the input instance
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xpathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    //Check for Number of occurences of the field in the input instance
                    XmlNodeList xList = xNodeSequence.SelectNodes(xPath);

                    if (xList.Count != 0)
                    {
                        qualifierList = qualifierListHold;
                        tempQualifierList = qualifierList;

                        //Calling Overloaded HasValidMultipleQualifiers (2)
                        isValidQualifier = CommonFunctions.HasValidMultipleQualifiers(xDocument, xList, ref qualifierList, ref tempQualifierList, errorCode, policyName, ruleName,
                            messageType, conditionalRuleName, conditionalRuleNumber, errorObject);
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValidQualifier;
        }

        /// <method>
        ///		IsValidFlag
        /// </method>
        /// <summary>
        ///		This method performs validation "Flag is only to be used in a sequence B5c with settlement amount field 19A::SETT//[N]3!a15d as it indicates whether the
        ///		concerned settlement amount includes the accrued interest and/or the stamp duty amount."
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the sequence to be validated.
        /// </param>
        /// <param name ="xPathTag1" type = "string">
        ///		Input reference of the flag tag(17B) in the same sequence to be validated.
        /// </param>
        /// <param name ="xPathTag2" type = "string">
        ///		Input reference of the flag tag(19A) in the same sequence to be validated.
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Reference containing the value (SETT) of the Qualifier for the Amount field element's qualifier.
        /// </param>
        /// <param name ="elementName" type = "string">
        ///		Input containing the element name.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        ///	</param>
        ///	<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidFlag(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag1,
            string xPathTag2,
            string qualifierValue,
            string elementName,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidFlag" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag1 == null ||
                    xPathTag1.Length == 0 ||
                    xPathTag2 == null ||
                    xPathTag2.Length == 0 ||
                    qualifierValue == null ||
                    qualifierValue.Length == 0 ||
                    elementName == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    ruleName == null ||
                    errorObject == null)
                {
                    return false;
                }

                int count = 0;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    string qualifier = string.Empty;

                    XmlNodeList xList17B = xNodeSequence.SelectNodes(xPathTag1);

                    if (xList17B.Count != 0)
                    {
                        XmlNodeList xList19A = xNodeSequence.SelectNodes(xPathTag2);

                        foreach (XmlNode xNode in xList19A)
                        {
                            if (xNode != null && xNode.FirstChild != null)
                            {
                                qualifier = xNode.FirstChild.InnerText;
                                if (qualifier == qualifierValue)
                                    count++;
                            }
                        }

                        if (count == 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, elementName, qualifier);
                            return false;
                        }


                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;
        }


        /// <method>
        /// 	CalculateAmount
        /// </method>
        /// <summary>
        ///		The amount will be equal to the deal price multiplied by the quantity of securities.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPath">
        ///		Input reference of the elements to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="elementName" type = "string">
        ///		Input containing the element Name.
        /// </param>
        /// <param name ="elementValue" type = "string">
        ///		Input containing the element Value.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        public static bool CalculateAmount(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string elementName,
            string elementValue,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CalculateAmount" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);

            try
            {
                if (
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null
                    )
                {
                    return false;

                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);

                double valuePriceQuantity = 0.0;
                double amount = SumOfTagValues(xDocument, xPathArray[0]);
                string[] arrayAmount = amount.ToString(CultureInfo.InvariantCulture).Split(charDecimalSeparator);
                int tempAmount = 0;
                if (arrayAmount.Length < Constants.INT2)
                    tempAmount = 0;
                else
                    tempAmount = arrayAmount[1].Length;

                valuePriceQuantity = SumOfTagValues(xDocument, xPathArray[1]) * SumOfTagValues(xDocument, xPathArray[2]);
                decimal dtPriceQuantity = Convert.ToDecimal(valuePriceQuantity);
                dtPriceQuantity = decimal.Round(dtPriceQuantity, tempAmount);
                valuePriceQuantity = Convert.ToDouble(dtPriceQuantity);

                if (amount != valuePriceQuantity)
                {
                    errorObject.AddError(errorCode, policyName, ruleName,
                        elementName, elementValue);
                    return false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
            }

            return true;
        }


        /// <method>
        /// 	ExtractAmount
        /// </method>
        /// <summary>
        /// The function converts the string amount to double and replaces
        /// comma with dot.
        /// </summary>
        /// <param name="amtText">Input Text</param>
        /// <returns>Converted double value</returns>

        private static double ExtractAmount(string amtText)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function ExtractAmount:");
            double amount = 0.0;
            try
            {
                if (amtText != null && amtText.Trim().Length != 0)
                {
                    amount = Convert.ToDouble(amtText.Replace(Constants.CHRCOMMA,
                        charDecimalSeparator), CultureInfo.InvariantCulture);
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return amount;
        }

        /*
        //
        COMMENTED AS PER CONFIRMATION FROM SWIFT, ON THE LINE OF BUG: 96563
        //
        /// <method>
        ///		IsValidReceiversCharges
        /// </method>
        /// <summary>
        ///		This method performs validation for the usage Rule of MT102
        ///		and MT102PLUS. The sum of all Receivers charges in fields 71G of sequence B,
        /// 	equals the total Receivers charges of field 71G in sequence C
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequenceB" type = "string">
        ///		Input reference of the Sequence B
        /// </param>
        /// <param name ="xPathSequenceC" type = "string">
        ///		Input reference of the Sequence C
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of the Tag 71G in Sequence B
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Input reference of the Tag 71G in Sequence C
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool IsValidReceiversCharges(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathSequenceC,
            string xPath1,
            string xPath2,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            if(xDocument == null ||
                xPathSequenceB == null ||
                xPathSequenceB.Length == 0 ||
                xPathSequenceC == null ||
                xPathSequenceC.Length == 0 ||
                xPath1 == null ||
                xPath1.Length == 0 ||
                xPath2 == null||
                xPath2.Length == 0 ||
                errorCode == null ||
                errorCode.Length == 0 ||
                policyName == null ||
                ruleName == null ||
                errorObject == null)
            {
                return false;
            }

            double receiversCharges = 0.0;
            int count = 0;

            XmlNode xRoot = xDocument.Document;
            //Select all the nodes of Sequence B
            XmlNodeList xListSequenceB = xRoot.SelectNodes(xPathSequenceB);
            //Select the node of Sequence C
            XmlNode xNodeSequenceC = xRoot.SelectSingleNode(xPathSequenceC);

            foreach(XmlNode xNodeSequence in xListSequenceB)
            {
                //Select the node of Tag 71G in Sequence B
                XmlNode xNode71G = xNodeSequence.SelectSingleNode(xPath1);

                if(xNode71G != null && xNode71G.LastChild != null)
                {
                    count++;
                    receiversCharges = receiversCharges + Convert.ToDouble(xNode71G.LastChild.InnerText.Replace(Constants.CHRCOMMA,charDecimalSeparator));
                }
            }

            //Select the node of Tag 71G in Sequence C
            XmlNode xNodeC = xNodeSequenceC.SelectSingleNode(xPath2);

            //If tag 71G is not present in Sequence B but present
            //in Sequence C, throw an error
            if(count == 0 && xNodeC != null)
            {
                errorObject.AddError(errorCode, policyName, ruleName,
                    xNodeC.Name, xNodeC.LastChild.InnerText);
                return false;
            }

            if(xNodeC != null && xNodeC.LastChild != null)
            {
                //If the sum of all Receivers charges in fields 71G of sequence B
                //is not equal to the total Receivers charges of field 71G in
                //sequence C, throw an error
                if(Convert.ToDouble(xNodeC.LastChild.InnerText.Replace(Constants.CHRCOMMA,charDecimalSeparator)) != receiversCharges)
                {
                    errorObject.AddError(errorCode, policyName, ruleName,
                        xNodeC.Name, xNodeC.LastChild.InnerText);
                    return false;
                }

            }
            return true;
        }
        */
        /*
        //
        COMMENTED AS PER CONFIRMATION FROM SWIFT
        BUG: 96563
        // 
        /// <method>
        ///		IsValidSettlementAmount
        /// </method>
        /// <summary>
        ///		This method performs validation for the usage Rule of MT102
        ///		and MT102PLUS. The total amount in field 19 (or the sum of all transaction amounts
        ///		in fields 32B), plus the total Receivers charges in field 71G of sequence C,
        ///		equals the interbank settled amount in field 32A.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequenceList" type = "string">
        ///		Input containing the list of xPaths of all Sequences
        /// </param>
        /// <param name ="xPathList71A" type = "string">
        ///		Input containing the list of xPaths of Tag 71A in Sequence A and Sequence B
        /// </param>
        /// <param name ="xPath32B" type = "string">
        ///		Input reference of the Tag 32B in Sequence B
        /// </param>
        /// <param name ="xPath19" type = "string">
        ///		Input reference of the Tag 19 in Sequence C
        /// </param>
        /// <param name ="xPath71G" type = "string">
        ///		Input reference of the Tag 71G in Sequence C
        /// </param>
        /// <param name ="xPath32A" type = "string">
        ///		Input reference of the Tag 32A in Sequence C
        /// </param>
        /// <param name ="code" type = "string">
        ///		Input containing the Code value of tag 71A
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool IsValidSettlementAmount(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceList,
            string xPath71A,
            string xPathSeqB71G,
            string xPathSeqB32B,
            string xPathSeqC19,
            string xPathSeqC32A,
            string xPathSeqC71G,
            string code,
            int rangeAllowed,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {

            if(xDocument == null ||
                xPathSequenceList == null ||
                xPathSequenceList.Length == 0 ||
                xPath71A == null ||
                xPath71A.Length == 0 ||
                xPathSeqB71G == null ||
                xPathSeqB71G.Length == 0 ||
                xPathSeqB32B == null||
                xPathSeqB32B.Length == 0 ||
                xPathSeqC19 == null||
                xPathSeqC19.Length == 0 ||
                xPathSeqC32A == null||
                xPathSeqC32A.Length == 0 ||
                xPathSeqC71G == null||
                xPathSeqC71G.Length == 0 ||
                code == null ||
                code.Length == 0 ||
                errorCode == null ||
                errorCode.Length == 0 ||
                policyName == null ||
                ruleName == null ||
                errorObject == null)
            {
                return false;
            }

            if(rangeAllowed < 0 || rangeAllowed > 100)
            {
                return false;
            }

            double sumOfReceiversCharges = 0.0;
            double sumOfReceiversChargesSeqB = 0.0;
            double sumOfAmounts = 0.0;
            double sumOfAmounts32ASeqC = 0.0;
            double transactionAmount = 0.0;

            //Store the xPaths of each Sequence in an array
            string[] xPathSequence = xPathSequenceList.Split(Constants.CHRCOMMA);

            XmlNode xRoot = xDocument.Document;

            //Select the node of Sequence A
            XmlNode xNodeSequenceA = xRoot.SelectSingleNode(xPathSequence[0]);

            //Select all the nodes of Sequence B
            XmlNodeList xListSequenceB = xRoot.SelectNodes(xPathSequence[1]);

            //Select the node of Sequence C
            XmlNode xNodeSequenceC = xRoot.SelectSingleNode(xPathSequence[2]);

            //Select the node of Tag 71A in Sequence A
            XmlNode xNodeA = xNodeSequenceA.SelectSingleNode(xPath71A);

            string code71A = null;

            bool isValid = true;

            //Check if the Code value is equal to OUR
            if(xNodeA != null &&
                xNodeA.FirstChild != null)

            {
                code71A = xNodeA.FirstChild.InnerText;
            }

            // If 71A in SequenceA is not present, the usage rule need not be evaluated.
            if(null != code71A)
            {

                foreach(XmlNode xNodeSequenceB in xListSequenceB)
                {
                    //Select the node of Tag 32B in Sequence B
                    XmlNode xNode32B = xNodeSequenceB.SelectSingleNode(xPathSeqB32B);

                    if(xNode32B != null && xNode32B.LastChild != null)
                    {
                        transactionAmount = transactionAmount + Convert.ToDouble(xNode32B.LastChild.InnerText.Replace(Constants.CHRCOMMA,charDecimalSeparator));
                    }

                    XmlNode xNodeSeqB71G = xNodeSequenceB.SelectSingleNode(xPathSeqB71G);

                    if(xNodeSeqB71G != null && xNodeSeqB71G.LastChild != null)
                    {
                        sumOfReceiversChargesSeqB = sumOfReceiversChargesSeqB + Convert.ToDouble(xNodeSeqB71G.LastChild.InnerText.Replace(Constants.CHRCOMMA,charDecimalSeparator));
                    }
                }



                //Select the node of Tag 19 in Sequence C
                XmlNode xNode19 = xNodeSequenceC.SelectSingleNode(xPathSeqC19);

                // Amount in Field 19, Sequence C.
                if(xNode19 != null && xNode19.FirstChild != null)
                {
                    sumOfAmounts = Convert.ToDouble(xNode19.FirstChild.InnerText.Replace(Constants.CHRCOMMA,charDecimalSeparator));
                }

                //Select the node of Tag 32A in Sequence C
                XmlNode xNode32ASeqC = xNodeSequenceC.SelectSingleNode(xPathSeqC32A);

                // Amount in Field 32A, Sequence C.
                if(xNode32ASeqC != null && xNode32ASeqC.LastChild != null)
                {
                    sumOfAmounts32ASeqC = Convert.ToDouble(xNode32ASeqC.LastChild.InnerText.Replace(Constants.CHRCOMMA,charDecimalSeparator));
                }

                //Select the node of Tag 71G in Sequence C
                XmlNode xNode71G = xNodeSequenceC.SelectSingleNode(xPathSeqC71G);

                // Amount in Field 71G, Sequence C.
                if(xNode71G != null && xNode71G.LastChild != null)
                {
                    sumOfReceiversCharges = Convert.ToDouble(xNode71G.LastChild.InnerText.Replace(Constants.CHRCOMMA,charDecimalSeparator));
                }

                double sumofAmountsAllowed = sumOfAmounts * rangeAllowed/100;
                double sumofAmountHigh = sumOfAmounts + sumofAmountsAllowed;
                double sumofAmountLow = sumOfAmounts - sumofAmountsAllowed;
                double sumOfReceiversChargesAllowed = sumOfReceiversCharges * rangeAllowed/100;
                double sumOfReceiversChargesHigh = sumOfReceiversCharges + sumOfReceiversChargesAllowed;
                double sumOfReceiversChargesLow = sumOfReceiversCharges - sumOfReceiversChargesAllowed;
                double sumOfAmounts32ASeqCAllowed = sumOfAmounts32ASeqC * rangeAllowed/100;
                double sumOfAmounts32ASeqCHigh = sumOfAmounts32ASeqC + sumOfAmounts32ASeqCAllowed;
                double sumOfAmounts32ASeqCLow = sumOfAmounts32ASeqC - sumOfAmounts32ASeqCAllowed;

                switch(code71A)
                {
                    case "OUR":


                        //Validations to be done are:
                        // 1) Amount in Field 19 in SequenceC must be sum of all 32B amounts in SequenceB
                        // 2) Amount in 32A in SequenceC must be sum of Amount in 19 and 71G in SequenceC.
                        // 3) Amount in 71G must be sum of all 71Gs is SequenceB.
                        //
                        if((transactionAmount >= sumofAmountLow && sumofAmountLow <= sumofAmountHigh) &&
                            ((sumOfAmounts32ASeqCHigh >= (sumOfReceiversCharges + sumOfAmounts) && sumOfAmounts32ASeqCLow <= (sumOfReceiversCharges + sumOfAmounts)) &&
                            (sumOfReceiversChargesSeqB >= sumOfReceiversChargesLow && sumOfReceiversChargesSeqB <= sumOfReceiversChargesHigh)))
                        {
                            isValid = true;
                        }
                        else
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                Constants.SUMOFAMOUNTS, Constants.NOTPRESENT);
                            isValid = false;
                        }

                        break;

                    case "BEN":
                    case "SHA":

                        //Validations to be done are:
                        // 1) Amount in Field 32A in SequenceC must be sum of all 32B amounts in SequenceB
                        //

                        if(sumOfAmounts32ASeqCHigh >= transactionAmount && sumOfAmounts32ASeqCLow <= transactionAmount)
                        {
                            isValid = true;
                        }

                        else
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                Constants.SUMOFAMOUNTS, Constants.NOTPRESENT);
                            isValid = false;
                        }

                        break;

                    default:
                        errorObject.AddError(errorCode, policyName, ruleName,
                            Constants.SUMOFAMOUNTS, Constants.NOTPRESENT);
                        isValid = false;
                        break;

                }
            }

            return isValid;
        }
*/
        /// <method>
        ///		IsValidTransactionAmount
        /// </method>
        /// <summary>
        ///		This method performs validation for the usage Rule of MT102
        ///		and MT102PLUS. For each occurrence of sequence B,
        ///		the instructed amount in field 33B,
        ///		adjusted with the exchange rate in field 36,
        ///		minus the Senders charges in field(s) 71F,
        ///		equals the transaction amount in field 32B.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequenceA" type = "string">
        ///		Input containing the xPath of Sequence A
        /// </param>
        /// <param name ="xPathSequenceB" type = "string">
        ///		Input containing the xPath of Sequence B
        /// </param>
        /// <param name ="xPathTag33B" type = "string">
        ///		Input reference of the Tag 33B in Sequence B
        /// </param>
        /// <param name ="xPathList36" type = "string">
        ///		Input containing the list of xPaths of Tag 36
        /// </param>
        /// <param name ="xPathList71A" type = "string">
        ///		Input containing the list of xPaths of Tag 71A
        /// </param>
        /// <param name ="xPathTag71F" type = "string">
        ///		Input reference of the Tag 71F in Sequence B
        /// </param>
        /// <param name ="xPathTag32B" type = "string">
        ///		Input reference of the Tag 32B in Sequence B
        /// </param>
        /// <param name ="codeValueList" type = "string">
        ///		Input containing the list of Codes of tag 71A
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        //public static bool IsValidTransactionAmount(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequenceA,
        //    string xPathSequenceB,
        //    string xPathTag33B,
        //    string xPathList36,
        //    string xPathList71A,
        //    string xPathTag71F,
        //    string xPathTag32B,
        //    string codeValueList,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPathSequenceA == null ||
        //        xPathSequenceA.Length == 0 ||
        //        xPathSequenceB == null ||
        //        xPathSequenceB.Length == 0 ||
        //        xPathTag33B == null ||
        //        xPathTag33B.Length == 0 ||
        //        xPathList36 == null ||
        //        xPathList36.Length == 0 ||
        //        xPathList71A == null ||
        //        xPathList71A.Length == 0 ||
        //        xPathTag71F == null ||
        //        xPathTag71F.Length == 0 ||
        //        xPathTag32B == null ||
        //        xPathTag32B.Length == 0 ||
        //        codeValueList == null ||
        //        codeValueList.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        policyName == null ||
        //        ruleName == null ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    double rate = 0.0;
        //    double sendersCharges = 0.0;
        //    double amount = 0.0;
        //    double finalAmount = 0.0;
        //    double tempAmount = 0.0;

        //    //Store the xPaths of Tag 71A in an array
        //    string[] xPath71A = xPathList71A.Split(Constants.CHRCOMMA);
        //    //Store the xPaths of Tag 36 in an array
        //    string[] xPath36 = xPathList36.Split(Constants.CHRCOMMA);
        //    string code = string.Empty;

        //    XmlNode xRoot = xDocument.Document;

        //    //Select the node of Sequence A
        //    XmlNode xNodeSequenceA = xRoot.SelectSingleNode(xPathSequenceA);
        //    //Select all the nodes of Sequence B
        //    XmlNodeList xListSequenceB = xRoot.SelectNodes(xPathSequenceB);

        //    //Select the node of Tag 71A in Sequence A
        //    XmlNode xNode71A = xNodeSequenceA.SelectSingleNode(xPath71A[0]);
        //    //Select the node of Tag 36 in Sequence A
        //    XmlNode xNode36A = xNodeSequenceA.SelectSingleNode(xPath36[0]);

        //    foreach(XmlNode xNode in xListSequenceB)
        //    {
        //        sendersCharges = 0.0;

        //        //Select the node of Tag 33B in Sequence B
        //        XmlNode xNode33B = xNode.SelectSingleNode(xPathTag33B);
        //        //Select the node of Tag 32B in Sequence B
        //        XmlNode xNode32B = xNode.SelectSingleNode(xPathTag32B);
        //        //Select all the nodes of Tag 71F in Sequence B
        //        XmlNodeList xList71F = xNode.SelectNodes(xPathTag71F);
        //        //Select the node of Tag 36 in Sequence B
        //        XmlNode xNode36B = xNode.SelectSingleNode(xPath36[1]);
        //        //Select the node of Tag 71A in Sequence B
        //        XmlNode xNode71B = xNode.SelectSingleNode(xPath71A[1]);

        //        //If Tag 33B exists
        //        if(xNode33B != null && xNode33B.FirstChild != null)
        //        {
        //            //If Tag 71A exists in Sequence A
        //            if(xNode71A != null && xNode71A.FirstChild != null)
        //                code = xNode71A.FirstChild.InnerText;
        //            else
        //                //If Tag 71A exists in Sequence B
        //                if(xNode71B != null && xNode71B.FirstChild != null)
        //                code = xNode71B.FirstChild.InnerText;

        //            if(xNode32B != null && xNode32B.FirstChild != null)
        //            {
        //                //Check if the Currency codes in Tag 33B and 32B are equal
        //                if(xNode33B.FirstChild.InnerText.CompareTo(xNode32B.FirstChild.InnerText)== 0)
        //                    rate = 1.0;
        //                else
        //                    //If Tag 36 exists in Sequence A
        //                    if(xNode36A != null && xNode36A.FirstChild != null)
        //                        rate = Convert.ToDouble(xNode36A.FirstChild.InnerText.Replace(Constants.CHRCOMMA, charDecimalSeparator), CultureInfo.InvariantCulture);
        //                else
        //                    //If Tag 36 exists in Sequence B
        //                    if(xNode36B != null && xNode36B.FirstChild != null)
        //                        rate = Convert.ToDouble(xNode36B.FirstChild.InnerText.Replace(Constants.CHRCOMMA, charDecimalSeparator), CultureInfo.InvariantCulture);
        //                else
        //                    //If the Currency codes in Tag 33B and 32B are not equal
        //                    //and Tag 36 not present in both Sequence A and B
        //                    return false;
        //            }

        //            //Store the Codes of Tag 71A in an array
        //            string[] codes = codeValueList.Split(Constants.CHRCOMMA);

        //            foreach(XmlNode xNode71F in xList71F)
        //            {
        //                //If the Currency codes in Tag 33B and 71F are not equal, throw an error
        //                if(xNode71F.FirstChild != null &&
        //                    xNode71F.FirstChild.InnerText.CompareTo(xNode33B.FirstChild.InnerText) != 0)
        //                {
        //                    errorObject.AddError(errorCode, policyName, ruleName,
        //                        xNode71F.Name, xNode71F.FirstChild.InnerText);
        //                    return false;
        //                }

        //                if(xNode71F.LastChild != null)
        //                    sendersCharges = sendersCharges + Convert.ToDouble(xNode71F.LastChild.InnerText.Replace(Constants.CHRCOMMA, charDecimalSeparator), CultureInfo.InvariantCulture);
        //            }

        //            amount = Convert.ToDouble(xNode33B.LastChild.InnerText.Replace(Constants.CHRCOMMA, charDecimalSeparator), CultureInfo.InvariantCulture);

        //            finalAmount = Convert.ToDouble(xNode32B.LastChild.InnerText.Replace(Constants.CHRCOMMA, charDecimalSeparator), CultureInfo.InvariantCulture);

        //            //If Code value is equal to SHA (or) OUR
        //            if(code.CompareTo(codes[0]) == 0 || code.CompareTo(codes[2]) == 0)
        //                tempAmount = amount * rate;

        //            //If Code value is equal to BEN
        //            if(code.CompareTo(codes[1])==0)
        //                tempAmount = (amount - sendersCharges) * rate;

        //            //If the Transaction Amount in field 32B is not in line with
        //            //the Usage Rule, throw an error
        //            if(finalAmount != tempAmount)
        //            {
        //                errorObject.AddError(errorCode, policyName, ruleName,
        //                    xNode32B.Name, xNode32B.LastChild.InnerText);
        //                return false;
        //            }
        //        }
        //    }
        //    return true;
        //}

        /// <method>
        /// 	CheckTagOccurrenceInSequence
        /// </method>
        /// <summary>
        /// 	This method checks, that in a sequence Tag1 and Tag2 come alone or if
        /// 	they come together the number of Tag1 occurrences is equal to number of Tag2 occurances.
        /// 	It also verifies the order of the tags.
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        /// 	Xpath of the Sequence.
        /// </param>
        /// <param name="xPath1">
        /// 	Xpath of the First Tag.
        /// </param>
        /// <param name="xPath2">
        /// 	Xpath of the Second Tag
        /// </param>
        /// <param name="errorCode">
        /// 	The error code for the network rule.
        /// </param>
        /// <param name="policyName">
        /// 	Policy name where the rule is present.
        /// </param>
        /// <param name="ruleName">
        /// 	Rule calling the method.
        /// </param>
        /// <param name="messageType">
        /// 	Name of the message.
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	Name of Conditionall Rule.
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Conditional Rule number.
        /// </param>
        /// <param name="errorObject">
        /// 	Error Object.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        //public static bool CheckTagOccurrenceInSequence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence,
        //    string xPath1,
        //    string xPath2,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPathSequence == null ||
        //        xPathSequence.Length == 0 ||
        //        xPath1 == null ||
        //        xPath1.Length == 0 ||
        //        xPath2 == null ||
        //        xPath2.Length == 0 ||
        //        policyName == null ||
        //        policyName.Length == 0 ||
        //        ruleName == null ||
        //        ruleName.Length == 0 ||
        //        messageType == null ||
        //        messageType.Length == 0 ||
        //        conditionalRuleName == null ||
        //        conditionalRuleName.Length == 0 ||
        //        conditionalRuleNumber == null ||
        //        conditionalRuleNumber.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    string [] xPath1Values = xPath1.Split(Constants.COMMA.ToCharArray());
        //    string [] xPath2Values = xPath2.Split(Constants.COMMA.ToCharArray());
        //    //Select the root node
        //    XmlNode xRoot = xDocument.Document;
        //    //Select Nodes Sequence
        //    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

        //    //The sequence has been refered as outersequence in the function
        //    foreach (XmlNode xNode in xListSequence)
        //    {
        //        int xPath1Count= 0;
        //        int xPath2Count= 0;
        //        for(int i=0;i<xPath1Values.Length;i++)
        //        {
        //            XmlNodeList xPath1List=xNode.SelectNodes(xPath1Values[i]);
        //            xPath1Count=xPath1Count + xPath1List.Count;
        //        }
        //        for(int j=0;j<xPath2Values.Length;j++)
        //        {
        //            XmlNodeList xPath2List=xNode.SelectNodes(xPath2Values[j]);
        //            xPath2Count=xPath2Count + xPath2List.Count;
        //        }
        //        if((xPath1Count == 0 &&	xPath2Count == 0) || (xPath1Count == 0 ||	xPath2Count == 0))
        //            return true;
        //        if(xPath1Count != xPath2Count )
        //        {

        //            errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //            return false;
        //        }
        //        else
        //        {
        //            for(int i=0;i<xPath2Values.Length;i++)
        //                if((xPath1Count == xPath2Count) && (xPath2Values[i].CompareTo(Constants.XPATH + xNode.ChildNodes[1].Name) == 0))
        //                {
        //                    errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                    return false;
        //                }

        //            for(int j=1;j<xNode.ChildNodes.Count-1;j=j+2)
        //            {
        //                bool flag = true;
        //                bool flag2 = true;
        //                for(int nCount = 0;nCount < xPath1Values.Length ; nCount++)
        //                {
        //                    if(xPath1Values[nCount].CompareTo(Constants.XPATH + xNode.ChildNodes[j].Name) == 0)
        //                    {
        //                        flag = false;
        //                    }
        //                }
        //                for(int nCount1 = 0;nCount1 < xPath2Values.Length ; nCount1++)
        //                {
        //                    if(xPath2Values[nCount1].CompareTo(Constants.XPATH + xNode.ChildNodes[j+1].Name) == 0)
        //                    {
        //                        flag2 = false;
        //                    }
        //                }

        //                if(flag | flag2)
        //                {
        //                    errorObject.AddError(errorCode,policyName,ruleName,messageType,conditionalRuleName,conditionalRuleNumber);
        //                    return false;
        //                }
        //            }
        //        }
        //    }
        //    return true;

        //}

        /// <method>
        /// 	IsValidPartyIdentification
        /// </method>
        /// <summary>
        ///		Helper function for validating 57J tag occuring in sequence F
        ///		for message MT330.
        /// </summary>
        /// <param name="document">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="sequenceF57J">
        /// 	Input containing the name of the Sequence.
        /// </param>
        /// <param name="netsCodesFormat">
        /// 	List of valid Codes-format pair separated by comma.
        /// </param>
        /// <param name="netsMandatoryCodes">
        /// 	List of Mandatory codes separated by comma
        /// </param>
        /// <param name="clrcCodesFormat">
        /// 	List of valid Codes-format pair separated by comma.
        /// </param>
        /// <param name="clrcMandatoryCodes">
        /// 	List of Mandatory codes separated by comma
        /// </param>
        /// <param name="sortFlag">
        ///		Input containing either true or false. True indicates that code in the xDocument has to be in order.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidPartyIdentification(Microsoft.RuleEngine.TypedXmlDocument document,
            string sequenceF57J,
            string netsCodesFormat,
            string netsMandatoryCodes,
            string clrcCodesFormat,
            string clrcMandatoryCodes,
            bool sortFlag,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidPartyIdentification" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (null == errorObject) throw new ArgumentNullException("errorObject");
                if (null == document) throw new ArgumentNullException("document");
                if (null == clrcMandatoryCodes) throw new ArgumentNullException("clrcMandatoryCodes");

                if (document == null ||
                    sequenceF57J == null ||
                    netsCodesFormat == null ||
                    netsMandatoryCodes == null ||
                    sequenceF57J.Length == 0 ||
                    clrcCodesFormat == null ||
                    clrcCodesFormat.Length == 0 ||
                    clrcMandatoryCodes.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, "", "");
                    return false;
                }
                else
                {

                    XmlNode root = document.Document;
                    XmlDocument xDoc = new XmlDocument();

                    XmlNodeList xListSeqF57J = root.SelectNodes(sequenceF57J);

                    if (xListSeqF57J == null || xListSeqF57J.Count == 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, Constants.BLANK, Constants.BLANK);
                        return false;
                    }

                    XmlNodeList xListChildNode = xListSeqF57J.Item(0).ChildNodes;

                    string szSeqF57JValue = Constants.BLANK;
                    szSeqF57JValue = xListSeqF57J.Item(0).InnerText.ToString();

                    // If the value of 57J is /SSIS/ then check that its length cannot be more than 6
                    if (szSeqF57JValue.IndexOf(Constants.CODESSIS) >= 0 &&
                        szSeqF57JValue.Length > Constants.CODELEN)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, sequenceF57J, szSeqF57JValue);
                        return false;
                    }
                    // If the value is /NETS/ then check for the mandatory codes existence only
                    // if the length of the value is more than Codelength, i.e. 6
                    else if (szSeqF57JValue.IndexOf(Constants.CODENETS) >= 0 &&
                        szSeqF57JValue.Length >= Constants.CODELEN)
                    {
                        if (szSeqF57JValue.Length == Constants.CODELEN)
                        {
                            return true;
                        }
                        return IsValidPartyIdentification(document, sequenceF57J,
                            netsCodesFormat, netsMandatoryCodes, sortFlag,
                            errorCode, policyName, ruleName, errorObject);
                    }
                    // If the value is /CLRC/ then check for the mandatory codes existence only
                    // if the length of the value is more than Codelength, i.e. 41
                    else if (szSeqF57JValue.IndexOf(Constants.CODECLRC) >= 0 &&
                        szSeqF57JValue.Length >= Constants.CLRCLEN)
                    {
                        if (szSeqF57JValue.Length == Constants.CLRCLEN &&
                            IsValidCodeFormatData(szSeqF57JValue.Substring(Constants.CODELEN), Constants.CLRCFORMAT))
                        {
                            return true;
                        }
                        return IsValidPartyIdentification(document, sequenceF57J, clrcCodesFormat,
                            clrcMandatoryCodes, sortFlag, errorCode,
                            policyName, ruleName, errorObject);
                    }
                    return true;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        /// <method>
        /// 	SumOfTagValues
        /// </method>
        /// <summary>
        /// 	This method selects all the tags in the message with the xpath passed and returns their sum.
        /// </summary>
        /// <param name="xDocument">
        /// 	The xml document.
        /// </param>
        /// <param name="xPathList">
        /// 	Comma separated xPaths of the tags.
        /// </param>
        /// <returns>
        /// 	Sum.
        /// </returns>
        public static double SumOfTagValues(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathList)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SumOfTagValues:");
            double sum = 0.0;
            try
            {
                if (null == xPathList) throw new ArgumentNullException("xPathList");
                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;


                // Split the comma separated xPathList
                string[] xPathArray = xPathList.Split(Constants.CHRCOMMA);



                foreach (string xPath in xPathArray)
                {
                    XmlNodeList xListTag = xRoot.SelectNodes(xPath);
                    foreach (XmlNode xNode in xListTag)
                    {
                        if (xNode.InnerText != null)
                        {
                            sum = sum + ExtractAmount(xNode.InnerText);
                        }
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return sum;

        }

        /// <method>
        /// 	CheckReportingAndTransactionCurrency
        /// </method>
        /// <summary>
        /// 	This function checks that when the amount in the reporting currency( Tag 19A in Sequence1)
        /// 	is not present or when the reporting currency is the same as the transaction currency
        /// 	(Tag 19A in Sequence2), First Currency Code and Second Currency Code in Tag 92B
        /// 	in Sequence3 are the same and Rate is equal to 1.
        /// </summary>
        /// <param name="xDocument" type = "string" >
        /// 	Input containing the xml document to be validated
        /// </param>
        /// <param name="xPathSequence1" type = "string">
        /// 	Input Containing xPath to the Sequence which has reporting currency.
        /// 	To be passed as //SequenceB
        /// </param>
        /// <param name="xPath1Tag19A" type = "string">
        /// 	Input Containing xPath of Tag 19A in Sequence 1.
        /// 	To be passed as ./Amount_B_19A/SignCodeAmount
        /// </param>
        /// <param name="xPathSequence2" type = "string">
        /// 	Input Containing xPath to the Sequence which has Transaction currency.
        /// 	To be passed as //SequenceC
        /// </param>
        /// <param name="xPath2Tag19A" type = "string">
        /// 	Input Containing xPath of Tag 19A in Sequence2.
        /// 	To be passed as ./Amount_C_19A/SignCodeAmount
        /// </param>
        /// <param name="xPathSequence3" type = "string">
        /// 	Input Containing xPath of Sequence3,containing ExchangeRate 92B
        /// 	To be passed as .//SequenceC1a
        /// </param>
        /// <param name="xPathTag92B" type = "string">
        /// 	Input Containing xPath of Tag 92B
        /// 	To passed as ./Rate_C1a_92B
        /// </param>
        /// <param name="xPathTag92BRate" type = "string">
        /// 	Input Containing xPath of Tag 92B,containing Rate
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        //public static bool CheckReportingAndTransactionCurrency(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence1,
        //    string xPath1Tag19A,
        //    string xPathSequence2,
        //    string xPath2Tag19A,
        //    string xPathSequence3,
        //    string xPathTag92B,
        //    string xPathTag92BRate,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{
        //    if (null == errorObject) throw new ArgumentNullException("errorObject");

        //    // ArrayList to be used for checking validity of the parameters passed.
        //    ArrayList parameters = new ArrayList();

        //    //Add all the parameters to Arraylist
        //    parameters.Add(xPath1Tag19A);
        //    parameters.Add(xPath2Tag19A);
        //    parameters.Add(xPathSequence1);
        //    parameters.Add(xPathSequence2);
        //    parameters.Add(xPathSequence3);
        //    parameters.Add(xPathTag92B);
        //    parameters.Add(policyName);
        //    parameters.Add(ruleName);

        //    // Pass the ArrayList to CheckValidity Function which checks for the validity of the parameters.
        //    if(!CheckValidity(parameters))
        //    {
        //        return false;
        //    }

        //    // Check whether all occurences of Tag 19A in Sequence B,C have same currencies.
        //    if (!CheckForSameCurrency(xDocument,xPathSequence1,xPath1Tag19A) ||
        //        !CheckForSameCurrency(xDocument,xPathSequence2,xPath2Tag19A))
        //    {
        //        errorObject.AddError(resManager.GetString("ERROR_INVALID_CURRENCY"),policyName,ruleName,
        //            resManager.GetString("ERROR_ELEMENTNAME_NOTDEFINED"),resManager.GetString("ERROR_ELEMENTVALUE_NOTDEFINED"));

        //    }

        //    XmlNode xRoot = xDocument.Document;

        //    XmlNode	xSequence1 = xRoot.SelectSingleNode(xPathSequence1);
        //    XmlNodeList	xListSequence2 = xRoot.SelectNodes(xPathSequence2), xListSequence3;

        //    //Get Tag 19A data in Sequence1,having Reporting Currency.
        //    XmlNode xNode1 = xSequence1.SelectSingleNode(xPath1Tag19A);
        //    if(xNode1 == null || xNode1.InnerText == null || xNode1.InnerText.Length == 0)
        //    {
        //        return false;
        //    }

        //    XmlNode xNode2,xNode3,xNode4;

        //    //Check whether all occurences of Tag 19A in Seqeunce1 has zero Amount.
        //    bool isAmountZero = CheckAmountZero(xSequence1,xPath1Tag19A);
        //    string currency1 = string.Empty,currency2 = string.Empty;

        //    //Get Reporting Currency.
        //    currency1 = GetCurrencyFromSignCodeAmount(xNode1);
        //    foreach(XmlNode xSequence2 in xListSequence2)
        //    {
        //        //Get Tag 19A data in Sequence2, having Transaction Currency.
        //        xNode2 = xSequence2.SelectSingleNode(xPath2Tag19A);
        //        if(xNode2 == null || xNode2.InnerText == null || xNode2.InnerText.Length == 0)
        //        {
        //            return false;
        //        }
        //        //Get Transaction Currency.
        //        currency2 = GetCurrencyFromSignCodeAmount(xNode2);

        //        xListSequence3 = xSequence2.SelectNodes(xPathSequence3);
        //        foreach(XmlNode xSequence3 in xListSequence3)
        //        {
        //            //Get Tag92B Data from Sequence3
        //            xNode3 = xSequence3.SelectSingleNode(xPathTag92B);
        //            if (xNode3 == null || xNode3.InnerText == null || xNode3.InnerText.Length == 0 )
        //            {
        //                return false;
        //            }
        //            xNode4 = xSequence3.SelectSingleNode(xPathTag92BRate);
        //            if(xNode4 == null || xNode4.InnerText == null || xNode4.InnerText.Length == 0)
        //            {
        //                return false;
        //            }

        //            //Check if Tag 92B contains both the currencies present in Tag 19A in Sequence1,Sequence2.

        //            if ( !CheckIfCurrenciesExist(xNode3.InnerText,currency1,currency2))
        //            {
        //                errorObject.AddError(resManager.GetString("ERROR_INVALID_EXCHANGERATE92B"),policyName,
        //                    ruleName,xNode3.Name,xNode3.InnerText);
        //            }
        //            //Check whether Rate in Tag 92B is 1 when Both currencies are same
        //            if( ( ( currency1.CompareTo(currency2) == 0 || isAmountZero ) )
        //                && (Convert.ToDecimal(xNode4.InnerText.Replace(Constants.CHRCOMMA, charDecimalSeparator), CultureInfo.InvariantCulture) != 1))
        //            {
        //                errorObject.AddError(resManager.GetString("ERROR_EXCHANGERATE92B_USAGERULE"),policyName,
        //                    ruleName,xNode3.Name,xNode3.InnerText);
        //            }
        //        }
        //    }
        //    return true;
        //}

        /// <method>
        /// 	CheckValidity
        /// </method>
        /// <summary>
        /// 	This Function Checks if any of the ArrayList memebers are null or empty
        /// </summary>
        /// <param name="parameters" type = "ArrayList">
        /// 	ArrrayList containing the members for which check is to be applied.
        /// </param>
        /// <returns>
        /// 	True on success,otherwise returns False
        /// </returns>

        private static bool CheckValidity(ArrayList parameters)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidity:");
            try
            {

                foreach (string parameter in parameters)
                {
                    if (parameter == null ||
                        parameter.Length == 0)
                    {
                        return false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;
        }

        /// <method>
        /// 	CheckForSameCurrency
        /// </method>
        /// <summary>
        /// 	This Function Checks whether all the occurences of
        /// 	specified tag in particular occurrence of Specified Sequence,
        /// 	has the same currency.
        /// </summary>
        /// <param name="xDocument" type = "string" >
        /// 	Input containing the xml document to be validated
        /// </param>
        /// <param name="xPathSequence" type = "string" >
        /// 	Input Reference containing xPath of Seqeunce
        /// </param>
        /// <param name="xPathTag" type = "string">
        /// 	Input Reference containing xPath of Tag
        /// </param>
        /// <returns>Returns True when Currencies of all ocurrences are same else false </returns>

        //private static bool CheckForSameCurrency(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence,
        //    string xPathTag)
        //{
        //    XmlNode xRoot =	xDocument.Document;
        //    XmlNodeList	xList =	xRoot.SelectNodes(xPathSequence);

        //    string currency	= string.Empty;
        //    string currencyCheck = string.Empty;

        //    if(xList.Count != 0 )
        //    {
        //        foreach(XmlNode xSequence in xList)
        //        {
        //            XmlNodeList xTagList = xSequence.SelectNodes(xPathTag);
        //            currency = Constants.BLANK;
        //            foreach(XmlNode xNode in xTagList)
        //            {
        //                //Extract Currency from the SignCodeAmount Data
        //                currency = GetCurrencyFromSignCodeAmount(xNode);
        //                //if it is the first tag which is being checked then use its currency as check for
        //                //subsequent occurences of tag
        //                if(currencyCheck.CompareTo(Constants.BLANK)==0)
        //                {
        //                    currencyCheck = currency;
        //                }
        //                if(currency.CompareTo(currencyCheck) != 0)
        //                {
        //                    return false;
        //                }
        //            }
        //        }
        //    }
        //    return true;
        //}

        /// <method>
        /// 	GetCurrencyFromSignCodeAmount
        /// </method>
        /// <summary>
        /// 	Extracts Currency from SignCodeAmount Data
        /// </summary>
        /// <param name="xNode" type = "XmlNode">
        /// 	XmlNode having SignCodeAmount Data
        /// </param>
        /// <returns> string which is currency</returns>

        private static string GetCurrencyFromSignCodeAmount(XmlNode xNode)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function GetCurrencyFromSignCodeAmount:");
            int startPositionOfCurrency = 0;
            string currency = string.Empty;

            //tempCurrency is used to check if data starts with sign[N].
            string tempCurrency = string.Empty;
            try
            {
                if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                {
                    //Extract fourth character from SignCodeAmount
                    tempCurrency = xNode.InnerText.Substring(Constants.INT3, 1);

                    //Check whether tempCurency is character
                    if (Constants.ALPHASET.IndexOf(tempCurrency) != -1)
                    {
                        //Data starts with Sign.
                        startPositionOfCurrency = 1;
                    }
                    currency = xNode.InnerText.Substring(startPositionOfCurrency, Constants.INT3);
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return currency;
        }

        /// <method>
        /// 	CheckAmountZero
        /// </method>
        /// <summary>
        /// 	This function Checks whether all the occurences of the specified tag
        /// 	have zero amount.
        /// </summary>
        /// <param name="xSequence" type = "string">
        /// 	Input reference to the sequence.
        /// </param>
        /// <param name="xPath" type = "string">
        /// 	Input reference to the tag for which the validation is to be performed.
        /// </param>
        /// <returns>
        /// 	True when all occurences of specified tag have 0
        /// 	value in all the occurences
        /// </returns>
        private static bool CheckAmountZero(XmlNode xSequence,
            string xPath)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckAmountZero:");
            try
            {

                XmlNodeList xNodeList;

                xNodeList = xSequence.SelectNodes(xPath);

                foreach (XmlNode xNode in xNodeList)
                {
                    if (xNode.InnerText != null && (ConvertToDecimal(xNode.InnerText) != 0))
                    {
                        return false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return true;
        }

        /// <method>
        /// 	CheckIfCurrenciesExist
        /// </method>
        /// <summary>
        /// 	This function checks whether Exchange Rate contains
        /// 	both Reporting and Transaction currecies.
        /// </summary>
        /// <param name="exchangeRate" type = "string">
        /// 	Input reference containing Exchange Rate.
        /// </param>
        /// <param name="currency1" type = "string">
        /// 	Input reference containing currency1.
        /// </param>
        /// <param name="currency2" type = "string">
        /// 	Input Reference containing currency2.
        /// </param>
        /// <returns>bool</returns>

        private static bool CheckIfCurrenciesExist(string exchangeRate,
            string currency1,
            string currency2)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckIfCurrenciesExist:");
            try
            {
                int currency1Position = exchangeRate.IndexOf(currency1);
                if (currency1Position == -1 || exchangeRate.IndexOf(currency2) == -1 || exchangeRate.Remove(currency1Position, 3).IndexOf(currency2) == -1)
                {
                    return false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;
        }


        /// <method>
        /// 	CheckValidSignUnitAmount
        /// </method>
        /// <summary>
        /// 	This function will return false if the validation of sign Unit and
        /// 	amount is false depending on boolean values set.
        /// </summary>
        /// <param name="xDocument">
        /// 	XmlDocument
        /// </param>
        /// <param name="xPathTag">
        /// 	Comma seperated list of xPath of tags
        /// 	eg.//AmountToBeSettled_B_32R/SignUnitAmount
        /// </param>
        /// <param name="UnitCodeList">
        ///  code list of different Units.
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="ruleName">
        /// 	rule name
        /// </param>
        /// <param name="policyName">
        /// 	policyname
        /// </param>
        /// <param name="errorobj">
        /// 	error object
        /// </param>
        /// <returns>
        /// 	bool
        public static bool CheckValidSignUnitAmount(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string UnitCodeList,
            string errorCode,
            string ruleName,
            string policyName,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidSignRate" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xPathTag == null ||
                    xPathTag.Length == 0)
                {
                    return false;
                }
                if (null == errorObj) throw new ArgumentNullException("ErrorObj");
                if (null == xDocument) throw new ArgumentNullException("xDocument");

                string signUnitAmount = String.Empty;
                string sign = String.Empty;
                string Unit = String.Empty;
                string amount = String.Empty;

                if (null == errorCode) throw new ArgumentNullException("ErrorCode");
                if (null == errorObj) throw new ArgumentNullException("errorObj");
                string[] errorCodeList = errorCode.Split(Constants.CHRCOMMA);


                XmlNode xRoot = xDocument.Document;
                string[] xPathTagList = xPathTag.Split(Constants.CHRCOMMA);
                foreach (string xPath in xPathTagList)
                {
                    XmlNodeList xNodeList = xRoot.SelectNodes(xPath);
                    foreach (XmlNode xNode in xNodeList)
                    {
                        sign = String.Empty;
                        //Extracts signUnitAmount value
                        signUnitAmount = xNode.InnerText;
                        //Checks the fourth character from starting of signUnitAmount
                        //if it is integer then sign is absent.

                        if (signUnitAmount.Length > 3)
                        {
                            if (Constants.NUMBERSET.IndexOf(signUnitAmount.Substring(3, 1)) != -1)
                            {
                                Unit = signUnitAmount.Substring(0, 3);
                                amount = signUnitAmount.Substring(3);
                            }
                            else
                            {
                                sign = signUnitAmount.Substring(0, 1);
                                Unit = signUnitAmount.Substring(1, 3);
                                amount = signUnitAmount.Substring(4);
                            }
                        }
                        else
                        {
                            errorObj.AddError(errorCodeList[0], policyName, ruleName, Constants.BLANK, amount);
                            isValid = false;
                            continue;
                        }

                        //Checks if negative sign is present.
                        string amt = String.Empty;
                        if (sign.Equals(Constants.ALPHAN) || sign.Equals(Constants.NEGATIVESIGN))
                        {
                            //checks if amount is zero
                            if (Convert.ToDouble(amount.Replace(Constants.CHRCOMMA, charDecimalSeparator), CultureInfo.InvariantCulture) == 0.0)
                            {
                                errorObj.AddError(Constants.ERRORT14, policyName, ruleName, Constants.BLANK, Constants.BLANK);
                                isValid = false;
                            }
                        }
                        //perform Unit validation
                        if (UnitCodeList.IndexOf(Unit) == -1)
                        {
                            errorObj.AddError(Constants.ERRORT06, policyName, ruleName, Constants.BLANK, Constants.BLANK);
                            isValid = false;
                        }

                        //Checks for leading zeros if checkLeadingZero bool is set to false
                        if (!CheckLeadingZero(amount))
                        {
                            errorObj.AddError(errorCodeList[0], policyName, ruleName, Constants.BLANK, amount);
                            isValid = false;
                        }


                        // check if Amount contain more than six digits following the decimal comma
                        string[] amount1;
                        amount1 = amount.Split(Constants.CHRCOMMA);

                        if (amount1.Length >= 2)
                        {
                            if (amount1[1].Length > 6)
                            {
                                errorObj.AddError(Constants.ERRORC89, policyName, ruleName, Constants.BLANK, Constants.BLANK);
                                return false;
                            }
                        }
                        else
                        {
                            errorObj.AddError(errorCodeList[1], policyName, ruleName, Constants.BLANK, amount);
                            return false;
                        }

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="xRoot"></param>
        /// <param name ="xPath95a" type = "string">
        ///		Comma separated input references of the elements to be validated for tag 95a.
        /// </param>
        /// <param name ="xPath22H" type = "string">
        ///		nput reference of the Element 22H in Sequence B.
        /// </param>
        /// <param name ="qualifierList22H" type = "string">
        ///		Reference containing the list of the qualifiers for xPath22H.
        /// </param>
        /// <param name ="qualifierList95a" type = "string">
        ///		Reference containing the list of the qualifiers for xPath95a.
        /// </param>
        /// <param name ="indicatorList22H" type = "string">
        ///		Reference containing the list of the indicators.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        private static bool CheckValidTagParty(XmlNode xRoot,
                                                string xPath95a,
                                                string xPath22H,
                                                string qualifierList22H,
                                                string qualifierList95a,
                                                string indicatorList22H,
                                                string errorCode,
                                                string policyName,
                                                string ruleName,
                                                string messageType,
                                                string conditionalRuleName,
                                                string conditionalRuleNumber,
                                                ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidTagParty" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                bool blnTag95aQualifier = false;
                bool qualifierPresent = false;


                string[] xPathArray = xPath95a.Split(Constants.CHRCOMMA);
                int lengthxPath = xPathArray.Length;

                XmlNodeList xList22H = xRoot.SelectNodes(xPath22H);
                foreach (XmlNode xNode22H in xList22H)
                {
                    if (xNode22H.InnerText != null && xNode22H.InnerText.Length != 0)
                    {
                        if (xNode22H.FirstChild != null && xNode22H.LastChild != null)
                        {
                            if (xNode22H.FirstChild.InnerText.CompareTo(qualifierList22H) == 0
                                && xNode22H.LastChild.InnerText.CompareTo(indicatorList22H) == 0)
                            {
                                qualifierPresent = true;
                                for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                                {
                                    XmlNodeList xList95a = xRoot.SelectNodes(xPathArray[nCount].ToString());
                                    foreach (XmlNode xNode95a in xList95a)
                                    {
                                        if (xNode95a.InnerText.ToString().Trim().CompareTo(qualifierList95a) == 0)
                                        {
                                            blnTag95aQualifier = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNode22H.Name, Constants.NOCONTENT);
                        isValid = false;
                    }

                    switch (messageType)
                    {
                        case "MT548":
                            XmlNodeList xSequenceB1 = xRoot.SelectNodes("//SequenceB1");
                            bool bIsSequenceB1Present = false;
                            if (xSequenceB1 != null && xSequenceB1.Count > 0)
                            {
                                bIsSequenceB1Present = true;
                            }
                            if (qualifierPresent == true && bIsSequenceB1Present && !blnTag95aQualifier)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                            break;

                        default:
                            if (blnTag95aQualifier == false && qualifierPresent == true)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                            break;
                    }

                    blnTag95aQualifier = false;
                    qualifierPresent = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule270
        /// </method>
        /// <summary>
        ///	If field :22F::DBNM is present in sequence C and the instruction is a delivery
        ///	(i.e. :22H::REDE//DELI in sequence B),then it is mandatory to specify a buyer,
        ///	i.e. one occurrence of subsequence C1 must contain field :95a::BUYR (Error code(s): E70).
        ///
        ///	If field :22F::DBNM is present in sequence C and the instruction is a receipt
        ///	(i.e. :22H::REDE//RECE in sequence B),then it is mandatory to specify a seller,
        ///	i.e. one occurrence of subsequence C1 must contain field :95a::SELL (Error code(s): E70).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath95a" type = "string">
        ///		Comma separated input references of the elements to be validated for tag 95a.
        /// </param>
        /// <param name ="xPath22H" type = "string">
        ///		nput reference of the Element 22H in Sequence B.
        /// </param>
        /// <param name ="qualifierDBNM" type = "string">
        ///		Reference containing the list of the qualifiers for xPath22F.
        /// </param>
        /// <param name ="qualifierList95a" type = "string">
        ///		Reference containing the list of the qualifiers for xPath95a.
        /// </param>
        /// <param name ="qualifierList22H" type = "string">
        ///		Reference containing the list of the qualifiers for xPath22H.
        /// </param>
        /// <param name ="indicatorList22H" type = "string">
        ///		Reference containing the list of the indicators.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT360
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule270(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath22F,
            string xPath95a,
            string xPath22H,
            string qualifierDBNM,
            string qualifierList22H,
            string qualifierList95a,
            string indicatorList22H,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule270" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath95a == null ||
                    xPath22F == null ||
                    xPath22H == null ||
                    xPath95a.Length == 0 ||
                    xPath22F.Length == 0 ||
                    xPath22H.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xNodeList22F = xRoot.SelectNodes(xPath22F);

                foreach (XmlNode xNode22F in xNodeList22F)
                {
                    if (xNode22F.FirstChild != null && xNode22F.FirstChild.InnerText != null
                        && xNode22F.FirstChild.InnerText.CompareTo(qualifierDBNM) == 0)
                    {
                        isValid = CheckValidTagParty(xRoot, xPath95a, xPath22H, qualifierList22H, qualifierList95a,
                            indicatorList22H, errorCode, policyName, ruleName, messageType,
                            conditionalRuleName, conditionalRuleNumber, errorObject);
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	SWIFTSRG2001NetworkRule52
        /// </method>
        /// <summary>
        /// 	This function performs Conditional Rule C52 Validation which ensures that
        /// 	if Sequence is present two or more times, optional field(s) must be present in each occurrence
        /// 	of the repetitive sequence
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPathMandatoryTag" type = "string">
        /// 	Input containing the xpath of Tag, first mandatory non-repetitive tag of Sequence.
        /// </param>
        /// <param name="xPathOptionalTags" type = "string">
        /// 	Input containing the xpath of Tags comma seprated.
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Inutput containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule52(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathMandatoryTag,
        //    string xPathOptionalTags,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    if (null == xPathOptionalTags) throw new ArgumentNullException("xPathOptionalTags");

        //    bool isValid = true;
        //    int countSeqRepetition = 0;
        //    int countOptionalTagRepetition = 0;

        //    string[] arrxPath = xPathOptionalTags.Split(Constants.CHRCOMMA);

        //    if(xDocument == null ||
        //        xPathMandatoryTag == null ||
        //        xPathOptionalTags == null ||
        //        xPathMandatoryTag.Length == 0 ||
        //        xPathOptionalTags.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    XmlNode xRoot = xDocument.Document;
        //    XmlNodeList xList1 = xRoot.SelectNodes(xPathMandatoryTag);
        //    countSeqRepetition = xList1.Count;
        //    foreach(string xPath in arrxPath)
        //    {
        //        XmlNodeList xList2 = xRoot.SelectNodes(xPath);
        //        countOptionalTagRepetition += xList2.Count;
        //    }
        //    if (countSeqRepetition > 1 &&
        //        (countSeqRepetition != countOptionalTagRepetition))
        //    {
        //        errorObject.AddError(errorCode,policyName,ruleName,
        //            messageType,conditionalRuleName,conditionalRuleNumber);
        //        isValid = false;
        //    }

        //    return isValid;
        //}

        /// <method>
        /// 	CheckValidAmount
        /// </method>
        /// <summary>
        /// 	This function Validates the no of decimal places after the comma for a specific
        /// 	currency code and it also checks for the leading zeros depending on the bool value
        /// 	set.
        /// </summary>
        /// <param name="xDocument">
        /// 	A4SWIFTXmlDocument
        /// </param>
        /// <param name="xPathTagList">
        /// 	Xpath of the tag which you are validating
        /// 	eg://SpecialConcessions_33S,//SpecialConcessions_33P
        /// </param>
        /// <param name="xPathCurrency">
        /// 	xPath of the currency field
        /// 	eg: ./Currency
        /// </param>
        /// <param name="xPathAmount">
        /// 	xPath of the currency field
        /// 	eg:./Amount
        /// </param>
        /// <param name="currencyAmountList">
        /// 	Codelist which contains the list of currencies and thier respective decimal places
        /// </param>
        /// <param name="allowLeadingZero">
        /// 	checks for leading zeros if set false.
        /// </param>
        /// <param name="amountLength">
        /// 	specify the maximum length of amount.
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="elementName">
        /// 	Tag Name
        /// </param>
        /// <param name="ruleName">
        /// 	rule name
        /// </param>
        /// <param name="policyName">
        /// 	policy name
        /// </param>
        /// <param name="errorObj">
        /// 	Error object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool CheckValidAmount(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTagList,
            string xPathCurrency,
            string xPathAmount,
            //string currencyAmountList,
            bool allowLeadingZero,
            int amountLength,
            string errorCode,
            string elementName,
            string ruleName,
            string policyName,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidAmount" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTagList == null ||
                    xPathTagList.Length == 0 ||
                    xPathCurrency == null ||
                    xPathCurrency.Length == 0 ||
                    xPathAmount == null ||
                    xPathAmount.Length == 0 ||
                    //currencyAmountList == null ||
                    //currencyAmountList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0)
                {
                    return false;
                }

                if (null == errorObj) throw new ArgumentNullException("errorObj");


                string currency = string.Empty;
                string amount = string.Empty;

                //Creates a hash table of currency codes and their corresponding
                //decimal places
                //	string[] data = currencyAmountList.Split(Constants.CHRPIPE);
                //Hashtable currencyList = new Hashtable();
                //	BuildCurrencyList(data,ref currencyList);


                XmlNode xRoot = xDocument.Document;

                //Splitting XpathTagList
                string[] arrxPath = xPathTagList.Split(Constants.CHRCOMMA);
                char[] removeAlphabets = Constants.ALPHASET.ToCharArray();
                foreach (string xPathTag in arrxPath)
                {
                    //Selects all the occurences of the tag in the message
                    XmlNodeList xTagList = xRoot.SelectNodes(xPathTag);

                    foreach (XmlNode xNode in xTagList)
                    {
                        XmlNode amountNode = xNode.SelectSingleNode(xPathAmount);
                        if (amountNode != null)
                        {
                            amount = xNode.SelectSingleNode(xPathAmount).InnerText;
                        }

                        // Added to remove any Alphabhets
                        amount = amount.TrimStart(removeAlphabets);

                        //Extracts the currency and amount of the tag.
                        if (xNode.SelectSingleNode(xPathAmount) != null &&
                            amount != null &&
                            amount.Length <= amountLength)
                        {
                            if (xNode.SelectSingleNode(xPathCurrency) != null)
                            {
                                currency = xNode.SelectSingleNode(xPathCurrency).InnerText;
                            }

                            isValid = CheckCurrencyAmount(currency, amount, allowLeadingZero,
                                true, true, errorCode, Constants.ELEMENTCURRENCYNAME, elementName, ruleName, policyName,
                                errorObj);

                        }

                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }

        /// <method>
        /// 	CheckValidWeighingFactor
        /// </method>
        /// <summary>
        /// 	This function Validates the no of decimal places after the comma for a specific
        /// 	Weight Factor and it also checks for the leading zeros depending on the bool value
        /// 	set.
        /// </summary>
        /// <param name="xDocument">
        /// 	A4SWIFTXmlDocument
        /// </param>
        /// <param name="xPathTagList">
        /// 	Xpath of the tag which you are validating
        /// 	eg://SpotAveragingWeightingFactor_J1_19Y,//StrikeAveragingWeightingFactor_J2_19Z
        /// </param>
        /// <param name="xPathWeight">
        /// 	xPath of the Weigtht field
        /// 	eg: ./Weight
        /// <param name="allowLeadingZero">
        /// 	checks for leading zeros if set false.
        /// </param>
        /// <param name="WeightLength">
        /// 	specify the maximum length of amount.
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="elementName">
        /// 	Tag Name
        /// </param>
        /// <param name="ruleName">
        /// 	rule name
        /// </param>
        /// <param name="policyName">
        /// 	policy name
        /// </param>
        /// <param name="errorObj">
        /// 	Error object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool CheckValidWeighingFactor(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTagList,
            string xPathWeight,
            bool allowLeadingZero,
            int WeightLength,
            string errorCode,
            string elementName,
            string ruleName,
            string policyName,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidWeighingFactor" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTagList == null ||
                    xPathTagList.Length == 0 ||
                    xPathWeight == null ||
                    xPathWeight.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0)
                {
                    return false;
                }

                if (null == errorObj) throw new ArgumentNullException("errorObj");

                string weight = string.Empty;
                XmlNode xRoot = xDocument.Document;

                //Splitting XpathTagList
                string[] arrxPath = xPathTagList.Split(Constants.CHRCOMMA);
                char[] removeAlphabets = Constants.ALPHASET.ToCharArray();
                foreach (string xPathTag in arrxPath)
                {
                    //Selects all the occurences of the tag in the message
                    XmlNodeList xTagList = xRoot.SelectNodes(xPathTag);

                    foreach (XmlNode xNode in xTagList)
                    {
                        XmlNode WeightNode = xNode.SelectSingleNode(xPathWeight);
                        if (WeightNode != null)
                        {
                            weight = xNode.SelectSingleNode(xPathWeight).InnerText;
                        }

                        // Added to remove any Alphabhets
                        weight = weight.TrimStart(removeAlphabets);

                        //Extracts the currency and amount of the tag.
                        if (WeightNode != null &&
                            weight != null &&
                            weight.Length <= WeightLength)
                        {
                            isValid = CheckWeighingFactor(weight, allowLeadingZero,
                                errorCode, elementName, ruleName, policyName,
                                errorObj);

                        }

                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }

        /// <method>
        /// 	CheckWeighingFactor
        /// </method>
        /// <summary>
        /// 	This function performs the amount and currency validation depending the bool values set.
        /// </summary>
        /// <param name="weight">
        ///		Contains the weightfactor value to be validated
        /// </param>
        /// <param name="allowLeadingZero">
        ///		if set to false this function will perform leadingzero validation.
        /// <param name="errorCode">
        ///		errorCode
        /// </param>
        /// <param name="elementWeightName">
        ///		weight element name
        /// </param>
        /// <param name="ruleName">
        ///		rule name
        /// </param>
        /// <param name="policyName">
        ///		policy name
        /// </param>
        /// <param name="errorObj">
        ///		errorObject
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool CheckWeighingFactor(string weight,
            bool allowLeadingZero,
            string errorCode,
            string elementWeightName,
            string ruleName,
            string policyName,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckWeighingFactor" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == errorCode) throw new ArgumentNullException("ErrorCode");
                if (null == errorObj) throw new ArgumentNullException("errorObj");

                string[] errorCodeList = errorCode.Split(Constants.CHRCOMMA);
                int errorCodeCount = errorCodeList.Length;


                //default (true) does not check leading zero
                if (!allowLeadingZero)
                {
                    //Checks for leading zeros if checkLeadingZero bool is set to false
                    if (!CheckLeadingZero(weight))
                    {
                        if (errorCodeCount == Constants.INT3)
                        {
                            errorObj.AddError(errorCodeList[1], policyName, ruleName, elementWeightName, weight);
                            return false;
                        }
                        else
                        {
                            errorObj.AddError(Constants.ERRORT40, policyName, ruleName, elementWeightName, weight);
                            return false;
                        }
                        //isValid = false;
                    }
                }

              

                    //Extracts the decimal digits after dot fron the amount present in string.
                    string[] weightData = weight.Split(Constants.CHRCOMMA);

                    //Checks for the validity of amount
                    if (weightData.Length >= 2)
                    {
                        if (Convert.ToInt32(1, CultureInfo.InvariantCulture) != -1 &&
                            weightData.Length > 1 && weightData[1].Length > Convert.ToInt32(1, CultureInfo.InvariantCulture))
                        {
                            errorObj.AddError(errorCodeList[0], policyName, ruleName, elementWeightName, weight);
                            isValid = false;
                        }
                    }
                    else
                    {
                        errorObj.AddError(errorCodeList[1], policyName, ruleName, elementWeightName, weight);
                        return false;
                    }
                }
            
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;
        }


        /// <method>
        /// 	CheckValidAmountWithMultipleDecimals
        /// </method>
        /// <summary>
        /// 	This function Validates the no of decimal places after the comma for a specific
        /// 	currency code and it also checks for the leading zeros depending on the bool value
        /// 	set.
        /// </summary>
        /// <param name="xDocument">
        /// 	A4SWIFTXmlDocument
        /// </param>
        /// <param name="xPathTagList">
        /// 	Xpath of the tag which you are validating
        /// 	eg://SpecialConcessions_33S,//SpecialConcessions_33P
        /// </param>
        /// <param name="xPathCurrency">
        /// 	xPath of the currency field
        /// 	eg: ./Currency
        /// </param>
        /// <param name="xPathAmount">
        /// 	xPath of the currency field
        /// 	eg:./Amount
        /// </param>
        /// <param name="currencyAmountList">
        /// 	Codelist which contains the list of currencies and thier respective decimal places
        /// </param>
        /// <param name="allowLeadingZero">
        /// 	checks for leading zeros if set false.
        /// </param>
        /// <param name="amountLength">
        /// 	specify the maximum length of amount.
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="elementName">
        /// 	Tag Name
        /// </param>
        /// <param name="ruleName">
        /// 	rule name
        /// </param>
        /// <param name="policyName">
        /// 	policy name
        /// </param>
        /// <param name="errorObj">
        /// 	Error object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool CheckValidAmountWithMultipleDecimals(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTagList,
            string xPathCurrency,
            string xPathAmount,
            bool allowLeadingZero,
            int amountLength,
            string errorCode,
            string elementName,
            string ruleName,
            string policyName,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidAmountWithMultipleDecimals" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null || xPathTagList == null || xPathTagList.Length == 0 || xPathCurrency == null ||
                    xPathCurrency.Length == 0 || xPathAmount == null || xPathAmount.Length == 0 || errorCode == null || errorCode.Length == 0)
                {
                    return false;
                }

                if (null == errorObj) { throw new ArgumentNullException("errorObj"); }

                string currency = string.Empty;
                string amount = string.Empty;

                XmlNode xRoot = xDocument.Document;

                //Splitting XpathTagList
                string[] arrxPath = xPathTagList.Split(Constants.CHRCOMMA);
                char[] removeAlphabets = Constants.ALPHASET.ToCharArray();
                foreach (string xPathTag in arrxPath)
                {
                    //Selects all the occurences of the tag in the message
                    XmlNodeList xTagList = xRoot.SelectNodes(xPathTag);

                    foreach (XmlNode xNode in xTagList)
                    {
                        XmlNode amountNode = xNode.SelectSingleNode(xPathAmount);
                        if (amountNode != null)
                        {
                            amount = xNode.SelectSingleNode(xPathAmount).InnerText;
                        }

                        // Added to remove any Alphabhets
                        amount = amount.TrimStart(removeAlphabets);

                        //Extracts the currency and amount of the tag.
                        if (xNode.SelectSingleNode(xPathAmount) != null && amount != null && amount.Length <= amountLength)
                        {
                            if (xNode.SelectSingleNode(xPathCurrency) != null)
                            {
                                currency = xNode.SelectSingleNode(xPathCurrency).InnerText;
                            }

                            isValid = CheckCurrencyAmountWithMultipleDecimals(currency, amount, allowLeadingZero, true, true, errorCode,
                                Constants.ELEMENTCURRENCYNAME, elementName, ruleName, policyName, errorObj);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw e;
            }

            return isValid;
        }

        /// <method>
        /// 	CheckCurrencyAmountWithMultipleDecimals
        /// </method>
        /// <summary>
        /// 	This function performs the amount and currency validation depending the bool values set.
        /// </summary>
        /// <param name="currency">
        ///		Contains the currency value to be validated
        /// </param>
        /// <param name="amount">
        ///		Contains the Amount value to be validated
        /// </param>
        /// <param name="currencyAmountList">
        ///		Contains the currency list and corresponding decimal places.
        /// </param>
        /// <param name="allowLeadingZero">
        ///		if set to false this function will perform leadingzero validation.
        /// </param>
        /// <param name="isCurrencyValidationRequired">
        ///		if set to true this function will perform currency code validation.
        /// </param>
        /// <param name="isCurrencyAmountValidationRequired">
        ///		if set to true this function will perform Amounts decimal place validation
        ///		with corresponding currency.
        /// </param>
        /// <param name="errorCode">
        ///		errorCode
        /// </param>
        /// <param name="elementCurrencyName">
        ///		Currency element name
        /// </param>
        /// <param name="elementAmountName">
        ///		Amount element name
        /// </param>
        /// <param name="ruleName">
        ///		rule name
        /// </param>
        /// <param name="policyName">
        ///		policy name
        /// </param>
        /// <param name="errorObj">
        ///		errorObject
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool CheckCurrencyAmountWithMultipleDecimals(string currency,
            string amount,
            bool allowLeadingZero,
            bool isCurrencyValidationRequired,
            bool isCurrencyAmountValidationRequired,
            string errorCode,
            string elementCurrencyName,
            string elementAmountName,
            string ruleName,
            string policyName,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckCurrencyAmountWithMultipleDecimals" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (currency == null || currency.Length == 0 || currency.Length == 0)
                {
                    return false;
                }

                if (null == errorCode) { throw new ArgumentNullException("ErrorCode"); }
                if (null == errorObj) { throw new ArgumentNullException("errorObj"); }

                //Split the errorCodes passed
                string[] errorCodeList = errorCode.Split(Constants.CHRCOMMA);
                int errorCodeCount = errorCodeList.Length;

                //default (true) does not check leading zero
                if (!allowLeadingZero)
                {
                    //Checks for leading zeros if checkLeadingZero bool is set to false
                    if (!CheckLeadingZero(amount))
                    {
                        if (errorCodeCount == Constants.INT3)
                        {
                            errorObj.AddError(errorCodeList[1], policyName, ruleName, elementAmountName, amount);
                            return false;
                        }
                        else
                        {
                            errorObj.AddError(Constants.ERRORT40, policyName, ruleName, elementAmountName, amount);
                            return false;
                        }
                    }
                }

                if (!SqlConnector.hashCurrencyCodeList.ContainsKey(currency))
                {
                    isValid = false;
                    isCurrencyAmountValidationRequired = false;
                    errorObj.AddError(Constants.ERRORT52, policyName, ruleName, elementCurrencyName, currency);
                }

                if (isCurrencyAmountValidationRequired)
                {
                    //Extracts the decimal places value for a currency code from the
                    string decimalplaces = (String)SqlConnector.hashCurrencyCodeList[currency];

                    //Extracts the decimal digits after dot fron the amount present in string.
                    string[] amountData = amount.Split(Constants.CHRCOMMA);

                    //Checks for the validity of amount
                    if (amountData.Length < 2)
                    {
                        errorObj.AddError(errorCodeList[2], policyName, ruleName, elementAmountName, amount);
                        return false;
                    }
                }

                //Checks if the currency is present in the currency list provided
                if ((isCurrencyValidationRequired || isCurrencyAmountValidationRequired)
                    && !SqlConnector.hashCurrencyCodeList.Contains(currency))
                {
                    isValid = false;
                    isCurrencyAmountValidationRequired = false;
                }

                if (isCurrencyAmountValidationRequired)
                {
                    //Extracts the decimal places value for a currency code from the
                    string decimalplaces = (String)SqlConnector.hashCurrencyCodeList[currency];

                    //Extracts the decimal places after comma fron the amount present in tag.
                    string[] amountData = amount.Split(Constants.CHRCOMMA);

                    //Checks for the validity of amount
                    if (amountData.Length < 2)
                    {
                        errorObj.AddError(errorCodeList[2], policyName, ruleName, elementAmountName, amount);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw e;
            }

            return isValid;
        }

        /// <method>
        /// 	CheckForLeadingZero
        /// </method>
        /// <summary>
        /// 	This function does the leading zero validation for rate
        /// </summary>
        /// <param name="xDocument">
        /// 	XMLDocument
        /// </param>
        /// <param name="xPath">
        /// 	xPath of Tag
        /// 	eg;//Rate_91/SignRate
        /// </param>
        /// <param name="errorCode">
        /// 	errorCode
        /// </param>
        /// <param name="ruleName">
        /// 	RuleName
        /// </param>
        /// <param name="policyName">
        /// 	policyName
        /// </param>
        /// <param name="errorObj">
        /// 	Error object
        /// </param>
        /// <returns>
        /// 	bool
        ///</returns> 
        public static bool CheckForLeadingZero(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string ruleName,
            string policyName,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckForLeadingZero" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xPath == null ||
                    xPath.Length == 0)
                {
                    return false;
                }

                if (null == errorObj) throw new ArgumentNullException("ErrorObj");
                if (null == xDocument) throw new ArgumentNullException("xDocument");


                string sign = String.Empty;
                string rate = String.Empty; ;

                XmlNode xRoot = xDocument.Document;

                string[] arrayxPath = xPath.Split(Constants.CHRCOMMA);

                foreach (string xPathTag in arrayxPath)
                {
                    XmlNodeList xTagList = xRoot.SelectNodes(xPathTag);

                    foreach (XmlNode xNode in xTagList)
                    {
                        sign = String.Empty;
                        if (xNode.InnerText != null)
                        {
                            if (Constants.NUMBERSET.IndexOf(xNode.InnerText.Substring(0, 1)) != -1)
                            {
                                rate = xNode.InnerText;
                            }
                            else
                            {
                                sign = xNode.InnerText.Substring(0, 1);

                                rate = xNode.InnerText.Substring(1);
                            }

                            string[] data = rate.Trim().Split(Constants.CHRCOMMA);
                            // If starts with zero and integer part not equal to zero,
                            // then the field has leading zeroes. Return false. Else return true.
                            if ((data[0].StartsWith("0")) && (Convert.ToInt64(data[0], CultureInfo.InvariantCulture) != 0))
                            {
                                errorObj.AddError(errorCode, policyName, ruleName, xNode.LocalName, rate);
                                isValid = false;
                            }

                        }
                    }

                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        /// 	CheckLeadingZero
        /// </method>
        /// <summary>
        /// 	This functions returns false if leading zeros are preseent in amount
        /// </summary>
        /// <param name="amount">
        /// 	amount
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool CheckLeadingZero(string amount)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckLeadingZero:");
            try
            {
                if (amount == null || amount.Length == 0)
                {
                    return false;
                }

                string[] data = amount.Trim().Split(Constants.CHRCOMMA);
                // If valid SWIFT Number field and starts with zero and integer part not equal to zero,
                // then the field has leading zeroes. Return false. Else return true.
                if ((IsValidSWIFTNumberField(amount.Trim()))
                    && (data[0].StartsWith("0")) && (Convert.ToInt64(data[0], CultureInfo.InvariantCulture) != 0))
                {
                    return false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return true;
        }

        /// <method>
        /// 	BuildCurrencyList
        /// </method>
        /// <summary>
        /// This function returns a hash table with currency code and its
        ///		corresponding decimal places
        /// </summary>
        /// <param name="data">list of currencies and decimal places</param>
        /// <param name="currencyList">the hash table</param>

        //		private static void BuildCurrencyList(string[] data,ref Hashtable currencyList)
        //		{
        //			for(int i = 0; i < data.Length;i++)
        //			{
        //				//looks for list of currency codes
        //				if (i % 2 != 0)
        //				{
        //					//Gets individual currency
        //					string[] currencies = data[i].Split(Constants.CHRCOMMA);
        //
        //					// Assigns a currency code with its corresponding decimal value.
        //					for (int j = 0; j < currencies.Length; j++)
        //					{
        //						currencyList.Add(currencies[j],data[i-1]);
        //					}
        //				}
        //			}
        //		}

        /// <method>
        /// IsValidPriceCode
        /// </method>
        /// <summary>
        /// This function performs a validation on ReferenceCode ,third field in CommonReference Node, which must
        /// consist of the rightmost non-zero digit of field specified by xPathPriceCode, preceded by the three
        /// digits to the left of it. If there are no digits to the left of it, the space must be zero filled.
        /// Here in Tag 33G Price and code are implemented in a single field, therefore this function is required.
        /// </summary>
        /// <param name="xDocument" Type = " string" >
        /// Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathReferenceCode" Type = " string">
        /// Reference containing the xPath of the ReferenceCode in CommonReference Node(element 22/22C).
        /// </param>
        /// <param name="xPathPriceCode" Type = " string">
        /// Reference containing the xPath of the Decimal Part in PriceCode.
        /// </param>
        /// <param name="errorCode" Type = " string" >
        /// Input containing Error Code</param>
        /// <param name="policyName" Type = " string">
        /// Input Containing Policy Name
        /// </param>
        /// <param name="ruleName" Type = " string">
        /// Input Containing Rule Name.
        /// </param>
        /// <param name="errorObject" Type = "ErrorCollection">
        /// Input Containing Object of ErrorCollection used to Add errors.
        /// </param>
        /// <returns> Boolean</returns>

        public static bool IsValidPriceCode(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathReferenceCode,
            string xPathPriceCode,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidPriceCode" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathReferenceCode == null ||
                    xPathPriceCode == null ||
                    xPathReferenceCode.Length == 0 ||
                    xPathPriceCode.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNode xReferenceCode = xRoot.SelectSingleNode(xPathReferenceCode.ToString());
                XmlNode xPriceCode = xRoot.SelectSingleNode(xPathPriceCode.ToString());
                string priceCode = xPriceCode.InnerText;
                int startPositionAmount = priceCode.IndexOf(Constants.ALPHASET);
                string amount = string.Empty;

                if (startPositionAmount == -1)
                {
                    amount = priceCode;
                }
                else
                {
                    amount = priceCode.Substring(0, priceCode.Length - startPositionAmount);
                }


                char[] checkReference = new char[4];
                string referenceCode1 = string.Empty;
                int digitCount = 4;
                bool flag = false;

                if (xReferenceCode != null && xReferenceCode.InnerText != null)
                {

                    char[] price = amount.ToCharArray();
                    string referenceCode = xReferenceCode.InnerText;

                    for (int i = price.Length - 1; (i >= 0 && digitCount > 0); i--)
                    {
                        if (price[i] != Constants.CHR0 || flag == true)
                        {
                            if (price[i] != Constants.CHRCOMMA && price[i] != Constants.NEGATIVESIGN)
                            {

                                checkReference[digitCount - 1] = price[i];
                                digitCount--;
                                if (!flag)
                                {
                                    flag = true;
                                }

                            }
                        }
                    }

                    if (digitCount > 0)
                    {
                        for (int i = 0; i < digitCount; i++)
                        {
                            checkReference[digitCount - i - 1] = '0';

                        }

                    }
                    // Concatenate the characters in checkReference array and save it as string in referenceCode1.
                    for (int nCount = 0; nCount < checkReference.Length; nCount++)
                    {
                        referenceCode1 = referenceCode1 + checkReference[nCount].ToString();
                    }

                    if (referenceCode.CompareTo(referenceCode1) != 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, xReferenceCode.Name, referenceCode);
                        isValid = false;
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }

        /// <method>
        ///		IsValidPartyIdentifierLocation
        /// </method>
        /// <summary>
        ///		It checks for the tags like 53B and 57B wher party identifier and Location are optional,
        ///		this method checks for the presence of atleast one field.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the tag for which u are checking.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		leave this blank.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidPartyIdentifierLocation(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidPartyIdentifierLocation" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of the tag in the message

                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach (XmlNode xNode in xList)
                {
                    if (!xNode.HasChildNodes || null == xNode.InnerText)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, xNode.Name, xNode.InnerText);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;
        }

        /// <method>
        /// 	IsValidCertificateNumber
        /// </method>
        /// <summary>
        /// 	In Tag 13B Data Source Scheme must not be used when Number is ISO 8532,
        /// 	Securities - Format for transmission of certificate numbers.
        /// </summary>
        /// <param name="xDocument" type = "string" >
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag" type = "string">
        /// 	Input containg reference of Tag 13B.
        /// </param>
        /// <param name="xPathDataSourceScheme" type = "string">
        /// 	Input containing reference of field DataSourceScheme.
        /// </param>
        /// <param name="xPathNumber" type = "string">
        /// 	Input Containing reference of field Number.
        /// </param>
        /// <param name="numberValue" type = "string">
        /// 	Value of the number, in this case ISO 8532.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidCertificateNumber(TypedXmlDocument xDocument,
            string xPathTag,
            string xPathDataSourceScheme,
            string xPathNumber,
            string numberValue,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCertificateNumber" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathNumber == null ||
                    xPathNumber.Length == 0 ||
                    numberValue == null ||
                    numberValue.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xNodelist = xRoot.SelectNodes(xPathTag);

                foreach (XmlNode xNode in xNodelist)
                {
                    if (xNode.SelectSingleNode(xPathNumber) != null &&
                        xNode.SelectSingleNode(xPathNumber).InnerText != null &&
                        xNode.InnerText != null &&
                        xNode.SelectSingleNode(xPathNumber).InnerText.CompareTo(numberValue) == 0
                        && xNode.SelectSingleNode(xPathDataSourceScheme) != null)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, xNode.Name, xNode.InnerText);
                        return false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return true;

        }

        /// <method>
        ///		SWIFTNetworkRule89
        /// </method>
        /// <summary>
        ///		This function checks for a specific number of digits in the Amount field after the
        ///		comma
        /// </summary>
        /// <param name="xDocument">
        ///		 A4SWIFTXmlDocument
        /// </param>
        /// <param name="xPathTagList">
        ///		 Xpath of the tag which you are validating
        /// </param>
        /// <param name="xPathField">
        /// 	xPath of the Amount field
        /// 	eg: ./Amount
        /// </param>
        /// <param name="count">
        /// 	Number of digits required after the decimal comma
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="policyName">
        /// 	policy name
        /// </param>
        /// <param name="ruleName">
        /// 	rule name
        /// </param>
        /// <param name="elementName">
        /// 	Tag Name
        /// </param>
        /// <param name="elementValue">
        /// 	Input containing element value
        /// </param>
        /// <param name="errorObject">
        /// 	Error Object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool SWIFTNetworkRule89(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTagList,
            string xPathField,
            int count,
            string errorCode,
            string policyName,
            string ruleName,
            string elementName,
            string elementValue,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule89" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTagList == null ||
                    xPathTagList.Length == 0 ||
                    xPathField == null ||
                    xPathField.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                string[] xPathArray = xPathTagList.Split(Constants.CHRCOMMA);
                XmlNode xRoot = xDocument.Document;

                string[] amount;

                foreach (string xPath in xPathArray)
                {
                    XmlNodeList xList = xRoot.SelectNodes(xPath);

                    foreach (XmlNode xNode in xList)
                    {
                        if (xNode.SelectSingleNode(xPathField) != null &&
                            xNode.SelectSingleNode(xPathField).InnerText != null)
                        {
                            amount = xNode.SelectSingleNode(xPathField).InnerText.Split(Constants.CHRCOMMA);
                            if (amount.Length >= 2) //Added in SRG2010 to Fix Bug No. 158658
                            {
                                if (amount[1].Length > count)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, elementName, elementValue);
                                    isValid = false;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule283
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 283 to
        ///		be implemented. In each occurrence of sequence C, the presence
        ///		of subsequences C1, C2 and C3 depends on the value of field :22H::COLL//"Indicator"
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the Sequence
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input containing the xPath of the Tag 22H in the Sequence
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the Qualifier value
        /// </param>
        /// <param name ="indicatorValueList" type = "string">
        ///		Input containing the comma separated Indicator values
        /// </param>
        /// <param name ="xPathSubSequenceList" type = "string">
        ///		Input containing the comma separated xPaths of SubSequences
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool SWIFTNetworkRule283(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag,
            string qualifierValue,
            string indicatorValueList,
            string xPathSubSequenceList,
            ErrorCollection errorObject,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule283" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            string qualifier = string.Empty;
            string indicator = string.Empty;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    qualifierValue == null ||
                    qualifierValue.Length == 0 ||
                    indicatorValueList == null ||
                    indicatorValueList.Length == 0 ||
                    xPathSubSequenceList == null ||
                    xPathSubSequenceList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of the Sequence
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                //Store the Indicator values in an array
                string[] indicatorList = indicatorValueList.Split(Constants.CHRCOMMA);

                //Store the xPaths of Subsequences in an array
                string[] sequenceList = xPathSubSequenceList.Split(Constants.CHRCOMMA);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    //Select the Tag 22H in the Sequence
                    XmlNodeList xList = xNodeSequence.SelectNodes(xPathTag);

                    foreach (XmlNode xNode in xList)
                    {
                        if (xNode.FirstChild != null && xNode.FirstChild.InnerText != null)
                        {
                            //Get the Qualifier value
                            qualifier = xNode.FirstChild.InnerText;
                        }
                        if (qualifier.CompareTo(qualifierValue) == 0)
                        {
                            if (xNode.LastChild != null && xNode.LastChild.InnerText != null)
                            {
                                //Get the Indicator value
                                indicator = xNode.LastChild.InnerText;
                            }
                            //If Indicator value is equal to SCOL
                            if (indicator.CompareTo(indicatorList[2]) == 0)
                            {
                                if (xNodeSequence.SelectSingleNode(sequenceList[0]) == null || xNodeSequence.SelectSingleNode(sequenceList[1]) != null || xNodeSequence.SelectSingleNode(sequenceList[2]) != null)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                            }
                            //If Indicator value is equal to CCOL
                            if (indicator.CompareTo(indicatorList[1]) == 0)
                            {
                                if (xNodeSequence.SelectSingleNode(sequenceList[0]) != null || xNodeSequence.SelectSingleNode(sequenceList[1]) == null || xNodeSequence.SelectSingleNode(sequenceList[2]) != null)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                            }
                            //If Indicator value is equal to BCOL
                            if (indicator.CompareTo(indicatorList[0]) == 0)
                            {
                                if (xNodeSequence.SelectSingleNode(sequenceList[0]) != null || xNodeSequence.SelectSingleNode(sequenceList[1]) != null || xNodeSequence.SelectSingleNode(sequenceList[2]) == null)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                            }
                        }

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule272
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 272.
        ///		In each occurrence of subsequence C3, if field :22H::BCOL//LCOL is present, then field
        ///		:98B::EXPI//OPEN (i.e. Qualifier = EXPI, Data Source Scheme not present and Date Code
        ///		= OPEN) is not allowed, otherwise field :98B::EXPI//OPEN is optional
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the Sequence
        /// </param>
        /// <param name ="xPathTag22H" type = "string">
        ///		Input containing the xPath of the Tag 22H in the Sequence
        /// </param>
        /// <param name ="indicatorValue" type = "string">
        ///		Input containing the Indicator value
        /// </param>
        /// <param name ="xPathTag98B" type = "string">
        ///		Input containing the xPath of the Tag 98B in the Sequence
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Input containing the xPath of the Data Source Scheme
        /// </param>
        /// <param name ="dateCodeValue" type = "string">
        ///		Input containing the Date Code value
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool SWIFTNetworkRule272(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag22H,
            string indicatorValue,
            string xPathTag98B,
            string xPathDataSourceScheme,
            string dateCodeValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule272" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag22H == null ||
                    xPathTag22H.Length == 0 ||
                    indicatorValue == null ||
                    indicatorValue.Length == 0 ||
                    xPathTag98B == null ||
                    xPathTag98B.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    dateCodeValue == null ||
                    dateCodeValue.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of the Sequence
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    //Select the node of Tag 22H in the Sequence
                    XmlNode xNode22H = xNodeSequence.SelectSingleNode(xPathTag22H);

                    //If the Indicator value is LCOL
                    if (xNode22H != null &&
                        xNode22H.LastChild != null &&
                        xNode22H.LastChild.InnerText != null &&
                        xNode22H.LastChild.InnerText.CompareTo(indicatorValue) == 0)
                    {
                        //Select all the nodes of Tag 98B in the Sequence
                        XmlNodeList xList98B = xNodeSequence.SelectNodes(xPathTag98B);

                        foreach (XmlNode xNode98B in xList98B)
                        {
                            //In the Tag 98B, if Data Source Scheme is not present and
                            //Date Code value is OPEN, throw an error
                            if (xNode98B.LastChild != null &&
                                xNode98B.SelectSingleNode(xPathDataSourceScheme) == null &&
                                xNode98B.LastChild.InnerText != null &&
                                xNode98B.LastChild.InnerText.CompareTo(dateCodeValue) == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule94
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 94.
        ///		The user header of the message (block 3) is mandatory and must contain a valid code in the Validation Flag field 119 (
        /// 	{3:{119:xxxx}} ). This code must be identical to the code contained in field :22H::COLA//xxxx (Exposure Type Indicator)
        ///		in sequence A of the message content (text block 4)
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xHeaderDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the Header xml document to be validated
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input containing the xPath of the Tag 22H in Sequence A
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the Qualifier value
        /// </param>
        /// <param name ="xPathHeaderTag119" type = "string">
        ///		Input containing the xPath of the Header Tag 119
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool SWIFTNetworkRule94(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            Microsoft.RuleEngine.TypedXmlDocument xHeaderDocument,
            string xPathTag,
            string qualifierValue,
            string xPathHeaderTag119,
            ErrorCollection errorObject,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule94" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xHeaderDocument == null ||
                    xPathTag == null ||
                    qualifierValue == null ||
                    xPathHeaderTag119 == null ||
                    xPathTag.Length == 0 ||
                    qualifierValue.Length == 0 ||
                    xPathHeaderTag119.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                string indicator = string.Empty;

                XmlNode xRoot = xDocument.Document;
                XmlNode xHeader = xHeaderDocument.Document;

                //Select the nodes of Tag 22H
                XmlNodeList xList = xRoot.SelectNodes(xPathTag);

                foreach (XmlNode xNode in xList)
                {
                    //Check if the Qualifier value is COLA
                    if (xNode.FirstChild != null &&
                        xNode.FirstChild.InnerText != null &&
                        xNode.FirstChild.InnerText.CompareTo(qualifierValue) == 0
                        && xNode.LastChild != null)
                    {
                        //Get the Indicator value
                        indicator = xNode.LastChild.InnerText;
                    }
                }

                //Select the node of the Header Tag 119
                XmlNode xNodeHeader = xHeader.SelectSingleNode(xPathHeaderTag119);

                //If either Header Tag 119 is not present (or) value of the Header Tag 119
                //is not equal to Indicator value, throw an error
                if ((xNodeHeader == null || xNodeHeader.InnerText.CompareTo(indicator) != 0) && indicator != string.Empty)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		CheckAgreementIndicator
        /// </method>
        /// <summary>
        ///		This method performs validation for the Usage Rule of Tag 22F in Sequence A1.
        ///		For agreements different from the ones listed in the code list for Indicator,
        ///		field 70C should be used
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the Sequence
        /// </param>
        /// <param name ="xPathTag22F" type = "string">
        ///		Input containing the xPath of the Tag 22F in the Sequence
        /// </param>
        /// <param name ="indicatorValueList" type = "string">
        ///		Input containing the list of Indicator values
        /// </param>
        /// <param name ="xPathTag70C" type = "string">
        ///		Input containing the xPath of the Tag 70C in the Sequence
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool CheckAgreementIndicator(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag22F,
            string indicatorValueList,
            string xPathTag70C,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckAgreementIndicator" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {


                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag22F == null ||
                    xPathTag22F.Length == 0 ||
                    indicatorValueList == null ||
                    indicatorValueList.Length == 0 ||
                    xPathTag70C == null ||
                    xPathTag70C.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of the Sequence
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    //Select the node of Tag 22F in the Sequence
                    XmlNode xNode22F = xNodeSequence.SelectSingleNode(xPathTag22F);

                    //Select the node of Tag 70C in the Sequence
                    XmlNode xNode70C = xNodeSequence.SelectSingleNode(xPathTag70C);

                    if (xNode22F != null && xNode22F.LastChild != null)
                    {
                        //If the Indicator value is not in the list and Tag 70C
                        //is not present, throw an error
                        if (indicatorValueList.IndexOf(xNode22F.LastChild.InnerText) == -1
                            && xNode70C == null)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, xNodeSequence.LocalName, xNode22F.LocalName, xNode22F.LastChild.InnerText);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		CheckAgreementVersionNumber
        /// </method>
        /// <summary>
        ///		This method performs validation for the Usage Rule of Tag 13B in Sequence A1.
        ///		For ISDA agreements (:22F::AGRE//ISDA), Data Source Scheme should not be used
        ///		and Number should be a year in the YYYY format
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the Sequence
        /// </param>
        /// <param name ="xPathTag22F" type = "string">
        ///		Input containing the xPath of the Tag 22F in the Sequence
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Input containing the xPath of the Data Source Scheme
        /// </param>
        /// <param name ="indicatorValue" type = "string">
        ///		Input containing the Indicator value
        /// </param>
        /// <param name ="xPathTag13B" type = "string">
        ///		Input containing the xPath of the Tag 13B in the Sequence
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool CheckAgreementVersionNumber(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag22F,
            string xPathDataSourceScheme,
            string indicatorValue,
            string xPathTag13B,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckAgreementVersionNumber" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                string number = string.Empty;

                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag22F == null ||
                    xPathTag22F.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    indicatorValue == null ||
                    indicatorValue.Length == 0 ||
                    xPathTag13B == null ||
                    xPathTag13B.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                char[] numerics;
                XmlNode xRoot = xDocument.Document;
                //Select all the nodes of the Sequence
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    //Select the node of Tag 22F in the Sequence
                    XmlNode xNode22F = xNodeSequence.SelectSingleNode(xPathTag22F);

                    //Select the node of Tag 13B in the Sequence
                    XmlNode xNode13B = xNodeSequence.SelectSingleNode(xPathTag13B);

                    //If ISDA agreement(:22F::AGRE//ISDA) and Tag 13B present
                    if (xNode22F != null && xNode22F.SelectSingleNode(xPathDataSourceScheme) == null
                        && xNode22F.LastChild != null &&
                        xNode22F.LastChild.InnerText != null &&
                        xNode22F.LastChild.InnerText.CompareTo(indicatorValue) == 0
                        && xNode13B != null)
                    {
                        //If Data Source Scheme is present in Tag 13B, throw an error
                        if (xNode13B.SelectSingleNode(xPathDataSourceScheme) != null)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, xNodeSequence.LocalName, xNode13B.LocalName, xNode13B.SelectSingleNode(xPathDataSourceScheme).InnerText);
                            isValid = false;
                        }
                        else
                        {
                            if (xNode13B.LastChild != null)
                            {
                                //If the length of the Number is not equal to 4, throw an error
                                if (xNode13B.LastChild.InnerText.Length != 4)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                        xNodeSequence.LocalName, xNode13B.LocalName, xNode13B.LastChild.InnerText);
                                    isValid = false;
                                }
                                else
                                {
                                    numerics = xNode13B.LastChild.InnerText.ToCharArray();

                                    for (int count = 0; count < numerics.Length; count++)
                                    {
                                        //If the Number is not in YYYY format, throw an error
                                        if (Constants.NUMBERSET.IndexOf(numerics[count]) == -1)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, xNodeSequence.LocalName,
                                                xNode13B.LocalName, xNode13B.LastChild.InnerText);
                                            isValid = false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		CheckLeadingZeroInElement
        /// </method>
        /// <summary>
        ///		This method performs validation for the Leading Zeroes in elements
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathList" type = "string">
        ///		Input containing the list of xPaths of the Elements
        /// </param>
        /// <param name ="elementName" type = "string">
        ///		Input containing the Element name
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise
        /// </returns>
        public static bool CheckLeadingZeroInElement(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathList,
            string elementName,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckLeadingZeroInElement" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            return true;

            /* Bug#  94141 - Commenting out this functionality to return true always (i.e. No error
             * will be logged irrespective of whatever value is passed in.
             * This functionality is being used by policies that pass in Rate fields which
             * should allow leading zeroes. Need to remove the check therefore in totality
             * since we do not have a knob on this function signature to control whether or not to 
             * allow leading zeroes. (Safe to allow leading zeroes than not.)
             * /
            /*if(xDocument == null ||
                xPathList == null ||
                xPathList.Length == 0 ||
                elementName == null ||
                elementName.Length == 0 ||
                errorCode == null ||
                errorCode.Length == 0 ||
                errorObject == null)
            {
                return false;
            }

            XmlNode xRoot = xDocument.Document;

            //Store the xPaths in an array
            string[] arrayxPath = xPathList.Split(Constants.CHRCOMMA);

            foreach(string xPath in arrayxPath)
            {
                //Select all the nodes of the Element
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach(XmlNode xNode in xList)
                {
                    //If the value has leading zeroes, throw an error
                    if(xNode.InnerText != null && !CheckLeadingZero(xNode.InnerText.Trim())
                    {						
                        errorObject.AddError(errorCode,policyName,ruleName,elementName,xNode.InnerText);
                        isValid = false;
                    }
                }
            }*/
        }

        /// <method>
        /// 	CheckCurrencyAmount
        /// </method>
        /// <summary>
        /// 	This function performs the amount and currency validation depending the bool values set.
        /// </summary>
        /// <param name="currency">
        ///		Contains the currency value to be validated
        /// </param>
        /// <param name="amount">
        ///		Contains the Amount value to be validated
        /// </param>
        /// <param name="currencyAmountList">
        ///		Contains the currency list and corresponding decimal places.
        /// </param>
        /// <param name="allowLeadingZero">
        ///		if set to false this function will perform leadingzero validation.
        /// </param>
        /// <param name="isCurrencyValidationRequired">
        ///		if set to true this function will perform currency code validation.
        /// </param>
        /// <param name="isCurrencyAmountValidationRequired">
        ///		if set to true this function will perform Amounts decimal place validation
        ///		with corresponding currency.
        /// </param>
        /// <param name="errorCode">
        ///		errorCode
        /// </param>
        /// <param name="elementCurrencyName">
        ///		Currency element name
        /// </param>
        /// <param name="elementAmountName">
        ///		Amount element name
        /// </param>
        /// <param name="ruleName">
        ///		rule name
        /// </param>
        /// <param name="policyName">
        ///		policy name
        /// </param>
        /// <param name="errorObj">
        ///		errorObject
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool CheckCurrencyAmount(string currency,
            string amount,
            //string currencyAmountList,
            bool allowLeadingZero,
            bool isCurrencyValidationRequired,
            bool isCurrencyAmountValidationRequired,
            string errorCode,
            string elementCurrencyName,
            string elementAmountName,
            string ruleName,
            string policyName,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckCurrencyAmount" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (currency == null ||
                    currency.Length == 0 ||
                    //amount == null ||
                    //amount.Length == 0 ||
                    //currencyAmountList == null ||
                    currency.Length == 0)
                {
                    return false;
                }

                if (null == errorCode) throw new ArgumentNullException("ErrorCode");
                if (null == errorObj) throw new ArgumentNullException("errorObj");


                //Creates a hash table of currency codes and their corresponding
                //decimal places
                //	string[] data = currencyAmountList.Split(Constants.CHRPIPE);
                //	Hashtable currencyList = new Hashtable();
                //	BuildCurrencyList(data,ref currencyList);

                //Split the errorCodes passed
                string[] errorCodeList = errorCode.Split(Constants.CHRCOMMA);
                int errorCodeCount = errorCodeList.Length;


                //default (true) does not check leading zero
                if (!allowLeadingZero)
                {
                    //Checks for leading zeros if checkLeadingZero bool is set to false
                    if (!CheckLeadingZero(amount))
                    {
                        if (errorCodeCount == Constants.INT3)
                        {
                            errorObj.AddError(errorCodeList[1], policyName, ruleName, elementAmountName, amount);
                            return false;
                        }
                        else
                        {
                            errorObj.AddError(Constants.ERRORT40, policyName, ruleName, elementAmountName, amount);
                            return false;
                        }
                        //isValid = false;
                    }
                }

                if (!SqlConnector.hashCurrencyCodeList.ContainsKey(currency))
                {
                    isValid = false;
                    isCurrencyAmountValidationRequired = false;
                    errorObj.AddError(Constants.ERRORT52, policyName, ruleName, elementCurrencyName, currency);
                }

                if (isCurrencyAmountValidationRequired)
                {
                    //Extracts the decimal places value for a currency code from the
                    //hash table.
                    string decimalplaces = (String)SqlConnector.hashCurrencyCodeList[currency];

                    //Extracts the decimal digits after dot fron the amount present in string.
                    string[] amountData = amount.Split(Constants.CHRCOMMA);


                    //Checks for the validity of amount
                    if (amountData.Length >= 2)
                    {
                        if (Convert.ToInt32(decimalplaces, CultureInfo.InvariantCulture) != -1 &&
                            amountData.Length > 1 && amountData[1].Length > Convert.ToInt32(decimalplaces, CultureInfo.InvariantCulture))
                        {
                            isValid = false;
                        }
                    }
                    else
                    {
                        errorObj.AddError(errorCodeList[2], policyName, ruleName, elementAmountName, amount);
                        //isValid = false;
                        return false;
                    }
                }

                //Checks if the currency is present in the currency list provided
                if ((isCurrencyValidationRequired || isCurrencyAmountValidationRequired)
                    && !SqlConnector.hashCurrencyCodeList.Contains(currency))
                {
                    //errorObj.AddError(Constants.ERRORT52,policyName,ruleName,elementCurrencyName,currency);
                    isValid = false;
                    isCurrencyAmountValidationRequired = false;
                }

                if (isCurrencyAmountValidationRequired)
                {
                    //Extracts the decimal places value for a currency code from the
                    //hash table.
                    //string decimalplaces = (String)currencyList[currency];
                    string decimalplaces = (String)SqlConnector.hashCurrencyCodeList[currency];

                    //Extracts the decimal places after comma fron the amount present in tag.
                    string[] amountData = amount.Split(Constants.CHRCOMMA);

                    //Checks for the validity of amount
                    if (amountData.Length >= 2)
                    {
                        if (Convert.ToInt32(decimalplaces, CultureInfo.InvariantCulture) != -1 &&
                            amountData.Length > 1 && amountData[1].Length > Convert.ToInt32(decimalplaces, CultureInfo.InvariantCulture))
                        {
                            errorObj.AddError(errorCodeList[0], policyName, ruleName, elementAmountName, amount);
                            isValid = false;
                        }
                    }
                    else
                    {
                        errorObj.AddError(errorCodeList[2], policyName, ruleName, elementAmountName, amount);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;
        }

        /// <method>
        /// 	IsValidTransactionDetailsCurrencyAmount
        /// </method>
        /// <summary>
        ///		This function validates the Tag(s) TransactionDetails68B and
        ///		TransactionDetails68C currency and amount fields
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTransactionDetails">
        ///		Xpath of the tag which you are validating
        /// 	eg://SpecialConcessions_33S,//SpecialConcessions_33P
        ///	</param>
        /// <param name="currencyCodesList">
        /// 	Codelist which contains the list of currencies and thier respective decimal places
        /// </param>
        /// <param name="allowLeadingZero">
        /// 	checks for leading zeros if set false.
        /// </param>
        /// <param name="amountLength">
        /// 	specify the maximum length of amount.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool IsValidTransactionDetailsCurrencyAmount(
        //    Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathTransactionDetails,
        //    //string currencyCodesList,
        //    bool allowLeadingZero,
        //    int amountLength,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{

        //    if(xDocument == null ||
        //        xPathTransactionDetails == null ||
        //        xPathTransactionDetails.Length == 0 ||
        //        //				currencyCodesList == null ||
        //        //				currencyCodesList.Length == 0 ||
        //        amountLength <= 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    string numberContent = Constants.NUMBERSET;
        //    string currencyCode = string.Empty;
        //    string amount = string.Empty;
        //    bool isValid = true;
        //    string [] errorArray = errorCode.Split(Constants.CHRCOMMA);

        //    XmlNode xRoot = xDocument.Document;

        //    XmlNodeList xNodeList = xRoot.SelectNodes(xPathTransactionDetails);
        //    if(xNodeList != null & xNodeList.Count > 0)
        //    {
        //        foreach(XmlNode xNode in xNodeList)
        //        {
        //            int childCount = 0;
        //            string transactionDetails = null;

        //            if(xNode != null && xNode.HasChildNodes)
        //            {
        //                childCount = xNode.ChildNodes.Count;
        //                if(childCount == 1)
        //                {
        //                    transactionDetails = xNode.ChildNodes[0].InnerText;
        //                }

        //                if(childCount == 2)
        //                {
        //                    transactionDetails = xNode.ChildNodes[0].InnerText + xNode.ChildNodes[1].InnerText;
        //                }
        //            }

        //            //Validate for 68B
        //            if(xNode != null && xNode.Name.IndexOf("68B") > 0)
        //            {
        //                string part1Currency1, part1Amount1 = null;
        //                string part1Currency2, part1Amount2 = null;
        //                string currencyAmount = null;

        //                string []transactionDetailsArray = transactionDetails.Split('/');

        //                if(transactionDetailsArray.Length == 3)
        //                {
        //                    currencyAmount = transactionDetailsArray[1].Substring(1);

        //                    // Get currency and amount
        //                    currencyAmount = FetchFirstCurrenyAmountValues(currencyAmount,
        //                        out part1Currency1, out part1Amount1);

        //                    // Get currency and amount
        //                    currencyAmount = FetchFirstCurrenyAmountValues(currencyAmount,
        //                        out part1Currency2, out part1Amount2);

        //                    isValid = CheckCurrencyAmount(part1Currency2,part1Amount2,
        //                        allowLeadingZero, true, false,
        //                        errorArray[0],Constants.ELEMENTCURRENCYNAME,
        //                        Constants.ELEMENTCURRENCYNAME ,ruleName,policyName,
        //                        errorObject);

        //                    string part2 = transactionDetailsArray[2].ToString();
        //                    string part2Currency = part2.Substring(6,3);
        //                    string part2Amount = part2.Substring(9);

        //                    isValid = CheckCurrencyAmount(part2Currency,part2Amount,
        //                        allowLeadingZero, true, false,
        //                        errorArray[0],Constants.ELEMENTCURRENCYNAME,
        //                        Constants.ELEMENTCURRENCYNAME ,ruleName,policyName,
        //                        errorObject);

        //                }

        //                else
        //                {
        //                    errorObject.AddError(resManager.GetString("ERROR_INVALID_FIELD_FORMAT"),policyName,ruleName,
        //                        resManager.GetString("ERROR_ELEMENTNAME_NOTDEFINED"),resManager.GetString("ERROR_ELEMENTVALUE_NOTDEFINED"));
        //                    return false;
        //                }
        //            }



        //                //Validate for 68C
        //            else if(xNode != null && xNode.Name.IndexOf("68C") > 0)
        //            {
        //                string []transactionDetailsArray = transactionDetails.Split('/');

        //                if(transactionDetailsArray.Length == 3)
        //                {
        //                    string part2 = transactionDetailsArray[2].ToString();
        //                    string currencyAmount = null;
        //                    //If Date is present
        //                    if(numberContent.IndexOf(part2.Substring(1,1)) >= 0)
        //                    {
        //                        currencyAmount = part2.Substring(7);
        //                    }

        //                    else
        //                    {
        //                        currencyAmount = part2.Substring(1);
        //                    }

        //                    // Get the Stike Price Currency and Amount
        //                    string unit, quantityOfMetal = null;
        //                    string strikePriceCurrency,strikePrice = null;
        //                    string premiumPriceCurrency,premiumPrice = null;
        //                    string premiumPaymentCurrency,premiumPayment = null;

        //                    //This is not needed to be checked.
        //                    currencyAmount = FetchFirstCurrenyAmountValues(currencyAmount,
        //                        out unit, out quantityOfMetal);

        //                    currencyAmount = FetchFirstCurrenyAmountValues(currencyAmount,
        //                        out strikePriceCurrency, out strikePrice);

        //                    isValid = CheckCurrencyAmount(strikePriceCurrency,strikePrice,
        //                        allowLeadingZero, true, false,
        //                        errorArray[0],Constants.STRIKE_PRICE_CURRENCY,Constants.STRIKE_PRICE,
        //                        ruleName,policyName,errorObject);

        //                    // Get the Premium Price Currency and Amount
        //                    currencyAmount = FetchFirstCurrenyAmountValues(currencyAmount,
        //                        out premiumPriceCurrency, out premiumPrice);

        //                    isValid = CheckCurrencyAmount(premiumPriceCurrency,premiumPrice,
        //                        allowLeadingZero, true, false,
        //                        errorArray[0],Constants.PREMIUM_PRICE_CURRENCY,Constants.PREMIUM_PRICE,
        //                        ruleName,policyName,errorObject);

        //                    // Get the Premium Payment Currency and Amount

        //                    currencyAmount = FetchFirstCurrenyAmountValues(currencyAmount,
        //                        out premiumPaymentCurrency, out premiumPayment);

        //                    isValid = CheckCurrencyAmount(premiumPaymentCurrency,premiumPayment,
        //                        allowLeadingZero, true, true,
        //                        errorCode ,Constants.PREMIUM_PAYMENT_CURRENCY,Constants.PREMIUM_PAYMENT,
        //                        ruleName,policyName,errorObject);
        //                }

        //                else
        //                {
        //                    errorObject.AddError(resManager.GetString("ERROR_INVALID_FIELD_FORMAT"),policyName,ruleName,
        //                        resManager.GetString("ERROR_ELEMENTNAME_NOTDEFINED"),resManager.GetString("ERROR_ELEMENTVALUE_NOTDEFINED"));
        //                    return false;
        //                }
        //            }

        //            else
        //            {
        //                continue;
        //            }

        //        }
        //    }

        //    return isValid;
        //}


        /// <method>
        ///		SWIFTNetworkRuleT74
        /// </method>
        /// <summary>
        ///		The currency in subfield 7 and 10 of field 68B and subfields
        ///		7, 9 and 11 of field 68C must be the same.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTransactionDetails68B" type = "string">
        ///		Input reference of the Tag in which validation is to
        ///		performed.
        /// </param>
        /// <param name="xPathTag1Fields" type = "string" >
        ///		Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name ="xPathTransactionDetails68C" type = "string">
        ///		Input reference of the Tag in which validation is to
        ///		performed.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRuleT74(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTransactionDetails68B,
            string xPathTransactionDetails68C,
            //string currencyCodesList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRuleT74" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTransactionDetails68B == null ||
                    xPathTransactionDetails68B.Length == 0 ||
                    xPathTransactionDetails68C == null ||
                    xPathTransactionDetails68C.Length == 0 ||
                    //currencyCodesList == null ||
                    //currencyCodesList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                string numberContent = Constants.NUMBERSET + Constants.COMMA;
                char[] removeCharacters = numberContent.ToCharArray();
                string currencyCode = string.Empty;
                string amount = string.Empty;

                string[] errorArray = errorCode.Split(Constants.CHRCOMMA);

                XmlNode xRoot = xDocument.Document;

                //Validate 68B Field
                string[] xpathparentarray = xPathTransactionDetails68B.Split('/');

                XmlNodeList xNodeList68B = xRoot.SelectNodes("//" + xpathparentarray[2]);

                if (xNodeList68B != null & xNodeList68B.Count > 0)
                {
                    foreach (XmlNode xNode in xNodeList68B)
                    {
                        if (xNode != null)
                        {
                            string[] CurrenyAmount = new string[2];
                            CurrenyAmount[0] = xNode.ChildNodes[1].ChildNodes[0].InnerText;
                            CurrenyAmount[1] = xNode.ChildNodes[1].ChildNodes[1].ChildNodes[1].InnerText;

                            bool isValid1 = CheckCurrencyAmount(CurrenyAmount[0].Substring(0, 3), CurrenyAmount[0].Substring(3), false, true, true, "C03,T40,T43", xPathTransactionDetails68B, xPathTransactionDetails68B, "CheckValidCurrencyandAmount", "MT609_Validation_Policy", errorObject);

                            bool isValid2 = CheckCurrencyAmount(CurrenyAmount[1].Substring(0, 3), CurrenyAmount[1].Substring(3), false, true, true, "C03,T40,T43", xPathTransactionDetails68B, xPathTransactionDetails68B, "CheckValidCurrencyandAmount", "MT609_Validation_Policy", errorObject);

                            if ((CurrenyAmount[0].Substring(0, 3)).CompareTo(CurrenyAmount[1].Substring(0, 3)) != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;

                            }

                        }
                    }

                }

                //Validate 68C Field
                XmlNodeList xNodeList68C = xRoot.SelectNodes(xPathTransactionDetails68C);
                if (xNodeList68C != null & xNodeList68C.Count > 0)
                {
                    foreach (XmlNode xNode in xNodeList68C)
                    {
                        string transactionDetails = null;

                        if (xNode != null)
                        {
                            transactionDetails = xNode.InnerText;
                        }

                        string currencyAmount = transactionDetails;

                        string strikePriceCurrency, strikePrice = null;
                        string premiumPriceCurrency, premiumPrice = null;
                        string premiumPaymentCurrency, premiumPayment = null;

                        // Get the Stike Price Currency and Amount
                        currencyAmount = FetchFirstCurrenyAmountValues(currencyAmount,
                            out strikePriceCurrency, out strikePrice);

                        bool isValid1 = CheckCurrencyAmount(strikePriceCurrency, strikePrice, false, true, true, "C03,T40,T43", xPathTransactionDetails68C, xPathTransactionDetails68C, "CheckValidCurrencyandAmount", "MT609_Validation_Policy", errorObject);

                        // Get the Premium Price Currency and Amount
                        currencyAmount = FetchFirstCurrenyAmountValues(currencyAmount,
                            out premiumPriceCurrency, out premiumPrice);

                        bool isValid2 = CheckCurrencyAmount(premiumPriceCurrency, premiumPrice, false, true, true, "C03,T40,T43", xPathTransactionDetails68C, xPathTransactionDetails68C, "CheckValidCurrencyandAmount", "MT609_Validation_Policy", errorObject);

                        // Get the Premium Payment Currency and Amount
                        currencyAmount = FetchFirstCurrenyAmountValues(currencyAmount,
                            out premiumPaymentCurrency, out premiumPayment);

                        bool isValid3 = CheckCurrencyAmount(premiumPaymentCurrency, premiumPayment, false, true, true, "C03,T40,T43", xPathTransactionDetails68C, xPathTransactionDetails68C, "CheckValidCurrencyandAmount", "MT609_Validation_Policy", errorObject);


                        if (strikePriceCurrency.CompareTo(premiumPriceCurrency) != 0 ||
                            premiumPriceCurrency.CompareTo(premiumPaymentCurrency) != 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            isValid = false;

                        }

                    }
                }
            }


            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        /// 	FetchFirstCurrenyAmountValues
        /// </method>
        /// <summary>
        ///	This function retrieves the Currency and Amount
        ///	from the given input string
        /// </summary>
        /// <param name="currencyAmount">
        /// Input string containing currency and amount together
        /// </param>
        /// <param name="currency">
        /// Out param: Returns the currency
        /// </param>
        /// <param name="amount">
        /// Out param: Returns the amount
        /// </param>
        /// <returns>
        /// Returns the rest of the string value
        /// </returns>
        private static string FetchFirstCurrenyAmountValues(
            string currencyAmount,
            out string currency,
            out string amount)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function FetchFirstCurrenyAmountValues:");
            try
            {
                string numberContent = Constants.NUMBERSET + Constants.COMMA;
                char[] removeNumbers = numberContent.ToCharArray();
                char[] removeAlphabets = Constants.ALPHASET.ToCharArray();

                currency = currencyAmount.Substring(0,
                    Constants.INT3);
                currencyAmount = currencyAmount.Remove(0, Constants.INT3);
                int totalLength = currencyAmount.Length;

                string tempValue = currencyAmount.TrimStart(removeNumbers);

                int amountLength = totalLength - tempValue.Length;

                amount = currencyAmount.Substring(0, amountLength);

                return tempValue;
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        /// <method>
        /// 	CheckValidCurrencyAndPriceCode
        /// </method>
        /// <summary>
        /// 	This function Validates for the valid price code if present else does validation
        /// 	for the valid currency code.
        /// </summary>
        /// <param name="xDocument">
        /// 	A4SWIFTXmlDocument
        /// </param>
        /// <param name="xPathTagList">
        /// 	Xpath of the tag which you are validating
        /// </param>
        /// <param name="xPathCurrency">
        /// 	xPath of the currency field
        /// 	eg: ./Currency
        /// </param>
        /// <param name="xPathAmount">
        /// 	xPath of the currency field
        /// 	eg:./Amount
        /// </param>
        /// <param name="currencyList">
        /// 	Codelist which contains the list of currencies and thier respective decimal places
        /// </param>
        /// <param name="priceList">
        /// 	Codelist which contains price code
        /// </param>
        /// <param name="allowLeadingZero">
        /// 	checks for leading zeros if set false.
        /// </param>
        /// <param name="amountLength">
        /// 	The length of amount
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="elementName">
        /// 	Tag Name
        /// </param>
        /// <param name="ruleName">
        /// 	rule name
        /// </param>
        /// <param name="policyName">
        /// 	policy name
        /// </param>
        /// <param name="errorObj">
        /// 	Error Object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool CheckValidCurrencyAndPriceCode(Microsoft.RuleEngine.TypedXmlDocument xDocument,
                                                        string xPathTagList,
                                                        string xPathCurrency,
                                                        string xPathAmount,
                                                        bool allowLeadingZero,
                                                        int amountLength,
            //string currencyList,
                                                        string priceList,
                                                        string errorCode,
                                                        string elementName,
                                                        string ruleName,
                                                        string policyName,
                                                        ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidCurrencyAndPriceCode" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTagList == null ||
                    xPathTagList.Length == 0 ||
                    xPathCurrency == null ||
                    xPathCurrency.Length == 0 ||
                    xPathAmount == null ||
                    xPathAmount.Length == 0 ||
                    //				currencyList == null ||
                    //				currencyList.Length == 0 ||
                    priceList == null ||
                    priceList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObj == null)
                {
                    return false;
                }


                string currency = string.Empty;
                string amount = string.Empty;

                // Combine the price list and the currency list
                //string currencypricelist = currencyList + Constants.CHRCOMMA + priceList;
                //string currencypricelist = SqlConnector.hashCurrencyCodeList[currency].ToString() + Constants.CHRCOMMA + priceList;

                XmlNode xRoot = xDocument.Document;

                //Splitting XpathTagList
                string[] arrxPath = xPathTagList.Split(Constants.CHRCOMMA);

                foreach (string xPathTag in arrxPath)
                {
                    //Selects all the occurences of the tag in the message
                    XmlNodeList xTagList = xRoot.SelectNodes(xPathTag);

                    foreach (XmlNode xNode in xTagList)
                    {
                        if (xNode.SelectSingleNode(xPathAmount) != null
                            && xNode.SelectSingleNode(xPathAmount).InnerText != null
                            && xNode.SelectSingleNode(xPathAmount).InnerText.Length <= amountLength)
                        {
                            //Extracts the currency of the tag.
                            if (xNode.SelectSingleNode(xPathCurrency) != null)
                            {
                                currency = xNode.SelectSingleNode(xPathCurrency).InnerText;
                            }

                            amount = xNode.SelectSingleNode(xPathAmount).InnerText;

                            //default (true) does not check leading zero
                            if (!allowLeadingZero)
                            {
                                //Checks for leading zeros if checkLeadingZero bool is set to false
                                if (!CheckLeadingZero(amount))
                                {
                                    errorObj.AddError(errorCode, policyName, ruleName, xNode.Name, amount);
                                    isValid = false;
                                }
                            }

                            //	Check if the Currency is a valid ISO 4217 Currency code or a valid code like PCT, YLD or REN
                            //if((currencypricelist.IndexOf(currency) == -1))
                            if (SqlConnector.hashCurrencyCodeList.ContainsKey(currency) == false)
                            {
                                if (priceList.IndexOf(currency) == -1)
                                {
                                    errorObj.AddError(errorCode, policyName, ruleName, xNode.Name, currency);
                                    isValid = false;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }

        /// <method>
        /// 	CheckCurrencyPricePeriod
        /// </method>
        /// <summary>
        ///	This function retrieves the Currency and Price
        ///	from the given input string of currency price period
        /// </summary>
        /// <param name="xDocument">
        /// 	Xml Document
        /// </param>
        /// <param name="xPathInterestRate35U">
        /// 	xPath of InterestRate35U
        /// </param>
        /// <param name="xPathCurrency">
        /// 	xPath of currency Element
        /// </param>
        /// <param name="xPathPricePeriod">
        /// 	xPath of PricePeriod Element
        /// </param>
        /// <param name="currencyAmountList">
        /// 	CurrencyAmountList
        /// </param>
        /// <param name="allowLeadingZero">
        /// 	boolean value
        /// </param>
        /// <param name="errorCode">
        /// 	Error Code
        /// </param>
        /// <param name="elementName">
        /// 	Element Name
        /// </param>
        /// <param name="policyName">
        /// 	Policy Name
        /// </param>
        /// <param name="ruleName">
        /// 	Rule Name
        /// </param>
        /// <param name="messageType">
        /// 	The message number
        /// </param>
        /// <param name="errorObject">
        /// 	Error Object
        /// </param>
        /// <returns>
        /// 	boolean return value
        /// </returns>
        //        public static bool CheckCurrencyPricePeriod(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //            string xPathInterestRate35U,
        //            string xPathCurrency,
        //            string xPathPricePeriod,
        //            //string currencyAmountList,
        //            bool allowLeadingZero,
        //            string errorCode,
        //            string elementName,
        //            string policyName,
        //            string ruleName,
        //            string messageType,
        //            ErrorCollection errorObject)
        //        {

        //            bool isValid = true;

        //            if(xDocument == null ||
        //                xPathInterestRate35U == null ||
        //                xPathInterestRate35U.Length == 0 ||
        //                xPathCurrency == null ||
        //                xPathCurrency.Length == 0 ||
        //                xPathPricePeriod == null ||
        //                xPathPricePeriod.Length == 0 ||
        ////				currencyAmountList == null ||
        ////				currencyAmountList.Length == 0 ||
        //                errorCode == null ||
        //                errorCode.Length == 0 ||
        //                errorObject == null)
        //            {
        //                return false;
        //            }
        //            else
        //            {
        //                string currency = string.Empty;
        //                string price = string.Empty;
        //                string priceperiod = string.Empty;
        //                char[] CheckAlphabets = Constants.ALPHASET.ToCharArray();


        //                //Creates a hash table of currency codes and their corresponding
        //                //decimal places
        ////				string[] data = currencyAmountList.Split(Constants.CHRPIPE);
        ////				Hashtable currencyList = new Hashtable();
        ////				BuildCurrencyList(data,ref currencyList);


        //                XmlNode xRoot = xDocument.Document ;
        //                //Selects all the occurences of the tag in the message
        //                XmlNodeList xListInterestRate = xRoot.SelectNodes(xPathInterestRate35U);
        //                foreach (XmlNode xNode in xListInterestRate)
        //                {
        //                    if(xNode.InnerText != null && xNode.InnerText.Length != 0)
        //                    {
        //                        currency = xNode.SelectSingleNode(xPathCurrency).InnerText;
        //                        priceperiod = xNode.SelectSingleNode(xPathPricePeriod).InnerText;
        //                        price = priceperiod.TrimEnd(CheckAlphabets);

        //                        isValid = CheckCurrencyAmount(currency, price,  allowLeadingZero,
        //                            true,false,errorCode,Constants.ELEMENTCURRENCYNAME,
        //                            elementName,ruleName,policyName,errorObject);
        //                    }
        //                    else
        //                    {
        //                        errorObject.AddError(errorCode, policyName, ruleName,xNode.Name, Constants.NOCONTENT);
        //                        isValid = false;
        //                    }
        //                }
        //                return isValid;
        //            }

        //        }

        /// <method>
        ///		IsValidStatementLine61ForFundsCodeAbsent
        /// </method>
        /// <summary>
        ///		This method performs validation for fields with	multiple qualifiers to check for non-repetitive qualifiers.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="codeList" type = "string">
        ///		Reference containing the list of the DebitCreditCodes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "Microsoft.Solutions.FinancialServices.SWIFT.ErrorCollection">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidStatementLine61ForFundsCodeAbsent(
            Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidStatementLine61ForFundsCodeAbsent" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                string currencyCodeLastChar = null;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.InnerText != null)
                    {
                        IsValidLine1Attribute(xNode.ParentNode.Name, xNode.Name, xNode.InnerText,
                            currencyCodeLastChar, codeList, errorCode, policyName, ruleName, errorObject);
                    }
                    else
                    {
                        return false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return true;

        }

        /// <method>
        /// 	CheckValidSignCurrencyAmount
        /// </method>
        /// <summary>
        /// 	This function will return false if the validation of sign currency and
        /// 	amount is false depending on boolean values set.
        /// </summary>
        /// <param name="xDocument">
        /// 	XmlDocument
        /// </param>
        /// <param name="xPathTag">
        /// 	Comma separated list of xPath of tags
        /// 	eg.//Amount_E3_19A/SignCurrencyAmount
        /// </param>
        /// <param name="allowLeadingZero">
        /// 	determines whether leading zero check is allowed
        /// </param>
        /// <param name="isCurrencyValidationRequired">
        /// 	determines whether currency code check is required
        /// </param>
        /// <param name="isCurrencyAmountValidationRequired">
        /// 	determines whether Amount deciamal places check is required for a particular currency
        /// </param>
        /// <param name="currencyAmountList">
        /// 	currency amount code list
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="currencyName">
        /// 	Currency
        /// </param>
        /// <param name="amountName">
        /// 	amount
        /// </param>
        /// <param name="ruleName">
        /// 	rule name
        /// </param>
        /// <param name="policyName">
        /// 	policyname
        /// </param>
        /// <param name="errorObj">
        /// 	error object
        /// </param>
        /// <returns>
        /// 	bool
        ///	</returns>
        public static bool CheckValidSignCurrencyAmount(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            bool allowLeadingZero,
            bool isCurrencyValidationRequired,
            bool isCurrencyAmountValidationRequired,
            //string currencyAmountList,
            string errorCode,
            string currencyName,
            string amountName,
            string ruleName,
            string policyName,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidSignCurrencyAmount" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xPathTag == null ||
                    xPathTag.Length == 0)
                {
                    return false;
                }

                if (null == errorObj) throw new ArgumentNullException("ErrorObj");
                if (null == xDocument) throw new ArgumentNullException("xDocument");



                string signCurrencyAmount = String.Empty;
                string sign = String.Empty;
                string currency = String.Empty;
                string amount = String.Empty;

                XmlNode xRoot = xDocument.Document;

                string[] xPathTagList = xPathTag.Split(Constants.CHRCOMMA);

                foreach (string xPath in xPathTagList)
                {
                    XmlNodeList xNodeList = xRoot.SelectNodes(xPath);

                    foreach (XmlNode xNode in xNodeList)
                    {
                        sign = String.Empty;
                        //Extracts signCurrencyAmount value
                        signCurrencyAmount = xNode.InnerText;

                        //Checks the fourth character from starting of signCurrencyAmount
                        //if it is integer then sign is absent.
                        if (Constants.NUMBERSET.IndexOf(signCurrencyAmount.Substring(3, 1)) != -1)
                        {
                            currency = signCurrencyAmount.Substring(0, 3);

                            amount = signCurrencyAmount.Substring(3);
                        }
                        else
                        {
                            sign = signCurrencyAmount.Substring(0, 1);

                            currency = signCurrencyAmount.Substring(1, 3);

                            amount = signCurrencyAmount.Substring(4);
                        }

                        //Checks if neagtive sign is present.
                        if (sign.Equals(Constants.ALPHAN) || sign.Equals(Constants.NEGATIVESIGN))
                        {
                            //checks if amount is zero
                            if (Convert.ToDouble(amount.Replace(Constants.CHRCOMMA, charDecimalSeparator), CultureInfo.InvariantCulture) == 0.0)
                            {
                                errorObj.AddError(Constants.ERRORT14, policyName, ruleName, amountName, amount);
                                isValid = false;
                            }
                        }

                        //performs currency and amount validations
                        // Amount length should lie in the range of {1,15}
                        if (amount.Length >= 1 && amount.Length <= 15)
                        {
                            isValid = CheckCurrencyAmount(currency, amount, allowLeadingZero,
                                isCurrencyValidationRequired, isCurrencyAmountValidationRequired, errorCode,
                                currencyName, amountName, ruleName, policyName, errorObj);
                        }
                        else
                        {
                            errorObj.AddError(Constants.ERRORC03, policyName, ruleName, Constants.AMOUNT, amount);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }

        /// <method>
        /// 	CheckValidSignRate
        /// </method>
        /// <summary>
        /// 	This function CheckValidSignRate does the sign validation and leading zero validation for rate
        /// </summary>
        /// <param name="xDocument">
        /// 	XMLDocument
        /// </param>
        /// <param name="xPath">
        /// 	xPath of Tag
        /// 	eg;//Rate_91/SignRate
        /// </param>
        /// <param name="errorCode">
        /// 	errorCode
        /// </param>
        /// <param name="ruleName">
        /// 	RuleName
        /// </param>
        /// <param name="policyName">
        /// 	policyName
        /// </param>
        /// <param name="errorObj">
        /// 	Error object
        /// </param>
        /// <returns>
        /// 	bool
        ///</returns>
        public static bool CheckValidSignRate(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string ruleName,
            string policyName,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidSignRate" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xPath == null ||
                    xPath.Length == 0)
                {
                    return false;
                }

                if (null == errorObj) throw new ArgumentNullException("ErrorObj");
                if (null == xDocument) throw new ArgumentNullException("xDocument");


                string sign = String.Empty;
                string rate = String.Empty; ;

                XmlNode xRoot = xDocument.Document;

                string[] arrayxPath = xPath.Split(Constants.CHRCOMMA);

                foreach (string xPathTag in arrayxPath)
                {
                    XmlNodeList xTagList = xRoot.SelectNodes(xPathTag);

                    foreach (XmlNode xNode in xTagList)
                    {
                        sign = String.Empty;
                        if (xNode.InnerText != null)
                        {
                            if (Constants.NUMBERSET.IndexOf(xNode.InnerText.Substring(0, 1)) != -1)
                            {
                                rate = xNode.InnerText;
                            }
                            else
                            {
                                sign = xNode.InnerText.Substring(0, 1);

                                rate = xNode.InnerText.Substring(1);
                            }


                            //Checks if negative sign is present.
                            if (sign.Equals(Constants.ALPHAN) || sign.Equals(Constants.NEGATIVESIGN))
                            {
                                //checks if amount is zero
                                if (Convert.ToDouble(rate.Replace(Constants.CHRCOMMA, charDecimalSeparator), CultureInfo.InvariantCulture) == 0.0)
                                {
                                    errorObj.AddError(Constants.ERRORT14, policyName, ruleName, xNode.LocalName, rate);
                                    isValid = false;
                                }
                            }
                        }
                    }

                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        /// 	IsValidNarrativePattern
        /// </method>
        /// <summary>
        /// This function returns true if the tag follows the standerd pattern of narrative,
        /// i.e., /8c/additional information or //additional information
        /// The validations taken care here are as follows:
        ///		i.		Codes should always be at the beginning of the line between 2 slashes, e.g. /VARICOM/
        ///		ii.		Additional Information data cannot have slashes (/) in between.
        ///		iii.	If slash present then the additional information should starts in a new line
        ///		iv.		It also checks for the maximum number of lines allowed for an additional information,
        ///				 if "isAddInfoCountRequired" parameter is set to TRUE.
        /// </summary>
        /// <param name="xDocument">
        /// 	XmlDocument
        /// </param>
        /// <param name="xPathTag">
        /// 	xPath of the tag
        /// 	eg://SenderToreceiverInformation_72
        /// </param>
        /// <param name="codes">
        /// 	Comma seperated Codelist of codes
        /// </param>
        /// <param name="addInfoCount">
        /// 	It is the maximum number of addinfo lines after a code
        /// </param>
        /// <param name="isAddInfoCountRequired">
        /// Determines whether addinfo count validation is required or not
        /// </param>
        /// <param name="ruleName">
        /// 	RuleName
        /// </param>
        /// <param name="policyName">
        /// 	PolicyName
        /// </param>
        /// <param name="errObj">
        /// 	Errorobject
        /// </param>
        /// <returns>
        /// 	The function returns TRUE if succeeded else returns FALSE.
        /// </returns>
        public static bool IsValidNarrativePattern(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string codes,
            int addInfoCount,
            bool isAddInfoCountRequired,
            string ruleName,
            string policyName,
            ErrorCollection errObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidNarrativePattern" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xPathTag == null ||
                    xPathTag.Length == 0 ||
                    codes == null ||
                    codes.Length == 0)
                {
                    return false;
                }

                if (null == errObj) throw new ArgumentNullException("errObj");
                if (null == xDocument) throw new ArgumentNullException("xDocument");


                bool codePresent = false;
                int lineCount = -1;
                int codeStartPos = 0;
                int codeLength = 0;
                int codeEndPos = 0;
                bool validAddInfo = false;
                bool validLine1 = false;

                string lineText = string.Empty;

                XmlNode xRoot = xDocument.Document;

                string[] codeList = codes.Split(Constants.CHRCOMMA);

                XmlNodeList xNodeList = xRoot.SelectNodes(xPathTag);

                foreach (XmlNode xNode in xNodeList)
                {
                    //getting all the lines present inside the tag.
                    XmlNodeList xChildList = xNode.ChildNodes;

                    //Considering each line individually.
                    foreach (XmlNode xChildNode in xChildList)
                    {
                        codePresent = false;
                        validLine1 = false;
                        validAddInfo = false;

                        //Extracts the data of line
                        lineText = xChildNode.InnerText;

                        if (lineText != null)
                        {
                            //Checking with each code value
                            foreach (string codeValue in codeList)
                            {
                                //gets codeStartposition
                                codeStartPos = lineText.IndexOf(codeValue);

                                //gets code length
                                codeLength = codeValue.Length;

                                //gets code end position
                                codeEndPos = codeStartPos + codeLength;

                                //checking if code is present in the line
                                if (codeStartPos != -1)
                                {
                                    //Checking if already a code is existing or code is there in between the line
                                    if (codePresent == true || codeStartPos > 1)
                                    {
                                        errObj.AddError(resManager.GetString("ERROR_ERRORCODE_NOTDEFINED"), policyName,
                                            ruleName, xChildNode.LocalName, lineText);
                                        isValid = false;
                                    }
                                    else
                                    {
                                        //Checks if code starts with a slash AND
                                        //Ends with a slash
                                        //does not contain a slash in between th line
                                        if ((lineText.Substring(0, 1).Equals(Constants.SLASH)) &&
                                            (lineText.Substring(codeEndPos, 1).Equals(Constants.SLASH)) &&
                                            (lineText.Split(Constants.CHRSLASH).Length == 3))
                                        {
                                            codePresent = true;
                                            lineCount = 0;

                                            validLine1 = true;
                                        }
                                        else
                                        {
                                            errObj.AddError(resManager.GetString("ERROR_ERRORCODE_NOTDEFINED"),
                                                policyName, ruleName, xChildNode.LocalName, lineText);
                                            isValid = false;
                                        }
                                    }
                                }
                            }

                            //doing additional information check
                            if (lineText.IndexOf(Constants.DOUBLESLASH) == 0)
                            {
                                //doing addinfo count validation
                                if (isAddInfoCountRequired && lineCount != -1)
                                {
                                    lineCount++;

                                    if (lineCount > addInfoCount)
                                    {
                                        errObj.AddError(resManager.GetString("ERROR_ERRORCODE_NOTDEFINED"), policyName,
                                            ruleName, xChildNode.LocalName, lineText);
                                        isValid = false;
                                    }
                                }

                                //Checking for slashes between the line
                                if (lineText.Split(Constants.CHRSLASH).Length > 3)
                                {
                                    errObj.AddError(resManager.GetString("ERROR_ERRORCODE_NOTDEFINED"), policyName,
                                        ruleName, xChildNode.LocalName, lineText);
                                    isValid = false;
                                }
                                else
                                {
                                    validAddInfo = true;
                                }
                            }

                            if (!validAddInfo && !validLine1 && lineText.Substring(1).IndexOf(Constants.SLASH) != -1)
                            {
                                errObj.AddError(resManager.GetString("ERROR_ERRORCODE_NOTDEFINED"), policyName, ruleName,
                                    xChildNode.LocalName, lineText);
                                isValid = false;
                            }
                        }
                    }


                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		IsValidDetailsOfOrder
        /// </method>
        /// <summary>
        /// 	This function will do the validation for message MT820 for the tag
        /// 	DetailsOfOrder_68A
        /// </summary>
        /// <param name="xDocument">
        /// 	XmlDocument
        /// </param>
        /// <param name="xPathTag">
        /// 	xPath of the tag
        /// 	eg://RemittingAgent_52A
        /// </param>
        /// <param name="xPathNumberCurrencyDenomination">
        /// 	xpath of the "NumberCurrencyDenomination"
        /// 	eg:./NumberCurrencyAndDenomination
        /// </param>
        /// <param name="xPathAmount">
        /// 	xPath for "Amount: sub feild
        /// 	eg:./Amount
        /// </param>
        /// <param name="currencyFormatList">
        /// 	Currency code list(which contains both the currency and their decimal values)
        /// </param>
        /// <param name="currencyName">
        /// 	"Currency"
        /// </param>
        /// <param name="amountName">
        /// 	"Amount"
        /// </param>
        /// <param name="policyName">
        /// 	Policy Name
        /// </param>
        /// <param name="ruleName">
        /// 	Rule Name
        /// </param>
        /// <param name="errorCode">
        /// 	Error Code
        /// </param>
        /// <param name="errObj">
        /// 	Error object
        /// </param>
        /// <returns>
        /// 	bool(It returns true if it is a valid tag else it returns false)
        ///</returns>
        public static bool IsValidDetailsOfOrder(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathNumberCurrencyDenomination,
            string xPathAmount,
            //string currencyFormatList,
            string currencyName,
            string amountName,
            string policyName,
            string ruleName,
            string errorCode,
            ErrorCollection errObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidDetailsOfOrder" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathNumberCurrencyDenomination == null ||
                    xPathNumberCurrencyDenomination.Length == 0 ||
                    xPathAmount == null ||
                    xPathAmount.Length == 0)//||
                //				currencyFormatList == null ||
                //				currencyFormatList.Length == 0)
                {
                    return false;
                }

                if (null == errObj) throw new ArgumentNullException("errObj");


                string validationText = String.Empty;
                string amount = String.Empty;
                string currency = String.Empty;
                int count = 0;

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xNodeList = xRoot.SelectNodes(xPathTag);

                foreach (XmlNode xNode in xNodeList)
                {

                    if (xNode.SelectSingleNode(xPathNumberCurrencyDenomination) != null &&
                        xNode.SelectSingleNode(xPathNumberCurrencyDenomination).InnerText != null)
                    {
                        //Extract the text of NumberCurrencydenomination feild.
                        validationText = xNode.SelectSingleNode(xPathNumberCurrencyDenomination).InnerText;

                        for (count = 0; Constants.ALPHASET.IndexOf(validationText[count].ToString()) == -1; count++) ;

                        //Extracts Currency from the text
                        currency = validationText.Substring(count, 3);
                    }
                    if (xNode.SelectSingleNode(xPathAmount) != null &&
                        xNode.SelectSingleNode(xPathAmount).InnerText != null)
                    {
                        //extracts amount from the text.
                        amount = xNode.SelectSingleNode(xPathAmount).InnerText;
                    }

                    //Do the currency amount validation.
                    isValid = CheckCurrencyAmount_2011(currency, amount, true, true, true, errorCode,
                        currencyName, amountName, ruleName, policyName, errObj) && isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;

        }

        /// <method>
        /// 	IsValidTotalFaceValueOfCurrency
        /// </method>
        /// <summary>
        /// 	This function does the validation for the tag TotalFaceValueOfCurrency_19
        /// 	of meaasge MT820
        /// </summary>
        /// <param name="xDocument">
        /// 	XmlDocument
        /// </param>
        /// <param name="xPathTotalFaceValueOfCurrency">
        /// 	xPath if the tag
        /// 	eg ://TotalFaceValueOfCurrency_19
        /// </param>
        /// <param name="tagDetailsOfOrderName">
        /// 	Name of the previous tag,can be comma seperated list
        /// 	eg :DetailsOfOrder_68A,DetailsOfOrder_68A
        /// </param>
        /// <param name="currencyFormatList">
        /// 	Currency list(Which contains currency and their decimal places.
        /// </param>
        /// <param name="currencyName">
        /// 	"Currency"
        /// </param>
        /// <param name="amountName">
        /// 	"Amount"
        /// </param>
        /// <param name="errorCode">
        /// 	ErrorCode
        /// </param>
        /// <param name="policyName">
        /// 	PolicyName
        /// </param>
        /// <param name="ruleName">
        /// 	Rule Name
        /// </param>
        /// <param name="errObj">
        /// 	Error object
        /// </param>
        /// <returns>
        /// 	The function returns true if the tag is a valid tag.
        ///</returns>
        public static bool IsValidTotalFaceValueOfCurrency(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTotalFaceValueOfCurrency,
            string tagDetailsOfOrderName,
            //string currencyFormatList,
            string currencyName,
            string amountName,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidTotalFaceValueOfCurrency" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xPathTotalFaceValueOfCurrency == null ||
                    xPathTotalFaceValueOfCurrency.Length == 0 ||
                    //				currencyFormatList == null ||
                    //				currencyFormatList.Length == 0 ||
                    tagDetailsOfOrderName == null ||
                    tagDetailsOfOrderName.Length == 0)
                {
                    return false;
                }

                if (null == errObj) throw new ArgumentNullException("errObj");
                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNode xTempNode = null;


                string validationText = String.Empty;
                string currency = String.Empty;
                string amount = String.Empty;
                int count = 0;

                XmlNodeList xNodeList = xRoot.SelectNodes(xPathTotalFaceValueOfCurrency);

                foreach (XmlNode xNode in xNodeList)
                {
                    xTempNode = xNode;

                    while (xTempNode.PreviousSibling != null)
                    {
                        xTempNode = xTempNode.PreviousSibling;

                        if (tagDetailsOfOrderName.IndexOf(xTempNode.LocalName) != -1)
                        {

                            if (xTempNode != null &&
                                xTempNode.InnerText.Length != 0)
                            {
                                //Extract the text of NumberCurrencydenomination feild.
                                validationText = xTempNode.InnerText;

                                for (count = 0; Constants.ALPHASET.IndexOf(validationText[count].ToString()) == -1; count++) ;

                                //Extracts Currency from the text
                                if (validationText.Length >= count + 3)
                                {
                                    currency = validationText.Substring(count, 3);
                                }

                            }

                            if (xNode.InnerText != null)
                            {
                                amount = xNode.InnerText;
                            }

                            isValid = CheckCurrencyAmount(currency, amount, true, true, true,
                                errorCode, currencyName, amountName, ruleName, policyName, errObj) && isValid;

                            break;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	ReturnSequenceCount
        /// </method>
        /// <summary>
        /// 	This function returns the number of times a sequence has occured.
        /// </summary>
        /// <param name="xDocument">
        /// 	Xml Document
        /// </param>
        /// <param name="xPathSequence">
        /// 	XPath of Sequence
        /// </param>
        /// <returns>
        /// 	string (Sequence Count)
        /// </returns>
        public static string ReturnSequenceCount(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function ReturnSequenceCount:");
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0)
                {
                    return Constants.BLANK;
                }

                XmlNode xRoot = xDocument.Document;

                return xRoot.SelectNodes(xPathSequence).Count.ToString(CultureInfo.InvariantCulture);
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        /// <method>
        /// 	CheckForSameCurrency
        /// </method>
        /// <summary>
        /// 	This Function Checks whether all the occurences of
        /// 	specified tag(s) have the same currency.
        /// </summary>
        /// <param name="xDocument" type = "string" >
        /// 	Input containing the xml document to be validated
        /// </param>
        /// <param name="xPath" type = "string">
        /// 	Input Reference containing xPath(s) of Tag
        /// </param>
        /// <returns>
        /// 	Returns True when Currencies of all tags are same else false
        /// </returns>
        public static bool CheckForSameCurrency(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckForSameCurrency:");
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0)
                {
                    return false;
                }

                string currencyCode = string.Empty;

                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);

                int lengthxPath = xPathArray.Length;

                XmlNode xRoot = xDocument.Document;

                for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                {
                    XmlNodeList xList = xRoot.SelectNodes(xPathArray[nCount].ToString());
                    if (xList.Count != 0)
                    {
                        if (currencyCode.CompareTo(Constants.BLANK) == 0)
                        {
                            currencyCode = xList.Item(0).Value.ToString().Trim();
                        }

                        foreach (XmlNode xNode in xList)
                        {
                            if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                            {
                                if (xNode.InnerText.CompareTo(currencyCode) != 0)
                                {
                                    isValid = false;
                                }
                            }
                            else
                            {
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;
        }

        /// <method>
        /// 	SWIFTNetworkRule186
        /// </method>
        /// <summary>
        /// 	Fields 23E and 50D must, independently of each other, be present either in sequence A
        /// 	or in each occurrence of sequence B but not in both (Error code(s): D86).
        /// </summary>
        /// <param name="xDocument">
        /// 	TypedXmlDocument xDocument
        /// </param>
        /// <param name="xPathSequenceA">
        /// 	xPath of sequenceA
        /// </param>
        /// <param name="xPathSequenceB">
        /// 	xPath of sequenceB
        /// </param>
        /// <param name="xPathFieldA">
        /// 	Parameter values for the field in sequenceA
        /// </param>
        /// <param name="xPathFieldB">
        /// 	Parameter values for the field in sequenceB
        /// </param>
        /// <param name="errorCode">
        /// 	Parameter value for error code
        /// </param>
        /// <param name="policyName">
        /// 	Parameter value for policy name
        /// </param>
        /// <param name="ruleName">
        /// 	Parameter value for rulename
        /// </param>
        /// <param name="messageType">
        /// 	Parameter value for messageType
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	Parameter value for conditional rulename
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Parameter value for conditional rulenumber
        /// </param>
        /// <param name="errorObject">
        /// 	Parameter for error object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool SWIFTNetworkRule186(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceA,
            string xPathSequenceB,
            string xPathFieldA,
            string xPathFieldB,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule186" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPathSequenceA == null ||
                    xPathSequenceA.Length == 0 ||
                    xPathSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPathFieldA == null ||
                    xPathFieldA.Length == 0 ||
                    xPathFieldB == null ||
                    xPathFieldB.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    bool isValid = true;
                    bool isFoundInSequenceA = false;
                    bool isFoundInSequenceB = false;
                    int fieldCount = 0;

                    XmlNode xRoot = xDocument.Document;
                    // list of occurences in sequence A
                    XmlNode xNodeA = xRoot.SelectSingleNode(xPathSequenceA);

                    // list of occurences in sequence B
                    XmlNodeList xListB = xRoot.SelectNodes(xPathSequenceB);

                    // Checking for the field in sequence A
                    string[] xPathArrayA = xPathFieldA.Split(Constants.CHRCOMMA);
                    int lengthxPath = 0;
                    lengthxPath = xPathArrayA.Length;
                    XmlNode xNodeFieldA;
                    for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                    {
                        xNodeFieldA = xNodeA.SelectSingleNode(xPathArrayA[nCount]);
                        if (xNodeFieldA != null && xNodeFieldA.InnerText.Length != 0)
                        {
                            isFoundInSequenceA = true;
                            break;
                        }
                    }

                    string[] xPathArrayB = xPathFieldB.Split(Constants.CHRCOMMA);
                    lengthxPath = xPathArrayB.Length;
                    XmlNode xNodeFieldB;

                    foreach (XmlNode xNodeB in xListB)
                    {
                        if (xNodeB.InnerText != null &&
                            xNodeB.InnerText.Length != 0)
                        {
                            for (int nCountB = 0; nCountB <= lengthxPath - 1; nCountB++)
                            {
                                xNodeFieldB = xNodeB.SelectSingleNode(xPathArrayB[nCountB]);
                                if (xNodeFieldB != null && xNodeFieldB.InnerText.Length != 0)
                                {
                                    isFoundInSequenceB = true;
                                    fieldCount++;
                                }
                            }
                        }
                    }
                    if (isFoundInSequenceA && isFoundInSequenceB)
                    {
                        isValid = false;
                        errorObject.AddError(errorCode, policyName, ruleName, messageType,
                            conditionalRuleName, conditionalRuleNumber);
                    }
                    else if (!(isFoundInSequenceA) && !(isFoundInSequenceB))
                    {
                        isValid = false;
                        errorObject.AddError(errorCode, policyName, ruleName, messageType,
                            conditionalRuleName, conditionalRuleNumber);
                    }
                    else if (isFoundInSequenceB && (xListB.Count.CompareTo(fieldCount) != 0))
                    {
                        isValid = false;
                        errorObject.AddError(errorCode, policyName, ruleName, messageType,
                            conditionalRuleName, conditionalRuleNumber);
                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        /// <method>
        ///		SWIFTNetworkRule195
        /// </method>
        /// <summary>
        /// 	Code (subfield 1) of fields 23E, 22D and 22E may only be used according to the
        /// 	combinations specified in codelist23E,codelist22D and codelist22E (Error code(s): D95).
        /// </summary>
        /// <param name="xDocument">
        /// 	TypedXmlDocument xDocument
        /// </param>
        /// <param name="xPathSequence">
        /// 	xPath of Sequence (A or B)
        /// </param>
        /// <param name="xPathField23E">
        /// 	xPath of Tag 23E
        /// </param>
        /// <param name="xPathField22D">
        /// 	xPath of Tag 22D
        /// </param>
        /// <param name="xPathField22E">
        /// 	xPath of Tag 22E
        /// </param>
        /// <param name="codeList">
        /// 	codelist value of Code (subfield 1) of Tag 23E,22D,22E
        /// </param>
        /// <param name="errorCode">
        /// 	Parameter value for error code
        /// </param>
        /// <param name="policyName">
        /// 	Parameter value for policy name
        /// </param>
        /// <param name="ruleName">
        /// 	Parameter value for rulename
        /// </param>
        /// <param name="messageType">
        /// 	Parameter value for messageType
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	Parameter value for conditional rulename
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Parameter value for conditional rulenumber
        /// </param>
        /// <param name="errorObject">
        /// 	Parameter for error object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool SWIFTNetworkRule195(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathField23E,
            string xPathField22D,
            string xPathField22E,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule195" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {

                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathField23E == null ||
                    xPathField23E.Length == 0 ||
                    xPathField22D == null ||
                    xPathField22D.Length == 0 ||
                    xPathField22E == null ||
                    xPathField22E.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    bool isValid = true;
                    string value23E = null;
                    string value22D = null;
                    string value22E = null;
                    bool isMatch22E = false;

                    if (null == codeList) throw new ArgumentNullException("codeList");

                    XmlNode xRoot = xDocument.Document;
                    //list of occurences in sequence
                    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                    //Split the codelist according to the | (each line)character
                    string[] codeListEachLine = codeList.Split(Constants.CHRPIPE);

                    foreach (XmlNode xNodeSequence in xListSequence)
                    {
                        if (xNodeSequence.InnerText.Length != 0)
                        {
                            //Check for the 23E field in the sequence
                            XmlNode xNodeField23E = xNodeSequence.SelectSingleNode(xPathField23E);
                            if (xNodeField23E != null && xNodeField23E.InnerText != null)
                            {
                                value23E = xNodeField23E.InnerText;
                            }
                            else
                            {
                                value23E = string.Empty;
                            }
                            //Check for the 22D field in the sequence
                            XmlNode xNodeField22D = xNodeSequence.SelectSingleNode(xPathField22D);
                            if (xNodeField22D != null && xNodeField22D.InnerText != null)
                            {
                                value22D = xNodeField22D.InnerText;
                            }
                            else
                            {
                                value22D = string.Empty;
                            }
                            //Check for the 22E field in the sequence
                            XmlNode xNodeField22E = xNodeSequence.SelectSingleNode(xPathField22E);
                            if (xNodeField22E != null && xNodeField22E.InnerText != null)
                            {
                                value22E = xNodeField22E.InnerText;
                            }
                            else
                            {
                                value22E = string.Empty;
                            }

                            string[] codeListTag;
                            foreach (string codeListValue in codeListEachLine)
                            {
                                codeListTag = codeListValue.Split(Constants.CHRSLASH);

                                string code23E;
                                string[] codeList22D22E;
                                code23E = codeListTag[0].ToString();

                                if (code23E.CompareTo(value23E) == 0)
                                {
                                    //23E node value equals 23E set value
                                    codeList22D22E = codeListTag[1].Split(Constants.CHRASTERISK);

                                    //If node 22D and node 23E is empty then break the loop
                                    if ((value22D == string.Empty) && (value22E == string.Empty))
                                    {
                                        isMatch22E = true;
                                        break;
                                    }

                                    foreach (string codeEach22D22E in codeList22D22E)
                                    {
                                        string[] code22D22E;
                                        string[] codeList22EValues;
                                        code22D22E = codeEach22D22E.Split(Constants.CHRCARAT);
                                        codeList22EValues = code22D22E[1].Split(Constants.CHRCOMMA);

                                        if (value22D != string.Empty)
                                        {
                                            if (code22D22E[0].CompareTo(value22D) == 0)
                                            {
                                                if (value22E != string.Empty)
                                                {
                                                    foreach (string codeEach22EValue in codeList22EValues)
                                                    {
                                                        if (codeEach22EValue.CompareTo(value22E) == 0)
                                                        {
                                                            isMatch22E = true;
                                                            break;
                                                        }
                                                    }

                                                }
                                                else
                                                {
                                                    isMatch22E = true;
                                                }
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            foreach (string codeEach22EValue in codeList22EValues)
                                            {
                                                if (codeEach22EValue.CompareTo(value22E) == 0)
                                                {
                                                    isMatch22E = true;
                                                    break;
                                                }
                                            }
                                            break;
                                        }

                                    }
                                    if (isMatch22E == false)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                    }
                                    isMatch22E = false;
                                    break;
                                }

                            }
                        }
                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        /// <method>
        ///		SWIFTNetworkRuleT13
        /// </method>
        /// <summary>
        ///		This method performs validation for Fields 30,31P,82D,83D,33T,32M
        ///		The Fields are Mandatory.(Error code(s): T13)
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        ///		For e.g. SWIFT_NetworkRuleT13_Policy
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the Rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Input containing Conditional Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input containing Conditional Rule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool SWIFTNetworkRuleT13(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathTag,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,

        //    ErrorCollection errorObject)
        //{

        //    if(xDocument == null ||
        //        xPathTag == null ||
        //        xPathTag.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    bool isValid = true;
        //    string[] xPathArray = xPathTag.Split(Constants.CHRCOMMA);
        //    int lengthxPath = 0;
        //    lengthxPath = xPathArray.Length;

        //    XmlNode xRoot = xDocument.Document;

        //    //If the specified Fields are not present
        //    for(int count = 0;count <= lengthxPath - 1;count++)
        //    {
        //        XmlNode xNode = xRoot.SelectSingleNode(xPathArray[count].ToString());
        //        if(xNode == null)
        //        {
        //            errorObject.AddError(errorCode,policyName,ruleName,
        //                messageType,conditionalRuleName,conditionalRuleNumber);
        //        }
        //    }


        //    return isValid;
        //}

        /// <method>
        /// 	CheckMultilineCharacter
        /// </method>
        /// <summary>
        /// If multiline field is present then check second and subsequent line never start with the COLON(:) or HYPHEN(-) 
        /// as a first character.        
        /// </summary>
        /// <param name="xDocument"></param>
        /// XmlDocument
        /// <param name="xPathTag"></param>
        /// Xpath of mutiline element
        /// <param name="errorCode"></param>
        /// Error Code Not Define
        /// <param name="policyName"></param>
        /// Policy name to be passed
        /// <param name="ruleName"></param>
        /// Rule name to be passed
        /// <param name="errorObject"></param>
        /// error object
        /// <returns type = "bool">
        /// True if validation succeeds, False otherwise.
        /// </returns>


        public static bool CheckMultilineCharacter(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckMultilineCharacter" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                string[] xPathTagArray = xPathTag.Split(Constants.CHRCOMMA);
                int lengthxPathTag = xPathTagArray.Length;

                for (int nCount = 0; nCount < lengthxPathTag; nCount++)
                {
                    XmlNode xRoot = xDocument.Document;
                    XmlNodeList nodeList = xRoot.SelectNodes(xPathTagArray[nCount]);
                    if (nodeList.Count != 0)
                    {
                        foreach (XmlNode node in nodeList)
                        {
                            if (node.InnerText != null && node.InnerText.Length != 0)
                            {
                                int nodeCount = node.ChildNodes.Count;
                                if (nodeCount > 1)
                                {
                                    int startIndx = 0;
                                    if (string.Compare(node.ChildNodes[0].Name, Constants.QUALIFIER, true, CultureInfo.InvariantCulture) == 0)
                                    {
                                        startIndx = 1;
                                    }
                                    for (int cCount = 1; cCount < nodeCount; cCount++)
                                    {
                                        XmlNode xNode = node.ChildNodes[cCount];
                                        int lineCount = xNode.ChildNodes.Count;
                                        for (int count = startIndx; count < lineCount; count++)
                                        {
                                            XmlNode xNodeLine = xNode.ChildNodes[count];

                                            if ((xNodeLine.InnerText.StartsWith(Constants.COLON)) ||
                                                (xNodeLine.InnerText.StartsWith(Constants.HYPHEN)))
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, xNodeLine.ParentNode.Name, xNodeLine.InnerText);//Constants.BLANK);
                                                isValid = false;
                                            }
                                        }
                                    }

                                }
                                else if (nodeCount == 1 && (node.ChildNodes[0].Name == Constants.PARTYIDENTIFICATION2 || node.ChildNodes[0].Name == Constants.PARTYIDENTIFICATION3))
                                {
                                    XmlNode xNode = node.ChildNodes[0].ChildNodes[0];

                                    if (null != xNode)
                                    {
                                        int lineCount = xNode.ChildNodes.Count;
                                        for (int count = 1; count < lineCount; count++)
                                        {
                                            XmlNode xNodeLine = xNode.ChildNodes[count];

                                            if ((xNodeLine.InnerText.StartsWith(Constants.COLON)) ||
                                                (xNodeLine.InnerText.StartsWith(Constants.HYPHEN)))
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, xNodeLine.ParentNode.Name, xNodeLine.InnerText);//Constants.BLANK);
                                                isValid = false;
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    XmlNode xNode = node.ChildNodes[0];
                                    int lineCount = xNode.ChildNodes.Count;
                                    for (int count = 1; count < lineCount; count++)
                                    {
                                        XmlNode xNodeLine = xNode.ChildNodes[count];

                                        if ((xNodeLine.InnerText.StartsWith(Constants.COLON)) ||
                                            (xNodeLine.InnerText.StartsWith(Constants.HYPHEN)))
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, xNodeLine.ParentNode.Name, xNodeLine.InnerText);//Constants.BLANK);
                                            isValid = false;
                                        }
                                    }

                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;
        }


        /// <method>
        /// 	CheckField90D
        /// </method>
        /// <summary>
        /// This function Validates the no of decimal places after the comma for a specific
        /// currency code and it also checks for the leading zeros depending on the bool value
        /// set.
        /// </summary>
        /// <param name="xDocument"></param>
        /// XmlDocument
        /// <param name="xPathTag"></param>
        /// Input reference of the element to be validated.
        /// <param name="allowLeadingZero">
        /// checks for leading zeros if set false.
        /// </param>
        /// <param name="errorCode"></param>
        /// Input containing the error code.
        /// <param name="elementName">
        /// Tag Name
        /// </param>
        /// <param name="ruleName"></param>
        /// Rule name to be passed
        /// <param name="policyName"></param>
        /// Policy name to be passed
        /// <param name="errorObject"></param>
        /// error object
        /// <returns type = "bool">
        /// True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckField90D(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            bool allowLeadingZero,
            string errorCode,
            string elementName,
            string ruleName,
            string policyName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckField90D" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                string[] errorCodeList = errorCode.Split(Constants.CHRCOMMA);
                XmlNode xRoot = xDocument.Document;
                XmlNodeList nodeList = xRoot.SelectNodes(xPathTag);
                if (nodeList.Count != 0)
                {
                    foreach (XmlNode node in nodeList)
                    {
                        if (node.InnerText != null && node.InnerText.Length != 0)
                        {
                            for (int count = 0; count < 6; count++)
                            {
                                if (Constants.ALPHASET.IndexOf(node.InnerText.Substring(count, 1)) != -1)
                                {
                                    int length = node.InnerText.Length;
                                    string currency = node.InnerText.Substring(count, 3);
                                    string amount = node.InnerText.Substring(count + 3, length - (count + 3));
                                    string[] amountData = amount.Split(Constants.CHRCOMMA);
                                    if (amountData.Length == 2)
                                    {
                                        isValid = CheckCurrencyAmount(currency, amount, allowLeadingZero, true, true, errorCode, Constants.ELEMENTCURRENCYNAME, elementName, ruleName, policyName, errorObject);
                                        break;
                                    }
                                    else
                                    {
                                        errorObject.AddError(errorCodeList[1], policyName, ruleName, elementName, amount);
                                        isValid = false;

                                    }
                                }

                            }
                        }
                    }
                }
            }

            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }







        /// <method>
        /// 	CheckRuleT56
        /// </method>
        /// <summary>
        /// First Line must Start with number 1.
        /// Number must appear in numerical order.
        /// Number 2 must not be used without number 3.
        /// Number 4 must not be used without number 5 and vice versa.
        /// Numbers 3, 5, 6 and 7 must be followed by a valid ISO country  code.
        /// Numbers 3, 4, 5, 6, 7 and 8 must not be repeated.
        /// Number 8 may only be used if it is preceded by at least one of the following
        ///     1. Line 1 has format 4!a/2!a/27x.
        ///     2. Line with number 6 is present.
        ///     3. Line with number 7 is present.
        /// </summary>
        /// <param name="xDocument"></param>
        /// XmlDocument
        /// <param name="xPathTag"></param>
        /// Input reference of the element to be validated.
        /// <param name=codeValues></param>
        /// Input containing list of codes to be validated.
        /// <param name="errorCode"></param>
        /// Input containing the error code.
        /// <param name="policyName"></param>
        /// Policy name to be passed
        /// <param name="ruleName"></param>
        /// Rule name to be passed
        /// <param name="errorObject"></param>
        /// error object
        /// <returns type = "bool">
        /// True if validation succeeds, False otherwise.
        /// </returns>

        public static bool CheckRuleT56(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string codeValues,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckRuleT56" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    codeValues == null ||
                    codeValues.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                XmlNode xRoot = xDocument.Document;
                XmlNodeList nodeList = xRoot.SelectNodes(xPathTag);
                bool is59F = xPathTag.Contains("59F");
                bool is50F = xPathTag.Contains("50F");
                if (nodeList.Count != 0)
                {
                    foreach (XmlNode node in nodeList)
                    {
                        if (node.InnerText != null && node.InnerText.Length != 0)
                        {
                            int nodeCount = node.ChildNodes.Count;
                            bool isValidLine3_59F = false;
                            bool isValidLine3_50F = false;
                            //For 59F, Account field is option. If Account is not present nodeCount will be greater than zero 
                            //Otherwise nodeCount will be greater than One. 
                            if ((nodeCount > 1 && string.Compare(xPathTag, "//BeneficiaryCustomer_59F_2", true, CultureInfo.InvariantCulture) != 0)
                                || (nodeCount > 0 && string.Compare(xPathTag, "//BeneficiaryCustomer_59F_2", true, CultureInfo.InvariantCulture) == 0)
                                || (nodeCount > 0 && string.Compare(xPathTag, "//Beneficiary_B_59F/OptionalAccount", true, CultureInfo.InvariantCulture) == 0)
                                || (nodeCount > 0 && string.Compare(xPathTag, "//BeneficiaryCustomer_B_59F/OptionalAccount", true, CultureInfo.InvariantCulture) == 0)
                                || (nodeCount > 0 && string.Compare(xPathTag, "//BeneficiaryCustomer_59F/OptionalAccount", true, CultureInfo.InvariantCulture) == 0))
                            {
                                int cCount = 1;
                                if ((string.Compare(xPathTag, "//BeneficiaryCustomer_59F_2", true, CultureInfo.InvariantCulture) == 0)
                                    || (string.Compare(xPathTag, "//Beneficiary_B_59F/OptionalAccount", true, CultureInfo.InvariantCulture) == 0)
                                    || (string.Compare(xPathTag, "//BeneficiaryCustomer_B_59F/OptionalAccount", true, CultureInfo.InvariantCulture) == 0)
                                    || (string.Compare(xPathTag, "//BeneficiaryCustomer_59F/OptionalAccount", true, CultureInfo.InvariantCulture) == 0))
                                {
                                    cCount = 0;
                                }
                                for (; cCount < nodeCount; cCount++)
                                {
                                    int preValue = 0;
                                    XmlNode xNode = node.ChildNodes[cCount];
                                    preValue = Convert.ToInt32(xNode.ChildNodes[0].FirstChild.InnerText);
                                    //if (preValue != 1)
                                    if (Constants.NUMBER1T56.IndexOf(xNode.ChildNodes[0].FirstChild.InnerText) == -1)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, xNode.ParentNode.Name, xNode.InnerText);//Constants.BLANK);
                                        isValid = false;
                                    }
                                    int lineCount = xNode.ChildNodes.Count;
                                    if (lineCount > 1)
                                    {
                                        bool isCountryFound = false;
                                        for (int count = 1; count < lineCount; count++)
                                        {
                                            int currValue = 0;
                                            XmlNode xNodeLine = xNode.ChildNodes[count];
                                            currValue = Int32.Parse(xNodeLine.FirstChild.InnerText);

                                            if (currValue != preValue)
                                            {
                                                isCountryFound = false;
                                            }

                                            //Numbers 3, 5, 6 and 7 must be followed by a valid ISO country code.
                                            //For 59F, Only the first occurance of 3 must be followed by a valid ISO country code.
                                            //For 50F, Only the first occurance of 3 must be followed by a valid ISO country code.
                                            if (Constants.NUMBERCHECKT56.IndexOf(xNodeLine.FirstChild.InnerText) != -1 && (!isValidLine3_59F || !isValidLine3_50F)
                                                && isCountryFound == false)
                                            {
                                                String country;
                                                if (xNodeLine.InnerText.Length == 3)
                                                    country = xNodeLine.InnerText.Substring(1, 2);

                                                else if (xNodeLine.InnerText.IndexOf("/") > 1)
                                                {
                                                    country = xNodeLine.InnerText.Substring(1, xNodeLine.InnerText.IndexOf("/") - 1);
                                                    isCountryFound = true;
                                                }
                                                else
                                                {
                                                    country = xNodeLine.InnerText.Substring(1);
                                                }

                                                if (!SqlConnector.hashCountryCodeList.ContainsValue(country))
                                                {
                                                    errorObject.AddError("T73", policyName, ruleName,
                                                        "CountryCode", country);
                                                    isValid = false;
                                                }
                                                if (is59F)
                                                {
                                                    isValidLine3_59F = true;
                                                }
                                                if (is50F)
                                                {
                                                    isValidLine3_50F = true;
                                                }
                                            }

                                            //For 59F, Line start with Numerical Letter (1-3). For remaining fields, Line start with Numerical Letter (1-9).
                                            if ((is59F && Constants.NUMBERSETT56_59F.IndexOf(xNodeLine.FirstChild.InnerText) == -1) || (!is59F && Constants.NUMBERSETT56.IndexOf(xNodeLine.FirstChild.InnerText) == -1))
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, xNode.ParentNode.Name, xNode.InnerText);//Constants.BLANK);
                                                isValid = false;

                                            }

                                            //Number must appear in numerical order.
                                            if (currValue < preValue && currValue != preValue)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, xNode.ParentNode.Name, "Number must appear in Numerical Order."/*xNode.InnerText*/);//Constants.BLANK);
                                                isValid = false;
                                            }

                                            //Number 2 must not be used without number 3.
                                            if (is59F)
                                            {
                                                if (((preValue == 2 && currValue != 3) && (preValue == 2 && currValue != 2)) || (currValue == 2 && xNodeLine.NextSibling == null))
                                                {
                                                    errorObject.AddError(errorCode, policyName, ruleName, xNode.ParentNode.Name, "Number 2 must not be used without number 3");//Constants.BLANK);
                                                    isValid = false;
                                                }
                                            }
                                            //Number 4 must not be used without number 5 and vice versa.
                                            if (!is59F)
                                            {
                                                if (((preValue == 2 && currValue != 3) && (preValue == 2 && currValue != 2)) || (preValue == 4 && currValue != 5) || (currValue == 5 && preValue != 4) || (currValue == 2 && xNodeLine.NextSibling == null) || (currValue == 4 && xNodeLine.NextSibling == null))
                                                {
                                                    errorObject.AddError(errorCode, policyName, ruleName, xNode.ParentNode.Name, "Number 2 must not be used without number 3 and Number 4 must not be used without number 5");//Constants.BLANK);
                                                    isValid = false;
                                                }
                                            }

                                            //Number 8 may only be used if it is preceded by at least one of the following
                                            //  1. Line 1 has format 4!a/2!a/27x.
                                            //  2. Line with number 6 is present.
                                            //  3. Line with number 7 is present.
                                            if (currValue == 8)
                                            {
                                                if (preValue == 6 || preValue == 7 || CheckValidCodeT56(xDocument, node, codeValues))
                                                {
                                                    //break;
                                                }
                                                else
                                                {
                                                    errorObject.AddError(errorCode, policyName, ruleName, xNode.ParentNode.Name, "Line with Number 6 or Number 7 is not present or Line 1 has not the format 4!a/2!a/27x");//Constants.BLANK);
                                                    isValid = false;
                                                }


                                            }
                                            //Except for 59F field, Numbers 3, 4, 5, 6, 7 and 8 must not be repeated.
                                            if (!is59F && !is50F && currValue == preValue && Constants.NUMBERCHECK8T56.IndexOf(xNodeLine.FirstChild.InnerText) != -1)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, xNode.ParentNode.Name, "Numbers 3,4,5,6,7 and 8 must not be repeated");//Constants.BLANK);
                                                isValid = false;
                                            }
                                            //For 50F field, Number 4, 5, 6, 7 and 8 must not be repeated.
                                            if (is50F && currValue == preValue && Constants.NUMBERCHECK50FT56.IndexOf(xNodeLine.FirstChild.InnerText) != -1)
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, xNode.ParentNode.Name, "Numbers 4,5,6,7 and 8 must not be repeated");//Constants.BLANK);
                                                isValid = false;
                                            }

                                            preValue = currValue;

                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }


        /// <method>
        /// 	CheckValidCodeT56
        /// </method>
        /// <summary>
        /// Method will validate Line has format 4!a/2!a/27x.
        /// </summary>
        /// <param name="xDocument"></param>
        /// XmlDocument
        /// <param name="nodePath"></param>
        /// Input reference of the element to be validated.
        /// <param name=codeValues></param>
        /// Input containing list of codes to be validated.
        /// <returns type = "bool">
        /// True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckValidCodeT56(Microsoft.RuleEngine.TypedXmlDocument xDocument,
           XmlNode nodePath,
           string codeValues)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidCodeT56:");
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    nodePath == null ||
                    codeValues == null ||
                    codeValues.Length == 0)
                {
                    return false;
                }


                XmlNode xNode = nodePath.ChildNodes[0];


                if ((xNode.ChildNodes.Count) > 1)
                {

                    string code = xNode.ChildNodes[0].FirstChild.InnerText;
                    if ((codeValues.IndexOf(code) == -1) || (code == Constants.BLANK))
                    {
                        isValid = false;
                    }
                    string country = xNode.ChildNodes[0].NextSibling.InnerText;
                    if (!SqlConnector.hashCountryCodeList.ContainsValue(country))
                    {
                        isValid = false;

                    }
                }
                else
                {
                    isValid = false;
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }


        /// <method>
        /// 	CheckRuleT50
        /// </method>
        /// <summary>
        /// Number 4 must be followed by a valid date in the format YYYYMMDD
        /// </summary>
        /// <param name="xDocument"></param>
        /// XmlDocument
        /// <param name="xPathTag"></param>
        /// Input reference of the element to be validated.
        /// <param name="errorCode"></param>
        /// Input containing the error code.
        /// <param name="policyName"></param>
        /// Policy name to be passed
        /// <param name="ruleName"></param>
        /// Rule name to be passed
        /// <param name="errorObject"></param>
        /// error object
        /// <returns type = "bool">
        /// True if validation succeeds, False otherwise.
        /// </returns>

        public static bool CheckRuleT50(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckRuleT50" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                XmlNode xRoot = xDocument.Document;
                XmlNodeList nodeList = xRoot.SelectNodes(xPathTag);
                if (nodeList.Count != 0)
                {
                    foreach (XmlNode node in nodeList)
                    {
                        if (node.InnerText != null && node.InnerText.Length != 0)
                        {
                            int nodeCount = node.ChildNodes.Count;
                            if (nodeCount > 1)
                            {
                                for (int cCount = 1; cCount < nodeCount; cCount++)
                                {
                                    XmlNode xNode = node.ChildNodes[cCount];
                                    int lineCount = xNode.ChildNodes.Count;
                                    if (lineCount > 1)
                                    {
                                        for (int count = 1; count < lineCount; count++)
                                        {
                                            int currValue = 0;
                                            XmlNode xNodeLine = xNode.ChildNodes[count];
                                            currValue = Int32.Parse(xNodeLine.FirstChild.InnerText);
                                            if (currValue == 4)
                                            {
                                                if (xNodeLine.InnerText.Length > 8)
                                                {
                                                    string date = xNodeLine.InnerText.Substring(1, 8);
                                                    if (!IsValidDateYYYYMMDD(date))
                                                    {
                                                        errorObject.AddError(errorCode, policyName, ruleName, xNode.ParentNode.Name, xNodeLine.InnerText);
                                                        isValid = false;

                                                    }
                                                }
                                                else
                                                {
                                                    errorObject.AddError(errorCode, policyName, ruleName, xNode.ParentNode.Name, xNodeLine.InnerText);
                                                    isValid = false;
                                                }

                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }











        /// <method>
        ///		SWIFTNetworkRuleT13
        /// </method>
        /// <summary>
        ///		This method performs validation for SequenceB
        ///		The SequenceB Should not Repeat.(Error code(s): T13)
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        ///		For e.g. SWIFT_NetworkRuleT13_Policy
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the Rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        /// </param>
        /// <param name="conditionalRuleName">
        ///		Input containing Conditional Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input containing Conditional Rule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence to be validated.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool SWIFTNetworkRuleT13(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject,
        //    string xPathSequence)
        //{
        //    if(xDocument == null ||
        //        xPathSequence == null ||
        //        xPathSequence.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    bool isValid = true;

        //    XmlNode xRoot = xDocument.Document;
        //    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

        //    int countSequence = xListSequence.Count;
        //    //If xPathSequence Count occurs more than once then raise an error
        //    if (xListSequence.Count > 1)
        //    {
        //        errorObject.AddError(errorCode,policyName,ruleName,messageType,
        //            conditionalRuleName,conditionalRuleNumber);
        //    }

        //    return isValid;
        //}

        /// <method>
        /// 	ConvertToString
        /// </method>
        /// <summary>
        /// 	Converts a given value to a string.
        /// </summary>
        /// <param name="objectValue">
        /// 	Input reference of the value to be converted to string
        /// </param>
        /// <returns>
        /// 	string
        /// </returns>
        //public static string ConvertToString(object objectValue)
        //{
        //    if (null == objectValue) throw new ArgumentNullException("objectValue");
        //    string returnValue = objectValue.ToString();
        //    return returnValue;
        //}

        /// <method>
        /// 	CheckInterestPaymentSchedule
        /// </method>
        /// <summary>
        /// 	Day must be present when Frequency contains the code MONT and Timing in Period contains
        /// 	the code word OTHR. It is not allowed in all other cases (Error code(s): T75).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag">
        /// 	xPath of tha tag
        /// </param>
        /// <param name="xPathInterestPaymentScheduleFrequency">
        /// 	xPath of InterestPaymentSchedule frequency
        /// </param>
        /// <param name="xPathInterestPaymentScheduleTime">
        /// 	xPath of InterestPaymentSchedule time
        /// </param>
        /// <param name="xPathInterestPaymentScheduleDay">
        /// 	xPath of InterestPaymentSchedule day
        /// </param>
        /// <param name="codeList1">
        /// 	codelist value for frequency
        /// </param>
        /// <param name="codeList2">
        /// 	codelist value for time
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="elementName">
        /// 	element name
        /// </param>
        /// <param name="policyName">
        /// 	policy name
        /// </param>
        /// <param name="ruleName">
        /// 	rule name
        /// </param>
        /// <param name="messageType">
        /// 	message type
        /// </param>
        /// <param name="errorObject">
        /// 	error object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool CheckInterestPaymentSchedule(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathInterestPaymentScheduleFrequency,
            string xPathInterestPaymentScheduleTime,
            string xPathInterestPaymentScheduleDay,
            string codeList1,
            string codeList2,
            string errorCode,
            string elementName,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckInterestPaymentSchedule" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathInterestPaymentScheduleFrequency == null ||
                    xPathInterestPaymentScheduleFrequency.Length == 0 ||
                    xPathInterestPaymentScheduleTime == null ||
                    xPathInterestPaymentScheduleTime.Length == 0 ||
                    xPathInterestPaymentScheduleDay == null ||
                    xPathInterestPaymentScheduleDay.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    bool isValid = true;

                    XmlNode xRoot = xDocument.Document;
                    XmlNodeList xListTag = xRoot.SelectNodes(xPathTag);

                    foreach (XmlNode xNodeTag in xListTag)
                    {
                        if (xNodeTag.InnerText.Length != 0)
                        {
                            XmlNode xNodeFrequency = xNodeTag.SelectSingleNode(xPathInterestPaymentScheduleFrequency);
                            XmlNode xNodeTime = xNodeTag.SelectSingleNode(xPathInterestPaymentScheduleTime);
                            XmlNode xNodeDay = xNodeTag.SelectSingleNode(xPathInterestPaymentScheduleDay);
                            if (xNodeFrequency.InnerText != null &&
                                xNodeFrequency.InnerText.Length != 0 &&
                                xNodeTime.InnerText != null &&
                                xNodeTime.InnerText.Length != 0)
                            {
                                if (xNodeFrequency.InnerText.CompareTo(codeList1) != 0
                                    && xNodeTime.InnerText.CompareTo(codeList2) != 0
                                    && xNodeDay != null
                                    && xNodeDay.InnerText != null)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                        xNodeTag.Name, xNodeFrequency.Name, xNodeFrequency.InnerText);
                                    isValid = false;
                                }
                                else if (xNodeFrequency.InnerText.CompareTo(codeList1) == 0 &&
                                    xNodeTime.InnerText.CompareTo(codeList2) == 0 && xNodeDay == null)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                        xNodeTag.Name, xNodeFrequency.Name, xNodeFrequency.InnerText);
                                    isValid = false;
                                }
                            }
                        }
                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        ///<method>
        ///	CheckForNarrative
        ///</method>
        /// <summary>
        /// 	Narrative may only be present when the code codelist is present in Code.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathTag">
        /// 	xPath of the tag
        /// </param>
        /// <param name="xPathCode">
        /// 	xPath of code
        /// </param>
        /// <param name="xPathNarrative">
        /// 	xPath of Narrative
        /// </param>
        /// <param name="codeList">
        /// 	codelist containing 'OTHR'
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="elementName">
        /// 	name of the element
        /// </param>
        /// <param name="policyName">
        /// 	policy name
        /// </param>
        /// <param name="ruleName">
        /// 	rule name
        /// </param>
        /// <param name="messageType">
        /// 	message number
        /// </param>
        /// <param name="errorObject">
        /// 	error object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        //public static bool CheckForNarrative(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathTag,
        //    string xPathCode,
        //    string xPathNarrative,
        //    string codeList,
        //    string errorCode,
        //    string elementName,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPathTag == null ||
        //        xPathTag.Length == 0 ||
        //        xPathCode == null ||
        //        xPathCode.Length == 0 ||
        //        xPathNarrative == null ||
        //        xPathNarrative.Length == 0 ||
        //        codeList == null ||
        //        codeList.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    else
        //    {
        //        bool isValid = true;

        //        XmlNode xRoot = xDocument.Document;
        //        XmlNodeList xListTag = xRoot.SelectNodes(xPathTag);

        //        foreach(XmlNode xNodeTag in xListTag)
        //        {
        //            if(xNodeTag.InnerText.Length != 0)
        //            {
        //                XmlNode xNodeCode = xNodeTag.SelectSingleNode(xPathCode);
        //                XmlNode xNodeNarrative = xNodeTag.SelectSingleNode(xPathNarrative);
        //                if(xNodeCode.InnerText != null && xNodeCode.InnerText.Length != 0)
        //                {
        //                    if (xNodeCode.InnerText.CompareTo(codeList) != 0 &&
        //                        xNodeNarrative != null && xNodeNarrative.InnerText != null)
        //                    {
        //                        errorObject.AddError(errorCode,policyName,ruleName,messageType,
        //                            xNodeTag.Name,xNodeCode.Name,xNodeCode.InnerText);
        //                        isValid = false;
        //                    }
        //                }
        //             }

        //        }
        //        return isValid;
        //    }
        //}

        /// <method>
        ///		IsValidCodeFormat
        /// </method>
        /// <summary>
        ///		This method performs validation for the codes which may be used with a particular format.
        ///		eg: /AABA/9n,/ACLAMT/3!a15d. This function is specifically written for ISITC type messages
        ///		such as MT523 ISITC
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="valueCodesFormat" type = "string">
        ///		Input containing the Code value with the Valid Format.
        /// </param>
        /// <param name ="currencyAmountList" type = "string">
        ///		Input containing the number of digits after the decimal Comma for a particular Currency Code .
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //        public static bool IsValidCodeFormat(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //            string xPathTag,
        //            string valueCodesFormat,
        //            //string currencyAmountList,
        //            string errorCode,
        //            string policyName,
        //            string ruleName,
        //            ErrorCollection errorObject)
        //        {
        //            if(xDocument == null ||
        //                xPathTag == null ||
        //                valueCodesFormat == null ||
        ////				currencyAmountList == null ||
        //                xPathTag.Length == 0 ||
        //                valueCodesFormat.Length == 0 ||
        ////				currencyAmountList.Length == 0 ||
        //                errorCode == null ||
        //                errorCode.Length == 0 ||
        //                errorObject == null)

        //            {
        //                return false;
        //            }

        //            bool isValid = true;
        //            XmlNode xRoot = xDocument.Document;
        //            XmlNodeList xListTag = xRoot.SelectNodes(xPathTag.ToString());

        //            //Check the existence of Tag
        //            if (xListTag.Count != 0)
        //            {
        //                //Split the Code-format pair into Array variable
        //                string [] strArray = valueCodesFormat.Split(Constants.CHRCOMMA);
        //                int ArrayCount = strArray.Length;
        //                string strCodes = string.Empty;
        //                //Put code and its format into Hashtable.
        //                Hashtable htCodeFormat = new Hashtable();
        //                for(int Count = 0;Count <= ArrayCount - 1;Count++)
        //                {
        //                    string [] strTagFormat=strArray[Count].Split(Constants.CHRPIPE);
        //                    htCodeFormat.Add(strTagFormat[0].ToString(),strTagFormat[1].ToString());
        //                    strCodes = strCodes + strTagFormat[0].ToString() + Constants.COMMA;

        //                }
        //                string strCodeExists = string.Empty;

        //                foreach(XmlNode xNodeTag in xListTag)
        //                {
        //                    strCodeExists = strCodes;

        //                    // Get the number of childs for a tag
        //                    int ChildCount = xNodeTag.ChildNodes.Count;

        //                    //Get the first child of Tag
        //                    XmlNode xNode = xNodeTag.FirstChild;

        //                    // This variable will contains the inner text of a tag, after verifying the following:
        //                    //	a.	The first character of line1 of the tag must start with a slash
        //                    //	b.	Each line in a tag should not have odd number of slashes.
        //                    string strLine = xNode.InnerText;

        //                    //If there are odd no. of slashes in first child of Tag then throw error
        //                    if (CheckSlashes(strLine)==false)
        //                    {
        //                        errorObject.AddError(errorCode, policyName, ruleName,
        //                            xNode.Name, strLine);
        //                        return false;

        //                    }

        //                    // Check for the next siblings of first child of Tag and check for odd number of slashes
        //                    // If found odd number of slashes then throw an error else concatenate the text of a line
        //                    // with the previous line text.
        //                    string strLine1 = string.Empty;
        //                    for(int Count = 1;Count<= ChildCount - 1;Count++)
        //                    {
        //                        xNode = xNode.NextSibling;
        //                        strLine1 = xNode.InnerText;
        //                        if (CheckSlashes(strLine1) == false)
        //                        {
        //                            errorObject.AddError(errorCode, policyName, ruleName,
        //                                xNode.Name, strLine1);
        //                            return false;
        //                        }
        //                        strLine = strLine + strLine1;
        //                    }

        //                    //Form a code-value pair of XML Document into two set of array variables
        //                    string [] strResult = strLine.Split(Constants.CHRSLASH);
        //                    int resultCount = strResult.Length;

        //                    // The variable strResultCodeArray will contain the list of codes
        //                    string [] strResultCodeArray = new string[resultCount/2];
        //                    // The variable strResultValueArray will contain the value corresponding to the respective Code.
        //                    string [] strResultValueArray = new string[resultCount/2];

        //                    int resultCode =0;
        //                    int resultValue = 0;

        //                    for(int Count = 1;Count<= resultCount-1;Count++)
        //                    {
        //                        if ((Count%2)!=0)
        //                        {
        //                            strResultCodeArray[resultCode] = Constants.SLASH +strResult[Count].ToString() + Constants.SLASH;
        //                            resultCode++;
        //                        }
        //                        else
        //                        {
        //                            strResultValueArray[resultValue]=strResult[Count].ToString();
        //                            resultValue++;
        //                        }
        //                    }

        //                    string strFormat = string.Empty;

        //                    //For each code of Xml document, check the corresponding format from Hash table
        //                    // Check the data type and max length of value of each code of xml doc
        //                    for(int Count = 0;Count<= strResultCodeArray.Length-1;Count++)
        //                    {
        //                        //Get the format of code from hash table
        //                        strFormat = GetFormatValue(htCodeFormat,strResultCodeArray[Count]);

        //                        if (strFormat != string.Empty)
        //                        {
        //                            //check non-repititiveness of codes
        //                            if (strCodeExists.IndexOf(strResultCodeArray[Count])== -1)
        //                            {
        //                                errorObject.AddError(errorCode, policyName, ruleName,
        //                                    xNodeTag.Name, strResultCodeArray[Count]);
        //                                return false;
        //                            }
        //                            else
        //                            {
        //                                string strCodeCheck = strResultCodeArray[Count].ToString();
        //                                strCodeCheck = strCodeCheck + Constants.COMMA;
        //                                strCodeExists = strCodeExists.Replace(strCodeCheck,Constants.BLANK);
        //                            }

        //                            if (strFormat.CompareTo(Constants.ALPHAg) == 0)
        //                            {
        //                                string currencyAmount = strResultValueArray[Count];
        //                                string currencyCode = currencyAmount.Substring(0,3);
        //                                string amountValue = currencyAmount.Substring(3);

        //                                Regex reg = new Regex(Constants.GPATTERN);
        //                                if (!reg.IsMatch(strResultValueArray[Count]))
        //                                {
        //                                    errorObject.AddError(errorCode, policyName, ruleName,
        //                                        strResultCodeArray[Count], strResultValueArray[Count]);
        //                                    return false;
        //                                }
        //                                if (reg.IsMatch(strResultValueArray[Count]))
        //                                {
        //                                    isValid = CheckCurrencyAmount(currencyCode, amountValue,  true,
        //                                        true,true,errorCode,Constants.ELEMENTCURRENCYNAME,xNodeTag.Name,ruleName,policyName,
        //                                        errorObject);
        //                                }
        //                            }
        //                            else if (IsValidCodeFormatData(strResultValueArray[Count],strFormat) == false)

        //                            {
        //                                //Raise error if value of code does not satisfy the format.
        //                                errorObject.AddError(errorCode, policyName, ruleName,
        //                                    strResultCodeArray[Count], strResultValueArray[Count]);
        //                                return false;
        //                            }

        //                        }
        //                    }
        //                }
        //            }
        //            return isValid;
        //        }

        /// <method>
        ///		IsValidCodeFormat
        /// </method>
        /// <summary>
        ///		This method performs validation for the codes which may be used with a particular format.
        ///		eg: /AABA/9n,/ACLAMT/3!a15d This function is specifically written for ISITC type messages
        ///		such as MT523 ISITC
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="valueCodesFormat" type = "string">
        ///		Input containing the Code value with the Valid Format.
        /// </param>
        /// <param name ="valueMandatoryCodes" type = "string">
        ///		Input containing the Mandatory Code value .
        /// </param>
        /// <param name ="valueCodesEnumlist" type = "string">
        ///		Input containing the Valid Code.
        ///		e.g. /ACDS/*BA|CD|CMO,/AITM/*A|B|C
        /// </param>
        /// <param name ="currencyAmountList" type = "string">
        ///		Input containing the number of digits after the decimal Comma for a particular Currency Code .
        /// </param>
        /// <param name ="valueOCMT" type = "string">
        ///		Input containing the value OCMT.
        /// </param>
        /// <param name ="valueCHGS" type = "string">
        ///		Input containing the value CHGS.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool IsValidCodeFormat(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathTag,
        //    string valueCodesFormat,
        //    string valueMandatoryCodes,
        //    string valueCodesEnumlist,
        //    //string currencyAmountList,
        //    string valueOCMT,
        //    string valueCHGS,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPathTag == null ||
        //        valueCodesFormat == null ||
        //        //currencyAmountList == null ||
        //        valueMandatoryCodes == null ||
        //        valueCodesEnumlist == null ||
        //        valueOCMT == null ||
        //        valueOCMT == null ||
        //        valueCHGS == null ||
        //        valueCHGS.Length == 0 ||
        //        valueCodesEnumlist.Length == 0 ||
        //        xPathTag.Length == 0 ||
        //        valueCodesFormat.Length == 0 ||
        //        valueMandatoryCodes.Length == 0 ||
        //        //currencyAmountList.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    bool isValid = true;

        //    XmlNode xRoot = xDocument.Document;
        //    XmlNodeList xListTag = xRoot.SelectNodes(xPathTag.ToString());

        //    //Check the existence of Tag
        //    if (xListTag.Count != 0)
        //    {

        //        string strMandatoryCodes = string.Empty;
        //        string strCodeExists = string.Empty;
        //        string strLine = string.Empty;
        //        string [] doubleSlashArray = null;
        //        string strLine1 = string.Empty;
        //        string strMandatory = string.Empty;
        //        string [] strResultCodeArray = null;
        //        string [] strResultValueArray = null;
        //        string [] codeValue = null;
        //        string [] strResult = null;

        //        int positionCode = 0;
        //        int lengthDoubleSlash = 0;
        //        int positionCodeCHGS = 0;
        //        int lengthDoubleSlash1 = 0;
        //        int resultCount = 0;
        //        int resultCode =0;
        //        int resultValue = 0;


        //        foreach(XmlNode xNodeTag in xListTag)
        //        {
        //            strMandatoryCodes = valueMandatoryCodes;

        //            //Check if the input Mandatory codes ends with comma. If not, add comma at the end.
        //            if (strMandatoryCodes != null && !strMandatoryCodes.EndsWith(Constants.COMMA))
        //            {
        //                strMandatoryCodes = strMandatoryCodes.ToString()+ Constants.COMMA;
        //            }

        //            // Get the text for a tag
        //            strLine = xNodeTag.InnerText;
        //            if(strLine.IndexOf(valueOCMT) != -1)
        //            {
        //                positionCode = strLine.LastIndexOf(valueOCMT);
        //                strLine1 = strLine.Substring(0,positionCode);
        //                strLine = strLine.Substring(positionCode);

        //                isValid = CheckCodeFormat(strLine1,valueCodesFormat,valueCodesEnumlist,
        //                    valueOCMT,valueCHGS,errorCode,policyName,ruleName,errorObject);

        //                strLine = strLine.Replace(Constants.DOUBLESLASH, Constants.CARAT);
        //                doubleSlashArray = strLine.Split(Constants.CHRCARAT);
        //                lengthDoubleSlash = doubleSlashArray.Length;

        //                positionCodeCHGS = 0;
        //                for(int nCount = 0; nCount<= lengthDoubleSlash - 1;nCount++)
        //                {
        //                    if(nCount >= Constants.INT1)
        //                    {
        //                        if(doubleSlashArray[nCount].IndexOf(valueCHGS) != -1 )
        //                        {
        //                            positionCodeCHGS = doubleSlashArray[nCount].LastIndexOf(valueCHGS);
        //                            if( positionCodeCHGS != 0)
        //                            {
        //                                errorObject.AddError(errorCode, policyName, ruleName,
        //                                    valueCHGS, doubleSlashArray[nCount]);
        //                            }
        //                        }
        //                    }

        //                    if(nCount > 0)
        //                    {
        //                        doubleSlashArray[nCount] = doubleSlashArray[nCount].Insert(0,Constants.SLASH);
        //                    }
        //                    if (lengthDoubleSlash > Constants.INT1 && nCount <= lengthDoubleSlash -2)
        //                    {
        //                        StringBuilder str = new StringBuilder(doubleSlashArray[nCount]);

        //                        doubleSlashArray[nCount] = str.Append(Constants.SLASH).ToString();

        //                    }
        //                    isValid = CheckCodeFormat(doubleSlashArray[nCount],valueCodesFormat,valueCodesEnumlist,
        //                        valueOCMT,valueCHGS,errorCode,policyName,ruleName,errorObject);

        //                }
        //            }

        //            else
        //            {
        //                CheckCodeFormat(strLine,valueCodesFormat,valueCodesEnumlist,
        //                    valueOCMT,valueCHGS,errorCode,policyName,ruleName,errorObject);
        //            }
        //            strLine = string.Empty;
        //            strLine = xNodeTag.InnerText;
        //            strLine = strLine.Replace(Constants.DOUBLESLASH, Constants.CARAT);
        //            codeValue = strLine.Split(Constants.CHRCARAT);
        //            lengthDoubleSlash1 = codeValue.Length;
        //            for(int nCount = 0; nCount<= lengthDoubleSlash1 - 1;nCount++)
        //            {
        //                strResult = codeValue[nCount].Split(Constants.CHRSLASH);
        //                resultCount = strResult.Length;

        //                // The variable strResultCodeArray will contain the list of codes
        //                strResultCodeArray = new string[resultCount/2];
        //                // The variable strResultValueArray will contain the value corresponding to the respective Code.
        //                strResultValueArray = new string[resultCount/2];

        //                resultCode =0;
        //                resultValue = 0;

        //                for(int countResult = Constants.INT1;countResult<= resultCount-1;countResult++)
        //                {
        //                    if ((countResult%2)!=0)
        //                    {
        //                        strResultCodeArray[resultCode] = Constants.SLASH + strResult[countResult].ToString() + Constants.SLASH;

        //                        resultCode++;
        //                    }
        //                    else
        //                    {
        //                        strResultValueArray[resultValue] = strResult[countResult].ToString();
        //                        resultValue++;
        //                    }
        //                }

        //                for(int countFormat = 0;countFormat <= strResultCodeArray.Length-1;countFormat++)
        //                {

        //                    if (strMandatoryCodes.IndexOf(strResultCodeArray[countFormat])!= -1)
        //                    {
        //                        //Remove code from Mandatory list of codes, if exist
        //                        strMandatory = strResultCodeArray[countFormat].ToString() + Constants.COMMA;
        //                        strMandatoryCodes=strMandatoryCodes.Replace(strMandatory,Constants.BLANK);
        //                    }
        //                }

        //            }
        //            if (strMandatoryCodes.Length !=0 )
        //            {
        //                // Raise error if Mandatory codes not exist in Xml doc code list.
        //                errorObject.AddError(errorCode, policyName, ruleName,
        //                    xNodeTag.Name, strMandatoryCodes);
        //                return false;
        //            }
        //        }
        //    }

        //    return isValid;
        //}

        /// <method>
        ///		IsValidDescriptionOfSecurity
        /// </method>
        /// <summary>
        ///		This method performs validation for the codes to be present before the
        ///		LocalIdentifier in the DescriptionOf security and the Codes that may be used.
        ///		This function is specifically written for ISITC type messages such as MT523 ISITC
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the element to be validated.
        ///		e.g. //IdentificationOfSecurities_A_35B/DescriptionOfSecurities
        /// </param>
        /// <param name ="valueCodesFormat" type = "string">
        ///		Input containing the list of Code-Format value. for e.g. /ACLT/|1!a,/ADIS/|12d
        /// </param>
        /// <param name ="valueSelectCodes" type = "string">
        ///		Input containing the code values to be used in first line.
        ///		e.g. /AAUS/,/ACED/,/ACIN/
        /// </param>
        /// <param name ="valueCodesEnumlist" type = "string">
        ///		Input containing the code values. The Enum list for a particular code. for e.g:
        ///		/ASCT/*BA|CD|CMO, i.e., code ASCT can have its value from the enum list BA, CD or CMO.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool IsValidDescriptionOfSecurity(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathTag,
        //    string valueCodesFormat,
        //    string valueSelectCodes,
        //    string valueCodesEnumlist,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPathTag == null ||
        //        valueCodesFormat == null ||
        //        valueCodesEnumlist == null ||
        //        valueSelectCodes == null ||
        //        valueSelectCodes.Length == 0 ||
        //        valueCodesEnumlist.Length == 0 ||
        //        xPathTag.Length == 0 ||
        //        valueCodesFormat.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    bool isValid = true;
        //    XmlNode xRoot = xDocument.Document;
        //    XmlNodeList xListTag = xRoot.SelectNodes(xPathTag);

        //    //Check the existence of Tag
        //    if (xListTag.Count != 0)
        //    {
        //        //Split the Code-EnumList pair into Array variable e.g. /ACDS/*BA|CD|CMO,/AITM/*A|B|C
        //        string [] strCodeEnumArray = valueCodesEnumlist.Split(Constants.CHRCOMMA);
        //        int CodeEnumArrayCount = strCodeEnumArray.Length;

        //        //Put code and its Enumeration list into Hashtable.
        //        string [] strTagFormat = null;
        //        Hashtable htCodeEnum = new Hashtable();
        //        for(int Count1 = 0;Count1 <= CodeEnumArrayCount - 1;Count1++)
        //        {
        //            // Splitting the codeformat pair string by asterisk (*)
        //            strTagFormat = strCodeEnumArray[Count1].Split(Constants.CHRASTERISK);
        //            // Creating a hashtable with Code as key & Enum list as value pair.
        //            // Adding each pair into the hash table
        //            htCodeEnum.Add(strTagFormat[0].ToString(),strTagFormat[1].ToString());
        //        }

        //        // Will Contains the comma separated list of codes.
        //        string strCodes = string.Empty;
        //        //Split the Code-format pair into Array variable, e.g. /ACLT/|1!a,/ADIS/|12d
        //        string [] strArrayCodeFormatPair = valueCodesFormat.Split(Constants.CHRCOMMA);

        //        //Put code and its format into Hashtable.
        //        strTagFormat = null;
        //        Hashtable htCodeFormat = new Hashtable();
        //        for(int Count = 0; Count <= strArrayCodeFormatPair.Length - 1; Count++)
        //        {
        //            // Splitting the codeformat pair string by pipe (|)
        //            strTagFormat= strArrayCodeFormatPair[Count].Split(Constants.CHRPIPE);
        //            // Creating a hashtable with Code as key & Format as value pair. Adding each pair into the hash table
        //            htCodeFormat.Add(strTagFormat[0].ToString(),strTagFormat[1].ToString());
        //            // Contains the comma separated list of codes.
        //            strCodes = strCodes + strTagFormat[0].ToString() + Constants.COMMA;
        //        }

        //        string strCodeExists = string.Empty;
        //        string strLine = string.Empty;
        //        int codePosition = 0;
        //        string strFormat = string.Empty;
        //        string strCodeCheck = string.Empty;
        //        string [] strResultArray = null;
        //        string [] strResultCodeArray = null;
        //        string [] strResultValueArray = null;
        //        string strEnumList = string.Empty;
        //        string[] codeList = null;

        //        int resultCode = 0;
        //        int resultValue = 0;
        //        int childCount = 0;
        //        int resultCount = 0;

        //        foreach(XmlNode xNodeTag in xListTag)
        //        {
        //            // Initializing strCodeExists with the list of Codes.
        //            strCodeExists = strCodes;
        //            // Getting the number of Child elements in a Tag
        //            childCount = xNodeTag.ChildNodes.Count;
        //            //Get the first child of Tag
        //            XmlNode xNode = xNodeTag.FirstChild;
        //            strLine = xNode.InnerText;

        //            //If there are odd no. of slashes in first child of Tag then throw error
        //            if (CheckSlashes(strLine)==false)
        //            {
        //                errorObject.AddError(errorCode, policyName, ruleName,
        //                    xNode.Name, strLine);
        //                return false;
        //            }

        //            // If the Codes /AAUS/,/ACED/ come in any other line except the First throw an error
        //            codeList = valueSelectCodes.Split(Constants.CHRCOMMA);
        //            foreach(string code in codeList)
        //            {
        //                codePosition = xNodeTag.InnerText.IndexOf(code);
        //                if(codePosition != -1 && codePosition != 0)
        //                {
        //                    errorObject.AddError(errorCode, policyName, ruleName,
        //                        xNodeTag.Name ,xNodeTag.InnerText);
        //                    return false;
        //                }
        //            }
        //            //If the the Codes /ACLT/,/ADIS/... come in the first line ,then throw an error
        //            codeList = null;
        //            codeList = strCodes.Split(Constants.CHRCOMMA);
        //            for(int codeCount = 0; codeCount <= codeList.Length - 2; codeCount++)
        //            {
        //                if(strLine.IndexOf(codeList[codeCount]) != -1)
        //                {
        //                    errorObject.AddError(errorCode, policyName, ruleName,
        //                        xNodeTag.Name ,strLine);
        //                    return false;
        //                }
        //            }

        //            // Resetting the variable to contain the inner text of rest of the siblings, after
        //            // first child of a tag.
        //            strLine = string.Empty;

        //            // Check for odd number of slashes in next siblings of first child of the Tag.
        //            // If found raise an error else concatenate the text of each sibling.
        //            for(int nCount = 1;nCount<= childCount - 1; nCount++)
        //            {
        //                xNode = xNode.NextSibling;
        //                if (CheckSlashes(xNode.InnerText)==false)
        //                {
        //                    errorObject.AddError(errorCode, policyName, ruleName,
        //                        xNode.Name, xNode.InnerText);
        //                    return false;
        //                }
        //                strLine = strLine + xNode.InnerText;
        //            }

        //            // Validating the value of a code w.r.t. its corresponding format
        //            // for the tag childs excluding first child.
        //            // Form a code-value pair of XML Document into two set of array variables
        //            strResultArray = strLine.Split(Constants.CHRSLASH);
        //            resultCount = strResultArray.Length;

        //            // Seperating out the Codes and their corresponding formats and
        //            // storing them into 2 separate arrays, strResultCodeArray - stores the codes
        //            // and strResultValueArray - stores the corresponding formats
        //            strResultCodeArray = new string[resultCount/2];
        //            strResultValueArray = new string[resultCount/2];

        //            //	Counters to increment the ResultCodeArray and ResultValueArray
        //            resultCode = 0;
        //            resultValue = 0;

        //            for(int Count = 1;Count<= resultCount-1;Count++)
        //            {
        //                if ((Count%2)!=0)
        //                {
        //                    strResultCodeArray[resultCode] = Constants.SLASH + strResultArray[Count].ToString(CultureInfo.InvariantCulture) + Constants.SLASH;
        //                    resultCode++;
        //                }
        //                else
        //                {
        //                    strResultValueArray[resultValue] = strResultArray[Count].ToString(CultureInfo.InvariantCulture);
        //                    resultValue++;
        //                }
        //            }

        //            //For each code of Xml document, check the corresponding format from Hash table
        //            // Check the data type and max length of value of each code of xml doc
        //            for(int Count = 0;Count<= strResultCodeArray.Length-1;Count++)
        //            {
        //                //Get the format of code from hash table
        //                strFormat = GetFormatValue(htCodeFormat,strResultCodeArray[Count]);
        //                if (strFormat != string.Empty)
        //                {
        //                    // check non-repititiveness of codes
        //                    if (strCodeExists.IndexOf(strResultCodeArray[Count])== -1)
        //                    {
        //                        errorObject.AddError(errorCode, policyName, ruleName,
        //                            xNodeTag.Name, strResultCodeArray[Count]);
        //                        return false;
        //                    }
        //                    else
        //                    {
        //                        strCodeCheck = strResultCodeArray[Count].ToString(CultureInfo.InvariantCulture);
        //                        strCodeCheck = strCodeCheck + Constants.COMMA;
        //                        strCodeExists = strCodeExists.Replace(strCodeCheck,Constants.BLANK);
        //                    }


        //                    // check for valid date format
        //                    if (strFormat.CompareTo(Constants.ALPHAdate6) == 0)
        //                    {
        //                        Regex reg = new Regex(Constants.DATE6PATTERN);
        //                        if (!reg.IsMatch(strResultValueArray[Count]))
        //                        {
        //                            //Raise error if value of code does not satisfy the format.
        //                            errorObject.AddError(errorCode, policyName, ruleName,
        //                                strResultCodeArray[Count], strResultValueArray[Count]);
        //                        }
        //                        if (reg.IsMatch(strResultValueArray[Count]))
        //                        {

        //                            if (strResultValueArray[Count].Length.ToString(CultureInfo.InvariantCulture)
        //                                != strFormat.Substring(0,1))
        //                            {
        //                                //Raise error if value of code does not satisfy the format.
        //                                errorObject.AddError(errorCode, policyName, ruleName,
        //                                    strResultCodeArray[Count], strResultValueArray[Count]);
        //                            }
        //                        }

        //                    }
        //                    if (IsValidCodeFormatData(strResultValueArray[Count],strFormat) == false)
        //                    {
        //                        //Raise error if value of code does not satisfy the format.
        //                        errorObject.AddError(errorCode, policyName, ruleName,
        //                            strResultCodeArray[Count], strResultValueArray[Count]);
        //                        return false;
        //                    }

        //                    // Checking for the valid enum values for a particular code
        //                    strEnumList = GetFormatValue(htCodeEnum,strResultCodeArray[Count]);
        //                    if (strEnumList.CompareTo(string.Empty) != 0)
        //                    {
        //                        if (strEnumList.IndexOf(strResultValueArray[Count])== -1)
        //                        {
        //                            //Raise error if value in xml doc does not exist in enum list
        //                            errorObject.AddError(errorCode, policyName, ruleName,
        //                                xNodeTag.Name, strResultCodeArray[Count]);
        //                            return false;
        //                        }
        //                    }
        //                }
        //            }
        //        }
        //    }
        //    return isValid;
        //}

        /// <method>
        ///		CheckMandatoryOccurrenceOfSubSequence
        /// </method>
        /// <summary>
        ///		In each occurance of subsequence(B1a,B2a,C,D) the presence of subsequence (B1a1,Ba1,C1,D1)depends
        ///		on the presence of field //22F::STCO//NSSP
        ///		applicable for error code E48,E49,E50,E51 of MT505
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the Sequence e.g. //SequenceB1a
        /// </param>
        /// <param name ="xPathSubSequence" type = "string">
        ///		Input containing the xPath of the Subsequence e.g. ./SequenceB1a1
        /// </param>
        /// <param name ="xPathTag22F" type = "string">
        ///		Input containing the xPath of the element 22F e.g. ./Indicator_B1a_22F
        /// </param>
        /// <param name ="valueQualifier" type = "string">
        ///		Input containing the value of the Qualifier
        /// </param>
        /// <param name ="valueIndicator" type = "string">
        ///		Input containing the value of the Indicator
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckMandatoryOccurrenceOfSubSequence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPathTag22F,
            string valueQualifier,
            string valueIndicator,
            string policyName,
            string ruleName,
            string messageType,
            string errorCode,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckMandatoryOccurrenceOfSubSequence" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    xPathTag22F == null ||
                    xPathTag22F.Length == 0 ||
                    valueQualifier == null ||
                    valueQualifier.Length == 0 ||
                    valueIndicator == null ||
                    valueIndicator.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleNumber == null ||
                    errorObject == null)
                {
                    return false;
                }



                XmlNode xRoot = xDocument.Document;
                //Select all nodes of the Sequence
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    bool presence = false;

                    //Select all the nodes of Tag 22F in the Sequence
                    XmlNodeList List22F = xNodeSequence.SelectNodes(xPathTag22F);

                    foreach (XmlNode Node22F in List22F)
                    {
                        //Check for the Qualifier and Indicator values, presence of
                        //Data Source Scheme in Tag 22F
                        if (Node22F != null && Node22F.FirstChild != null && Node22F.LastChild != null &&
                            Node22F.FirstChild.InnerText.CompareTo(valueQualifier) == 0 &&
                            !(Node22F.FirstChild.NextSibling.HasChildNodes) &&
                            Node22F.LastChild.InnerText.CompareTo(valueIndicator) == 0)
                        {
                            presence = true;
                            break;
                        }
                    }

                    //If codition for Tag 22F satisfied and Subsequence not present,
                    //throw an error
                    if (presence && xNodeSequence.SelectNodes(xPathSubSequence).Count == 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }


        /// <method>
        /// 	CheckIfSubSequencePresent
        /// </method>
        /// <summary>
        /// 	Sequence C is not allowed when for all occurrences of sequence B either
        /// 	the subsequence B1 is not present, or B1a is present in all occurrences of B1
        /// 	Sequence D is not allowed when for all occurrences of sequence B
        /// 	either the subsequence B2 is not present, or B2a is present in all occurrences of B2
        /// </summary>
        /// <param name="xDocument">
        /// 	xDocument
        /// </param>
        /// <param name="sequenceC">
        /// 	SequenceC
        /// </param>
        /// <param name="sequenceB">
        /// 	SequenceB
        /// </param>
        /// <param name="sequenceB1">
        /// 	SequenceB1
        /// </param>
        /// <param name="sequenceB1A">
        /// 	SequenceB1a
        /// </param>
        /// <param name="policyName">
        /// 	Input the network rule policy name
        /// </param>
        /// <param name="ruleName">
        /// 	Input the rule name
        /// </param>
        /// <param name="messageType">
        /// 	Input message type
        /// </param>
        /// <param name="errorCode">
        /// 	Input the error code
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	Input the conditional rule name (i.e C nn)
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Input the conditional rule number
        /// </param>
        /// <param name="errorObject">
        /// 	Error Object reference
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool CheckIfSubSequencePresent(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string sequenceC,
            string sequenceB,
            string sequenceB1,
            string sequenceB1A,
            string policyName,
            string ruleName,
            string messageType,
            string errorCode,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckIfSubSequencePresent" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (null == xDocument) throw new ArgumentNullException("xDocument");
                if (null == sequenceB1) throw new ArgumentNullException("sequenceB1");

                XmlNode xRoot = xDocument.Document;

                XmlNode nodeSeqC = xRoot.SelectSingleNode(sequenceC);

                bool nodeCExists = nodeSeqC != null;

                bool nodeB1NotInEveryNodeB = true;

                bool nodeB1AInEveryB1Node = true;

                // All B nodes.. - Each of them should not contain B1...
                XmlNodeList xListB = xRoot.SelectNodes(sequenceB);
                foreach (XmlNode nodeB in xListB)
                {
                    // If node B1 exists, then it is bad...
                    if (null != nodeB.SelectSingleNode(sequenceB1))
                    {
                        nodeB1NotInEveryNodeB = false;
                        break;
                    }
                }

                // Xpath to B1 passed in was a relative one... Cnvert to an absolute XPath...
                sequenceB1 = sequenceB1.Replace("./", "//");

                // All B1 nodes .. each of them should contain a B1A...
                XmlNodeList nodeB1List = xRoot.SelectNodes(sequenceB1);

                foreach (XmlNode nodeB1 in nodeB1List)
                {
                    if (null == nodeB1.SelectSingleNode(sequenceB1A))
                    {
                        // If there is no node B1A in the current B1 node, then we can bail....
                        nodeB1AInEveryB1Node = false;
                        break;
                    }
                }

                // Now the rule...
                // C can not exist, if either (node B1 is Not in every B OR node B1A in every B1)

                return ((!nodeCExists) &&
                           (nodeB1NotInEveryNodeB || nodeB1AInEveryB1Node)
                       );
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        ///<method>
        /// CheckIfSequencePresent
        ///</method>
        /// <summary>
        /// 	Sequence C is mandatory when in any occurrence of sequence B the subsequence B1 is present and the subsequence
        /// 	B1a is not present (Error code(s): C97).
        /// 	Sequence D is mandatory when in any occurrence of sequence B the subsequence B2 is present and the subsequence
        /// 	B2a is not present (Error code(s): C99).
        /// </summary>
        /// <param name="xDocument">
        /// 	xDocument
        /// </param>
        /// <param name="SequenceC">
        /// 	xPath of Sequence.
        /// </param>
        /// <param name="SequenceB">
        /// 	xPath of Sequence.
        /// </param>
        /// <param name="SequenceB1">
        /// 	xPath of Sequence.
        /// </param>
        /// <param name="SequenceB1a">
        /// 	xPath of Sequence.
        /// </param>
        /// <param name="policyName">
        /// 	Policy Name
        /// </param>
        /// <param name="ruleName">
        /// 	Rule Name
        /// </param>
        /// <param name="messageType">
        /// 	Message Number
        /// </param>
        /// <param name="errorCode">
        /// 	Error Code
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	Conditional Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Conditional Rule Number
        /// </param>
        /// <param name="errorObject">
        /// 	Error Object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool CheckIfSequencePresent(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string SequenceC,
            string SequenceB,
            string SequenceB1,
            string SequenceB1a,
            string policyName,
            string ruleName,
            string messageType,
            string errorCode,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckIfSequencePresent" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == errorObject) throw new ArgumentNullException("errorObject");
                if (null == xDocument) throw new ArgumentNullException("xDocument");


                XmlNode xRoot = xDocument.Document;
                XmlNode NodeseqC = xRoot.SelectSingleNode(SequenceC);

                XmlNodeList xListB = xRoot.SelectNodes(SequenceB);
                foreach (XmlNode xnodeb in xListB)
                {
                    XmlNode Nodeseqb1 = xnodeb.SelectSingleNode(SequenceB1);

                    if (Nodeseqb1 != null)
                    {
                        XmlNode Nodeseqb1a = Nodeseqb1.SelectSingleNode(SequenceB1a);

                        if (Nodeseqb1a == null && NodeseqC == null)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName,
                                conditionalRuleNumber);
                            isValid = false;
                            break;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		CheckMandatoryOccurrenceOfTagInSequence
        /// </method>
        /// <summary>
        /// 	In occurance of sequenceB if field :95C::PSET is present in one occurance of subsequence B1a1
        /// 	then field :22F::STCO/[8c]/PHYS is mandatory in subsequence B1a(Error Code(s): E54)
        /// 	In sequenceC if field :95C::PSET is present in one occurance of subsequence C1, then field
        /// 	::22F::STCO/[8c]/PHYS is mandatory in sequenceC (Error Code(s): E55)
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the Sequence e.g. //SequenceB
        /// </param>
        /// <param name ="xPathConditionalSequence" type = "string">
        ///		Input containing the xPath of the Sequence in which the Tag 95C
        ///		is present e.g. ./SequenceB1/SequenceB1a/SequenceB1a1
        /// </param>
        /// <param name ="xPathMandatorySequence" type = "string">
        ///		Input containing the xPath of the Sequence in which the Tag 22F
        ///		is present e.g. ./SequenceB1/SequenceB1a
        /// </param>
        /// <param name ="xPathTag95C" type = "string">
        ///		Input containing the xPath of the Tag 95C e.g. ./Party_B1a1_95C
        /// </param>
        /// <param name ="xPathTag22F" type = "string">
        ///		Input containing the xPath of the Tag 22F e.g. ./Indicator_B1a_22F
        /// </param>
        /// <param name ="valueQualifier95" type = "string">
        ///		Input containing the value of the Qualifier for Tag 95C
        /// </param>
        /// <param name ="valueQualifier22" type = "string">
        ///		Input containing the value of the Qualifier for Tag 22F
        /// </param>
        /// <param name ="valueIndicator" type = "string">
        ///		Input containing the value of the Indicator for Tag 22F
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool CheckMandatoryOccurrenceOfTagInSequence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence,
        //    string xPathConditionalSequence,
        //    string xPathMandatorySequence,
        //    string xPathTag95C,
        //    string xPathTag22F,
        //    string valueQualifier95,
        //    string valueQualifier22,
        //    string valueIndicator,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string errorCode,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{
        //    if(xDocument == null ||
        //        xPathSequence == null ||
        //        xPathSequence.Length == 0 ||
        //        xPathConditionalSequence == null ||
        //        xPathConditionalSequence.Length == 0 ||
        //        xPathMandatorySequence == null ||
        //        xPathMandatorySequence.Length == 0 ||
        //        xPathTag95C == null ||
        //        xPathTag95C.Length == 0 ||
        //        xPathTag22F == null ||
        //        xPathTag22F.Length == 0 ||
        //        valueQualifier95 == null ||
        //        valueQualifier95.Length == 0 ||
        //        valueQualifier22 == null ||
        //        valueQualifier22.Length == 0 ||
        //        valueIndicator == null ||
        //        valueIndicator.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        policyName == null ||
        //        policyName.Length == 0 ||
        //        ruleName == null ||
        //        ruleName.Length == 0 ||
        //        messageType == null ||
        //        messageType.Length == 0 ||
        //        conditionalRuleName == null ||
        //        conditionalRuleNumber == null ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }

        //    bool isValid = true;
        //    XmlNode xRoot = xDocument.Document;
        //    //Select all the nodes of the Sequence
        //    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

        //    foreach(XmlNode xNodeSequence in xListSequence)
        //    {
        //        bool presence95 = false;
        //        bool presence22 = false;
        //        //Select all the nodes of the Conditional Sequence in which
        //        //Tag 95C is to be checked
        //        XmlNodeList xListConditionalSequence = xNodeSequence.SelectNodes(xPathConditionalSequence);

        //        foreach(XmlNode xNodeConditionalSequence in xListConditionalSequence)
        //        {
        //            //Select the node of Tag 95C in the Conditional Sequence
        //            XmlNode Node95C = xNodeConditionalSequence.SelectSingleNode(xPathTag95C);

        //            //Check for the Qualifier value of Tag 95C
        //            if(Node95C != null && Node95C.FirstChild != null &&
        //                Node95C.FirstChild.InnerText.CompareTo(valueQualifier95) == 0)
        //            {
        //                presence95 = true;
        //                break;
        //            }
        //        }

        //        if(presence95)
        //        {
        //            XmlNodeList list22F = null;

        //            //If the Sequence and Mandatory Sequence are the same
        //            if(xPathSequence.Substring(10) == xPathMandatorySequence.Substring(10))
        //            {
        //                //Select all the nodes of Tag 22F in the Sequence
        //                list22F = xNodeSequence.SelectNodes(xPathTag22F);
        //            }
        //            else
        //            {
        //                //Select the node of the Mandatory Sequence in which
        //                //Tag 22F is to be checked
        //                XmlNode xNodeMandatorySequence = xNodeSequence.SelectSingleNode(xPathMandatorySequence);
        //                //Select all the nodes of Tag 22F in the Mandatory Sequence
        //                if(xNodeMandatorySequence != null)
        //                    list22F = xNodeMandatorySequence.SelectNodes(xPathTag22F);
        //            }
        //            foreach(XmlNode node22F in list22F)
        //            {
        //                //Check for the Qualifier and Indicator value of Tag 22F
        //                if(node22F != null && node22F.FirstChild != null && node22F.LastChild != null &&
        //                    node22F.FirstChild.InnerText.CompareTo(valueQualifier22) == 0 &&
        //                    node22F.LastChild.InnerText.CompareTo(valueIndicator) == 0)
        //                {
        //                    presence22 = true;
        //                    break;
        //                }
        //            }

        //            if(!(presence22))
        //            {
        //                errorObject.AddError(errorCode,policyName,ruleName,messageType,
        //                    conditionalRuleName,conditionalRuleNumber);
        //                isValid = false;
        //            }
        //        }
        //    }
        //    return isValid;
        //}

        /// <method>
        ///		SWIFTNetworkRule268
        /// </method>
        /// <summary>
        ///		if field:20C::MAST of Subsequence B2 is NOT present then Subsequence B2a is mandatory
        ///		else it is optional
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSeqB2">
        ///		Input reference of the element Sequence B2 to be validated
        ///		e.g. //SequenceB2
        /// </param>
        /// <param name="xPathTag20C">
        ///		Input reference of the element 20C of Sequence B2 to be validated
        ///		e.g. ./Reference_B2_20C
        /// </param>
        /// <param name="xPathSeqB2a">
        /// 	Input reference of the element Sequence B2a to be validated
        /// 	e.g. ./SequenceB2a
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT584
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule268(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSeqB2,
            string xPathTag20C,
            string xPathSeqB2a,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule268" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSeqB2 == null ||
                    xPathTag20C == null ||
                    xPathSeqB2a == null ||
                    xPathSeqB2.Length == 0 ||
                    xPathTag20C.Length == 0 ||
                    xPathSeqB2a.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                XmlNode xRoot = xDocument.Document;
                XmlNodeList xNodeListSeqB2 = xRoot.SelectNodes(xPathSeqB2);

                foreach (XmlNode xNodeSeqB2 in xNodeListSeqB2)
                {
                    XmlNode xNodeTag20C = xNodeSeqB2.SelectSingleNode(xPathTag20C);

                    if (xNodeTag20C == null)
                    {
                        XmlNode xNodeSeqB2a = xNodeSeqB2.SelectSingleNode(xPathSeqB2a);
                        if (xNodeSeqB2a == null)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule273
        /// </method>
        /// <summary>
        ///		Within each occurrence of Subsequence B2b/C1c, if the Settlement Amount (:19A::SETT)
        ///		is	present in Subsequence B2b/C1c, it must not be present in any occurrence of Subsequence	B2b2/C1c2.
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSeq">
        ///		Input reference of the element Sequence
        ///		e.g. //SequenceB2b
        /// </param>
        /// <param name="xPathSeqTag19A">
        ///		Input reference of the element Tag 19A of Sequence
        ///		e.g. ./Amount_B2b_19A
        /// </param>
        /// <param name="xPathSubSeqTag19AQualifier">
        ///		Input reference of the element Tag 19A qualifier of SubSequence
        ///		e.g. ./SequenceB2b2/Amount_B2b2_19A/Qualifier
        /// </param>
        /// <param name="valueSubSeqTag19AQualifier">
        ///		Input containing the value of Tag 19A qualifier of given subSequence
        ///		e.g. SETT
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT584
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule273(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSeq,
            string xPathSeqTag19A,
            string xPathSubSeqTag19AQualifier,
            string valueSubSeqTag19AQualifier,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule273" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSeq == null ||
                    xPathSeqTag19A == null ||
                    xPathSubSeqTag19AQualifier == null ||
                    valueSubSeqTag19AQualifier == null ||
                    xPathSeq.Length == 0 ||
                    xPathSeqTag19A.Length == 0 ||
                    xPathSubSeqTag19AQualifier.Length == 0 ||
                    valueSubSeqTag19AQualifier.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                XmlNode xRoot = xDocument.Document;
                XmlNodeList xNodeListSeq = xRoot.SelectNodes(xPathSeq);

                foreach (XmlNode xNodeSeq in xNodeListSeq)
                {
                    XmlNode xNodeSeqTag19A = xNodeSeq.SelectSingleNode(xPathSeqTag19A);

                    if (xNodeSeqTag19A != null && xNodeSeqTag19A.InnerText != null && xNodeSeqTag19A.InnerText.Length != 0)
                    {
                        XmlNodeList xNodeListSubSeqTag19A = xNodeSeq.SelectNodes(xPathSubSeqTag19AQualifier);
                        foreach (XmlNode xNodeSubSeqTag19A in xNodeListSubSeqTag19A)
                        {
                            if (xNodeSubSeqTag19A.InnerText.CompareTo(valueSubSeqTag19AQualifier) == 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                                break;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		IsValidPlaceOfPresentation
        /// </method>
        /// <summary>
        ///		Country Code is mandatory. Either Account Id or Place or both must be present (Error code(s):
        /// 	(T70). This function is specific to following format:
        ///				2!a[/34x]
        ///				[4*35x]
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the tag e.g.82S(MT405)
        /// </param>
        /// <param name ="xPathField1" type = "string">
        ///		Input reference of the Field1
        /// </param>
        /// <param name ="xPathField2" type = "string">
        ///		Input reference of the Field2
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		error Object.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidPlaceOfPresentation(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string xPathField1,
            string xPathField2,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidPlaceOfPresentation" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathField1 == null ||
                    xPathField1.Length == 0 ||
                    xPathField2 == null ||
                    xPathField2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }



                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of the tag in the message

                XmlNodeList xListTag = xRoot.SelectNodes(xPathTag);

                foreach (XmlNode xNode in xListTag)
                {
                    XmlNode xNodeField1 = xNode.SelectSingleNode(xPathField1);
                    XmlNode xNodeField2 = xNode.SelectSingleNode(xPathField2);
                    if (xNodeField1 == null && xNodeField2 == null)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, xNode.Name, xNode.InnerText);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        /// SWIFTNetworkRule190
        /// </method>
        /// <summary>
        /// 	The presence of subsequences A1 and B1 Avalisation Details is dependent on the
        /// 	presence and the content of Type of field 23E in the same sequence A and B, respectively
        /// 	(Error code(s): D90).
        /// </summary>
        /// <param name="xDocument">
        /// 	xml document
        /// </param>
        /// <param name="xPathSequence">
        /// 	xPath of Sequence e.g. //SequenceA
        /// </param>
        /// <param name="xPathSubSequence">
        /// 	xPath of SubSequence e.g. ./SequenceA1
        /// </param>
        /// <param name="xPathField23E">
        /// 	Xpath of Tag 23E e.g. ./xPathTag23E
        /// </param>
        /// <param name="codesSubSequenceAllowed">
        /// 	codes list for tag 23E of Sequence A to check the mandatory
        /// 	occurrence of Sequence A1 e.g. BAAV
        /// </param>
        /// <param name="codesSubSequenceNotAllowed">
        /// 	codes list for tag 23E of Sequence A to check the absence of
        /// 	Sequence A1 e.g. BACC,BNAV
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="policyName">
        /// 	policy name
        /// </param>
        /// <param name="ruleName">
        /// 	rule name
        /// </param>
        /// <param name="messageType">
        /// 	message number
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Rule Number
        /// </param>
        /// <param name="errorObject">
        /// 	error object
        /// </param>
        /// <returns>
        /// 	boolean value
        /// </returns>
        public static bool SWIFTNetworkRule190(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPathField23E,
            string codesSubSequenceAllowed,
            string codesSubSequenceNotAllowed,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule190" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    xPathField23E == null ||
                    xPathField23E.Length == 0 ||
                    codesSubSequenceAllowed == null ||
                    codesSubSequenceAllowed.Length == 0 ||
                    codesSubSequenceNotAllowed == null ||
                    codesSubSequenceNotAllowed.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                bool isError = false;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                if (xListSequence.Count != 0)
                {
                    foreach (XmlNode xNodeSequence in xListSequence)
                    {
                        //Check if the subsequence present
                        XmlNode xNodeSubSequence = xNodeSequence.SelectSingleNode(xPathSubSequence);

                        //Check if Field 23E is not present and Subsequence present then throw an error
                        XmlNode xNodeField23E = xNodeSequence.SelectSingleNode(xPathField23E);
                        if (xNodeField23E == null && xNodeSubSequence != null && xNodeSubSequence.InnerText != null)
                        {
                            isError = true;
                        }
                        //Check if Field 23E present or not
                        else if (xNodeField23E != null && xNodeField23E.InnerText != null)
                        {
                            if (codesSubSequenceAllowed.IndexOf(xNodeField23E.InnerText) >= 0 &&
                                (xNodeSubSequence == null || xNodeSubSequence.InnerText == null))
                            {
                                isError = true;

                            }
                            else if (codesSubSequenceNotAllowed.IndexOf(xNodeField23E.InnerText) >= 0 &&
                                xNodeSubSequence != null && xNodeSubSequence.InnerText != null)
                            {
                                isError = true;
                            }
                        }
                        if (isError)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                conditionalRuleName, conditionalRuleNumber);
                            isValid = false;

                        }
                        isError = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	SWIFTNetworkRule189
        /// </method>
        /// <summary>
        /// 	If sequence C is present and the sum of the fields 32a in sequence B equals the amount
        /// 	indicated in field 32a in sequence C, then field 19 must not be present in sequence C.
        /// 	If sequence C is present and the sum of the fields 32a in sequence B does not equal the
        /// 	amount indicated in field 32a in sequence C, then field 19 must be present in sequence C
        /// 	and must equal the sum of all the fields 32a in sequence B (Error code(s): D89).
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated
        /// </param>
        /// <param name="xPathSequence">
        /// 	xPath of Non Repetitive Sequence
        /// </param>
        /// <param name="xPathSequenceB32aAmount">
        /// 	xPath of Amount Field in Tag 32 Sequence B
        /// </param>
        /// <param name="xPathSequenceC32aAmount">
        /// 	xPath of Amount Field in Tag 32 Sequence C
        /// </param>
        /// <param name="xPathField19">
        /// 	xPath of Tag 19
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="policyName">
        /// 	policy name
        /// </param>
        /// <param name="ruleName">
        /// 	rule name
        /// </param>
        /// <param name="messageType">
        /// 	message number
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	Conditional Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	Conditional Rule Number
        /// </param>
        /// <param name="errorObject">
        /// 	Error object
        /// </param>
        /// <returns>
        /// 	boolean value
        /// </returns>
        public static bool SWIFTNetworkRule189(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSequenceB32aAmount,
            string xPathSequenceC32aAmount,
            string xPathField19,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule189" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSequenceB32aAmount == null ||
                    xPathSequenceB32aAmount.Length == 0 ||
                    xPathSequenceC32aAmount == null ||
                    xPathSequenceC32aAmount.Length == 0 ||
                    xPathField19 == null ||
                    xPathField19.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    bool isValid = true;
                    double Amount32aTotal = 0; //Sequence B
                    double Amount32a = 0; //Sequence C
                    bool isError = false;
                    XmlNode xRoot = xDocument.Document;

                    XmlNode xNodeSequence = xRoot.SelectSingleNode(xPathSequence);	// xPathNonRepetitiveSequence

                    if (xNodeSequence != null && xNodeSequence.InnerText != null)
                    {
                        //Calculate the sum of the fields 32a in sequence B
                        Amount32aTotal = CommonFunctions.SumOfTagValues(xDocument, xPathSequenceB32aAmount);

                        string[] xPathSequenceC32aAmountArray = xPathSequenceC32aAmount.Split(Constants.CHRCOMMA);

                        for (int count = 0; count <= xPathSequenceC32aAmountArray.Length - 1; count++)
                        {
                            XmlNode xNodeSequenceC32a = xNodeSequence.SelectSingleNode(xPathSequenceC32aAmountArray[count]);
                            if (xNodeSequenceC32a != null && xNodeSequenceC32a.InnerText != null)
                            {
                                Amount32a = Convert.ToDouble(xNodeSequenceC32a.InnerText.Replace(Constants.CHRCOMMA, charDecimalSeparator), CultureInfo.InvariantCulture);
                            }
                        }
                        //Check if the field 19 is present or not
                        XmlNode xNodeField19 = xNodeSequence.SelectSingleNode(xPathField19);
                        if (Amount32aTotal.CompareTo(Amount32a) == 0 && xNodeField19 != null && xNodeField19.InnerText != null)
                        {
                            isError = true;
                        }
                        else if (!Amount32aTotal.Equals(Amount32a))
                        {
                            if (xNodeField19 == null || xNodeField19.InnerText == null)
                            {
                                isError = true;
                            }
                            else if (xNodeField19 != null && xNodeField19.InnerText != null && Amount32aTotal.CompareTo
                                (Convert.ToDouble(xNodeField19.InnerText.Replace(Constants.CHRCOMMA, charDecimalSeparator), CultureInfo.InvariantCulture)) != 0)
                            {
                                isError = true;
                            }
                        }
                        if (isError)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                conditionalRuleName, conditionalRuleNumber);
                            isValid = false;

                        }
                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        /// <method>
        ///		SWIFTNetworkRule267
        /// </method>
        /// <summary>
        ///		if field :97a::SAFE of Sequence A is Present and
        ///			If sequence B is present then Subsequence B2b1 is optional and
        ///				field :97a::SAFE is not allowed in any occurrence of subsequence B2b1
        ///		if field :97a::SAFE of Sequence A is NOT Present and
        ///			If sequence B is present then Subsequence B2b1 is mandatory and
        ///				field :97a::SAFE is Mandatory in all occurrences of subsequence B2b1
        ///			If sequence B and C are	not present then raise error E67
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSeqA">
        ///		Input reference of the element Sequence A to be validated
        ///		e.g. //SequenceA
        /// </param>
        /// <param name="xPathSeqATag97a">
        ///		Input reference of the element Tag 97a of Sequence A to be validated
        ///		e.g. ./Account_A_97A,./Account_A_97B
        /// </param>
        /// <param name="xpathSeqB">
        ///		Input reference of the element Sequence B or C to be validated
        ///		e.g. //SequenceB or //SequenceC
        /// </param>
        /// <param name="xpathSeqB2b1">
        ///		Input reference of the element Sequence B2b1 or C1c1 to be validated
        ///		e.g. //SequenceB2b1 or //SequenceC1c1
        /// </param>
        /// <param name="xpathSeqB2b1Tag97a">
        ///		Input reference of the element Tag 97a of Sequence B2b1 or C1c1 to be validated
        ///		e.g. ./Account_B2b1_97A,./Account_B2b1_97B or ./Account_C1c1_97A,./Account_C1c1_97B
        /// </param>
        /// <param name="xpathSeqB2b1Tag97aQualifier">
        ///		Input reference of the element Tag 97a qualifier of Sequence B2b1 or C1c1 to be validated
        ///		e.g. ./Qualifier
        /// </param>
        /// <param name="valueSeqB2b1Tag97aQualifier">
        ///		Input containing qualifier value of tag Tag 97a
        ///		e.g. SAFE
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT584
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule267(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSeqA,
            string xPathSeqATag97a,
            string xpathSeqB,
            string xpathSeqB2b1,
            string xpathSeqB2b1Tag97a,
            string xpathSeqB2b1Tag97aQualifier,
            string valueSeqB2b1Tag97aQualifier,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule267" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSeqA == null ||
                    xPathSeqATag97a == null ||
                    xpathSeqB == null ||
                    xpathSeqB2b1 == null ||
                    xpathSeqB2b1Tag97a == null ||
                    xpathSeqB2b1Tag97aQualifier == null ||
                    valueSeqB2b1Tag97aQualifier == null ||
                    xPathSeqA.Length == 0 ||
                    xPathSeqATag97a.Length == 0 ||
                    xpathSeqB.Length == 0 ||
                    xpathSeqB2b1.Length == 0 ||
                    xpathSeqB2b1Tag97a.Length == 0 ||
                    xpathSeqB2b1Tag97aQualifier.Length == 0 ||
                    valueSeqB2b1Tag97aQualifier.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //to check the existence of Tag 97A/97B of Sequence A
                XmlNode xNodeSeqA = xRoot.SelectSingleNode(xPathSeqA);

                bool isSeqATag97aExist = IsConditionSatisfied(xNodeSeqA, xPathSeqATag97a);

                if (isSeqATag97aExist == true)
                {
                    /*
                        If Tag 97A/97B of Sequence A is present then
                        Tag 97A/97B of Sequence B2b1 should not be present. if present then raise error
                     */
                    bool isTagPresent = false;

                    XmlNodeList xListSeqB2b1 = xRoot.SelectNodes(xpathSeqB2b1);
                    foreach (XmlNode xNodeSeqB2b1 in xListSeqB2b1)
                    {
                        isTagPresent = IsConditionSatisfied(xNodeSeqB2b1, xpathSeqB2b1Tag97a, xpathSeqB2b1Tag97aQualifier, valueSeqB2b1Tag97aQualifier);
                        if (isTagPresent == true)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                            break;
                        }
                    }
                }
                else
                {
                    /*
                            If Tag 97A/97B of Sequence A is NOT present and Sequence B is present then
                            subsequence B2b1 is mandatory else raise an error
                    */
                    XmlNode xNodeSeqB = xRoot.SelectSingleNode(xpathSeqB);
                    if (xNodeSeqB != null && xNodeSeqB.InnerText != null && xNodeSeqB.InnerText.Length != 0)
                    {
                        XmlNodeList xListSeqB2b1 = xRoot.SelectNodes(xpathSeqB2b1);
                        if (xListSeqB2b1.Count == 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                        else
                        {
                            /* If Subsequence B2b1 is present then
                                field 97A/97B of Sequence B2b1 having specified qualifier should be mandatory
                                in all occurences of subsequence B2b1 else raise an error
                            */
                            bool isSeqB2b1Tag97aQualifierExist = false;
                            foreach (XmlNode xNodeSeqB2b1 in xListSeqB2b1)
                            {
                                isSeqB2b1Tag97aQualifierExist = IsConditionSatisfied(xNodeSeqB2b1, xpathSeqB2b1Tag97a, xpathSeqB2b1Tag97aQualifier, valueSeqB2b1Tag97aQualifier);
                                if (isSeqB2b1Tag97aQualifierExist == false)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule267
        /// </method>
        /// <summary>
        ///		If Tag 97A/97B of Sequence A is NOT present and
        ///		Sequence B and C are not present then raise an error
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSeqA">
        ///		Input reference of the element Sequence A to be validated
        ///		e.g. //SequenceA
        ///	</param>
        /// <param name="xPathSeqATag97a">
        ///		Input reference of the element Tag 97a of Sequence A to be validated
        ///		e.g. ./Account_A_97A,./Account_A_97B
        /// </param>
        /// <param name="xpathSeqB">
        ///		Input reference of the element Sequence B to be validated
        ///		e.g. //SequenceB
        /// </param>
        /// <param name="xpathSeqC">
        ///		Input reference of the element Sequence C to be validated
        ///		e.g. //SequenceC
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT584
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule267(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSeqA,
            string xPathSeqATag97a,
            string xpathSeqB,
            string xpathSeqC,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule267" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSeqA == null ||
                    xPathSeqATag97a == null ||
                    xpathSeqB == null ||
                    xpathSeqC == null ||
                    xPathSeqA.Length == 0 ||
                    xPathSeqATag97a.Length == 0 ||
                    xpathSeqB.Length == 0 ||
                    xpathSeqC.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //to check the existence of Tag 97A/97B of Sequence A
                XmlNode xNodeSeqA = xRoot.SelectSingleNode(xPathSeqA);

                bool isSeqATag97aExist = IsConditionSatisfied(xNodeSeqA, xPathSeqATag97a);
                if (isSeqATag97aExist == false)
                {
                    XmlNodeList xListSeqB = xRoot.SelectNodes(xpathSeqB);
                    XmlNodeList xListSeqC = xRoot.SelectNodes(xpathSeqC);

                    if (xListSeqB.Count == 0 && xListSeqC.Count == 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule293
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 293 to
        ///		be implemented for the message MT507
        ///		It is mandatory to specify a Receiving Agent for the Securities Settlement Parties (subsequences B1a1):
        ///		In each occurrence of sequence B (if present), if subsequence B1a1 Securities Settlement Parties
        ///		is present, then field :95a::REAG must be present in one and only one occurrence of
        ///		subsequence B1a1 within the same occurrence of sequence B (Error Code E93).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the Sequence e.g. //Sequence
        /// </param>
        /// <param name ="xPathSubSequence" type = "string">
        ///		Input containing the xPath of the Subsequence e.g. ./SubSequence
        /// </param>
        /// <param name ="xPathTagList" type = "string">
        ///		Input containing the comma seperated xPaths of the element 95a
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the Qualifier value
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule293(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPathTagList,
            string qualifierValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule293" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    xPathTagList == null ||
                    xPathTagList.Length == 0 ||
                    qualifierValue == null ||
                    qualifierValue.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleNumber == null ||
                    errorObject == null)
                {
                    return false;
                }

                //Store the xPaths of the Tag 95a in an array
                string[] xPathArray = xPathTagList.Split(Constants.CHRCOMMA);

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of the Sequence
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    int presence = 0;

                    //Select all the nodes of the Subsequence
                    XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);

                    if (xListSubSequence.Count != 0)
                    {
                        foreach (XmlNode xNodeSubSequence in xListSubSequence)
                        {
                            //Check for each xPath of Tag 95a
                            for (int count = 0; count < xPathArray.Length; count++)
                            {
                                XmlNodeList xList = xNodeSubSequence.SelectNodes(xPathArray[count]);
                                if (xList.Count != 0)
                                {
                                    foreach (XmlNode xNode in xList)
                                    {
                                        //Check if the given Qualifer is present
                                        if (xNode.InnerText.CompareTo(qualifierValue) == 0)
                                            presence++;
                                    }
                                }
                            }
                        }

                        //If Qualifier is not present exactly once, throw an error
                        if (presence != 1)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule69
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 69 to
        ///		be implemented for the message MT507
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequenceB" type = "string">
        ///		Input containing the xPath of the Sequence B e.g. //SequenceB
        /// </param>
        /// <param name ="xPathSequenceB1" type = "string">
        ///		Input containing the xPath of the Sequence B1 e.g. ./SubSequenceB1
        /// </param>
        /// <param name ="xPathSubSequenceList" type = "string">
        ///		Input containing the comma separated xPaths of the Subsequences
        ///		e.g. ./SubSequenceB1a,./SubsequenceB1b
        /// </param>
        /// <param name ="xPathTag22H" type = "string">
        ///		Input containing the xPath of the element 22H e.g. ./xPathTag22H
        /// </param>
        /// <param name ="indicatorList" type = "string">
        ///		Input containing the comma separated list of Indicators
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule69(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathSequenceB1,
            string xPathSubSequenceList,
            string xPathTag22H,
            string indicatorList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule69" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPathSequenceB1 == null ||
                    xPathSequenceB1.Length == 0 ||
                    xPathSubSequenceList == null ||
                    xPathSubSequenceList.Length == 0 ||
                    xPathTag22H == null ||
                    xPathTag22H.Length == 0 ||
                    indicatorList == null ||
                    indicatorList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleNumber == null ||
                    errorObject == null)
                {
                    return false;
                }


                string indicator = string.Empty;

                //Store the xPaths os Subsequences in an array
                string[] xPathArray = xPathSubSequenceList.Split(Constants.CHRCOMMA);

                //Store the values of Indicators in an array
                string[] indicatorArray = indicatorList.Split(Constants.CHRCOMMA);

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of the Sequence B
                XmlNodeList xListSequenceB = xRoot.SelectNodes(xPathSequenceB);
                foreach (XmlNode xNodeSequenceB in xListSequenceB)
                {
                    //Select the node of the Sequence B1
                    XmlNode xNodeSequenceB1 = xNodeSequenceB.SelectSingleNode(xPathSequenceB1);
                    if (xNodeSequenceB1 != null)
                    {
                        //Select all the nodes of the Sequence B1a
                        XmlNodeList xListSequenceB1a = xNodeSequenceB1.SelectNodes(xPathArray[0]);

                        //Select all the nodes of the Sequence B1b
                        XmlNodeList xListSequenceB1b = xNodeSequenceB1.SelectNodes(xPathArray[1]);

                        //Select the node of the element 22H in Sequence B
                        XmlNode xNode22H = xNodeSequenceB.SelectSingleNode(xPathTag22H);
                        if (xNode22H != null && xNode22H.LastChild != null)
                        {
                            //Get the Indicator value
                            indicator = xNode22H.LastChild.InnerText;
                        }

                        if ((indicator.CompareTo(indicatorArray[0]) == 0 &&
                            (xListSequenceB1a.Count != 0 || xListSequenceB1b.Count == 0)) ||
                            (indicator.CompareTo(indicatorArray[1]) == 0 &&
                            (xListSequenceB1a.Count == 0 || xListSequenceB1b.Count != 0)))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule70
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 70 to
        ///		be implemented for the message MT507
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the Sequence
        /// </param>
        /// <param name ="xPathSubSequence" type = "string">
        ///		Input containing the xPath of the Subsequence
        /// </param>
        /// <param name ="xPathTag25D" type = "string">
        ///		Input containing the xPath of the element 25D
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Input containing the xPath of the Data Source Scheme element
        /// </param>
        /// <param name ="statusCodeList" type = "string">
        ///		Input containing the comma separated list of Status Codes
        /// </param>
        /// <param name ="xPathTag22H" type = "string">
        ///		Input containing the xPath of the element 22H
        /// </param>
        /// <param name ="indicatorList" type = "string">
        ///		Input containing the comma separated list of Indicators
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditional rule name
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditional rule number
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule70(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPathTag25D,
            string xPathDataSourceScheme,
            string statusCodeList,
            string xPathTag22H,
            string indicatorList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule70" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    xPathTag25D == null ||
                    xPathTag25D.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    statusCodeList == null ||
                    statusCodeList.Length == 0 ||
                    xPathTag22H == null ||
                    xPathTag22H.Length == 0 ||
                    indicatorList == null ||
                    indicatorList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    messageType == null ||
                    messageType.Length == 0 ||
                    conditionalRuleName == null ||
                    conditionalRuleNumber == null ||
                    errorObject == null)
                {
                    return false;
                }


                //Store all the Status Codes in an array
                string[] statusCodeArray = statusCodeList.Split(Constants.CHRCOMMA);

                //Store all the Indicators in an array
                string[] indicatorArray = indicatorList.Split(Constants.CHRCOMMA);

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of the Sequence
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    //Select the node of the element 25D
                    XmlNode xNode25D = xNodeSequence.SelectSingleNode(xPathTag25D);

                    //Select the node of the element 22H
                    XmlNode xNode22H = xNodeSequence.SelectSingleNode(xPathTag22H);

                    //Select all the nodes of the Subsequence
                    XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);

                    if (xNode22H != null &&
                        xNode22H.LastChild != null &&
                        xNode25D != null &&
                        xNode25D.LastChild != null &&
                        ((xNode22H.LastChild.InnerText.CompareTo(indicatorArray[0]) == 0 &&
                          xListSubSequence.Count != 0) ||
                            (xNode25D.SelectSingleNode(xPathDataSourceScheme) == null &&
                             ((xNode25D.LastChild.InnerText.CompareTo(statusCodeArray[1]) == 0 &&
                               xListSubSequence.Count != 0) ||
                              (xNode25D.LastChild.InnerText.CompareTo(statusCodeArray[0]) == 0 &&
                               (xNode22H.LastChild.InnerText.CompareTo(indicatorArray[1]) == 0 ||
                                xNode22H.LastChild.InnerText.CompareTo(indicatorArray[2]) == 0) &&
                                xListSubSequence.Count == 0)))))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType,
                            conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        ///<method>
        ///		SWIFTNetworkRule71_SRG2006
        /// </method>
        /// <summary>
        /// In each occurrence of given sequence , given field with a prticular qualifier is not allowed to be repeated more than once.
        /// When repeated, one occurrence must have Quantity Type Code FAMT and the other occurrence must have 
        /// Quantity Type Code AMOR
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        ///		Reference path of the sequence
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Reference path of the Qualifier field.
        /// </param>
        /// <param name ="qualifier" type = "string">
        ///		Input containing the qualifier .
        /// </param>
        /// <param name ="xPathQuantityTypeCode" type = "string">
        ///		Input containing the QuantityTypeCode list.
        /// </param>
        /// <param name ="QuantityTypeCodeList" type = "string">
        ///		Input containing the QuantityTypeCode list.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule71_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath,
            string xPathQualifier,
            string qualifier,
            string xPathQuantityTypeCode,
            string QuantityTypeCodeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule71_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isError = true;
            // fieldCount is used to check for the multiple presence of given element.
            int fieldCount = 0;
            // arraylist is used for storing all the values of the QuantityTypeCode in the input field.
            ArrayList alistQuantitypeCode = new ArrayList();
            // checkCodesPresent is used to keep track of how many  codes passed in the function are
            // actually present in the Nodes.
            int checkCodesPresent = 0;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    qualifier == null ||
                    qualifier.Length == 0 ||
                    xPathQuantityTypeCode == null ||
                    xPathQuantityTypeCode.Length == 0 ||
                    QuantityTypeCodeList == null ||
                    QuantityTypeCodeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTag = xRoot.SelectNodes(xPathSequence);

                // Getting the array of the QuantityTypeCode codes passed
                string[] QuantityTypeCodeListArray = QuantityTypeCodeList.Split(Constants.CHRCOMMA);
                int lengthQuantityTypeCode = QuantityTypeCodeListArray.Length;

                //string x36BIndicator = string.Empty;

                foreach (XmlNode xNode in xListTag)
                {
                    // Selecting the nodes for input field 
                    XmlNodeList xNodeList = xNode.SelectNodes(xPath);
                    foreach (XmlNode xFieldNode in xNodeList)
                    {
                        // Comparing for the input qualifier in the nodes.
                        if (
                            xFieldNode != null &&
                            xFieldNode.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifier) == 0
                            )
                        {
                            // If the qualifier is same as there in input, then adding the Quantity Type Code in an Arraylist.
                            alistQuantitypeCode.Add(xFieldNode.SelectSingleNode(xPathQuantityTypeCode).InnerText);
                            // Incrementing the field count by 1
                            fieldCount += 1;
                        }

                    }
                    // Only if fieldCount is 2 the rule validates further
                    if (fieldCount == 2)
                    {
                        for (int i = 0; i <= lengthQuantityTypeCode - 1; i++)
                        {
                            if (alistQuantitypeCode.IndexOf(QuantityTypeCodeListArray[i]) != -1)
                            {
                                checkCodesPresent += 1;
                            }
                        }
                        if (checkCodesPresent != lengthQuantityTypeCode)
                        {
                            isValid = false;
                        }
                    }
                    // else fieldcount > 2 the rule will fail
                    else if (fieldCount > 2)
                    {
                        isValid = false;
                    }
                    if (!isValid)
                    {
                        isError = false;
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    }
                    fieldCount = 0;
                    checkCodesPresent = 0;
                    alistQuantitypeCode.Clear();
                    isValid = true;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isError;
        }

        ///<method>
        ///		SWIFTNetworkRule72_SRG2006
        /// </method>
        /// <summary>
        /// In each occurrence of subsequence C2, field :36B::PSTA is not allowed to be repeated more than once.
        /// When repeated, one occurrence must have Quantity Type Code FAMT and the other occurrence must have 
        /// Quantity Type Code AMOR (Error code(s): C72).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        ///		Reference path of the sequence
        /// </param>
        /// <param name ="xPath36B" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Reference path of the Qualifier field.
        /// </param>
        /// <param name ="qualifierPSTA" type = "string">
        ///		Input containing the qualifier PSTA.
        /// </param>
        /// <param name ="xPathQuantityTypeCode" type = "string">
        ///		Input containing the QuantityTypeCode list.
        /// </param>
        /// <param name ="QuantityTypeCodeList" type = "string">
        ///		Input containing the QuantityTypeCode list.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule72_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath36B,
            string xPathQualifier,
            string qualifierPSTA,
            string xPathQuantityTypeCode,
            string QuantityTypeCodeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule72_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool isError = true;
            // fieldCount is used to check for the multiple presence of 36 B with PSTA
            int fieldCount = 0;
            // arraylist is used for storing all the values of the QuantityTypeCode in the field 36B with PSTA
            ArrayList alistQuantitypeCode = new ArrayList();
            // checkCodesPresent is used to keep track of how many  codes passed in the function are
            // actually present in the Nodes.
            int checkCodesPresent = 0;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath36B == null ||
                    xPath36B.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    qualifierPSTA == null ||
                    qualifierPSTA.Length == 0 ||
                    xPathQuantityTypeCode == null ||
                    xPathQuantityTypeCode.Length == 0 ||
                    QuantityTypeCodeList == null ||
                    QuantityTypeCodeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListTag = xRoot.SelectNodes(xPathSequence);

                // Getting the array of the QuantityTypeCode codes passed
                string[] QuantityTypeCodeListArray = QuantityTypeCodeList.Split(Constants.CHRCOMMA);
                int lengthQuantityTypeCode = QuantityTypeCodeListArray.Length;

                //string x36BIndicator = string.Empty;

                foreach (XmlNode xNode in xListTag)
                {
                    // Selecting the nodes for field 36B
                    XmlNodeList xNodeList36B = xNode.SelectNodes(xPath36B);
                    foreach (XmlNode xNode36B in xNodeList36B)
                    {
                        // Comparing for the qualifier PSTA in the nodes.
                        if (
                            xNode36B != null &&
                            xNode36B.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifierPSTA) == 0
                            )
                        {
                            // If the qualifier is PSTA then adding the Quantity Type Code in an Arraylist.
                            alistQuantitypeCode.Add(xNode36B.SelectSingleNode(xPathQuantityTypeCode).InnerText);
                            // Incrementing the field count by 1
                            fieldCount += 1;
                        }

                    }
                    // Only if fieldCount is 2 the rule validates further
                    if (fieldCount == 2)
                    {
                        for (int i = 0; i <= lengthQuantityTypeCode - 1; i++)
                        {
                            if (alistQuantitypeCode.IndexOf(QuantityTypeCodeListArray[i]) != -1)
                            {
                                checkCodesPresent += 1;
                            }
                        }
                        if (checkCodesPresent != lengthQuantityTypeCode)
                        {
                            isValid = false;
                        }
                    }
                    // else fieldcount > 2 the rule will fail
                    else if (fieldCount > 2)
                    {
                        isValid = false;
                    }
                    if (!isValid)
                    {
                        isError = false;
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    }
                    fieldCount = 0;
                    checkCodesPresent = 0;
                    alistQuantitypeCode.Clear();
                    isValid = true;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isError;
        }

        /// <method>
        /// 	CheckCodeFormat
        /// </method>
        /// <summary>
        ///		This function retrieves the Code and its Format from the given input string
        ///		of ValueCodesFormat and checks the valid format for a given code.
        /// </summary>
        /// <param name="strLine">
        /// 	The input string.
        /// </param>
        /// <param name="valueCodesFormat">
        /// 	CodesFormatList
        /// </param>
        /// <param name="valueCodesEnumlist">
        /// 	CodesEnumlist
        /// </param>
        /// <param name="currencyAmountList">
        /// 	CurrencyAmountList
        /// </param>
        /// <param name="valueCHGS">
        /// 	CHGS
        /// </param>
        /// <param name="valueOCMT">
        /// 	OCMT
        /// </param>
        /// <param name="errorCode">
        /// 	Error Code
        /// </param>
        /// <param name="policyName">
        /// 	Policy Name
        /// </param>
        /// <param name="ruleName">
        /// 	Rule Name
        /// </param>
        /// <param name="errorObject">
        /// 	Error Object
        /// </param>
        /// <returns>
        /// 	boolean return value
        /// </returns>
        public static bool CheckCodeFormat(string strLine,
            string valueCodesFormat,
            string valueCodesEnumlist,
            //string currencyAmountList,
            string valueOCMT,
            string valueCHGS,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckCodeFormat" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (strLine == null ||
                    valueCodesFormat == null ||
                    //currencyAmountList == null ||
                    valueCodesEnumlist == null ||
                    valueOCMT == null ||
                    valueCHGS == null ||
                    valueCHGS.Length == 0 ||
                    valueOCMT.Length == 0 ||
                    strLine.Length == 0 ||
                    valueCodesEnumlist.Length == 0 ||
                    valueCodesFormat.Length == 0 ||
                    //currencyAmountList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //Split the Code-format pair into Array variable
                string[] strArray = valueCodesFormat.Split(Constants.CHRCOMMA);
                int nArrayCount = strArray.Length;

                //Split the Code-EnumList pair into Array variable
                string[] strCodeEnumArray = valueCodesEnumlist.Split(Constants.CHRCOMMA);
                int nCodeEnumArrayCount = strCodeEnumArray.Length;
                string strCodes = string.Empty;

                //Put code and its Enumeration list into Hashtable.
                Hashtable htCodeEnum = new Hashtable();

                for (int nCount = 0; nCount <= nCodeEnumArrayCount - 1; nCount++)
                {
                    string[] strTagEnumArray = strCodeEnumArray[nCount].Split(Constants.CHRASTERISK);
                    htCodeEnum.Add(strTagEnumArray[0].ToString(), strTagEnumArray[1].ToString());
                }

                //Put code and its format into Hashtable.
                Hashtable htCodeFormat = new Hashtable();

                for (int nCount = 0; nCount <= nArrayCount - 1; nCount++)
                {
                    string[] strTagFormat = strArray[nCount].Split(Constants.CHRPIPE);
                    htCodeFormat.Add(strTagFormat[0].ToString(), strTagFormat[1].ToString());
                    strCodes = strCodes + strTagFormat[0].ToString() + Constants.COMMA;
                }

                string strCodeExists = string.Empty;
                strCodeExists = strCodes;
                int positionOCMT = strLine.IndexOf(valueOCMT);
                int positionCHGS = strLine.IndexOf(valueCHGS);

                if (positionOCMT >= 0 || positionCHGS >= 0)
                {
                    string strLine1 = string.Empty;
                    if (strLine.EndsWith(Constants.SLASH))
                    {
                        strLine1 = strLine.TrimEnd(Constants.CHRSLASH);
                    }
                    if (CheckSlashes(strLine1) == false)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            strLine, Constants.SLASH);
                        return false;

                    }

                }
                else if (CheckSlashes(strLine) == false)
                {
                    errorObject.AddError(errorCode, policyName, ruleName,
                        strLine, Constants.SLASH);
                    return false;

                }

                // Form a code-value pair of XML Document into two set of array variables
                string[] strResult = strLine.Split(Constants.CHRSLASH);
                if (strLine.IndexOf(valueOCMT) != -1 && strLine.EndsWith(Constants.SLASH) ||
                    strLine.IndexOf(valueCHGS) != -1 && strLine.EndsWith(Constants.SLASH))
                {
                    strResult[strResult.Length - 2] = strResult[strResult.Length - 2] + Constants.CHRSLASH;
                }

                int nResultCount = strResult.Length;

                // The variable strResultCodeArray will contain the list of codes
                string[] strResultCodeArray = new string[nResultCount / 2];
                // The variable strResultValueArray will contain the value corresponding to the respective Code.
                string[] strResultValueArray = new string[nResultCount / 2];

                int nResultCode = 0;
                int nResultValue = 0;

                for (int countResult = 1; countResult <= nResultCount - 1; countResult++)
                {
                    if ((countResult % 2) != 0)
                    {
                        strResultCodeArray[nResultCode] = Constants.SLASH + strResult[countResult].ToString() + Constants.SLASH;

                        nResultCode++;
                    }
                    else
                    {
                        strResultValueArray[nResultValue] = strResult[countResult].ToString();
                        nResultValue++;
                    }
                }

                string strFormat = string.Empty;
                string currencyAmount = string.Empty;
                string currencyCode = string.Empty;
                string amountValue = string.Empty;
                string strCodeCheck = string.Empty;

                //			string[] data = currencyAmountList.Split(Constants.CHRPIPE);
                //			Hashtable currencyList = new Hashtable();
                //			BuildCurrencyList(data,ref currencyList);

                //For each code of Xml document, check the corresponding format from Hash table
                // Check the data type and max length of value of each code of xml doc
                for (int countFormat = 0; countFormat <= strResultCodeArray.Length - 1; countFormat++)
                {
                    //Get the format of code from hash table
                    strFormat = GetFormatValue(htCodeFormat, strResultCodeArray[countFormat]);
                    if (strFormat.CompareTo(string.Empty) != 0)
                    {
                        // b. checking for non-repititiveness of codes
                        if (strCodeExists.IndexOf(strResultCodeArray[countFormat]) == -1)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                strFormat, strResultCodeArray[countFormat]);
                            return false;
                        }
                        else
                        {
                            strCodeCheck = strResultCodeArray[countFormat].ToString();
                            strCodeCheck = strCodeCheck + Constants.COMMA;
                            strCodeExists = strCodeExists.Replace(strCodeCheck, Constants.BLANK);

                        }

                        // c. Checking for valid code format
                        if (strFormat.CompareTo(Constants.ALPHAg) == 0)
                        {
                            currencyAmount = strResultValueArray[countFormat];
                            currencyCode = currencyAmount.Substring(0, 3);
                            amountValue = currencyAmount.Substring(3);

                            Regex reg = new Regex(Constants.GPATTERN);
                            if (!reg.IsMatch(strResultValueArray[countFormat]))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    strResultCodeArray[countFormat], strResultValueArray[countFormat]);
                                return false;
                            }
                            if (reg.IsMatch(strResultValueArray[countFormat]))
                            {
                                isValid = CheckCurrencyAmount(currencyCode, amountValue, true,
                                    true, true, errorCode, Constants.ELEMENTCURRENCYNAME, strFormat, ruleName, policyName,
                                    errorObject);
                            }
                        }
                        // check for valid date format
                        else if (strFormat.CompareTo(Constants.ALPHAdate6) == 0)
                        {
                            Regex reg = new Regex(Constants.DATE6PATTERN);
                            if (!reg.IsMatch(strResultValueArray[countFormat]))
                            {
                                //Raise error if value of code does not satisfy the format.
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    strResultCodeArray[countFormat], strResultValueArray[countFormat]);
                            }
                            if (reg.IsMatch(strResultValueArray[countFormat]))
                            {

                                if (strResultValueArray[countFormat].Length.ToString(CultureInfo.InvariantCulture)
                                    != strFormat.Substring(0, 1))
                                {
                                    //Raise error if value of code does not satisfy the format.
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        strResultCodeArray[countFormat], strResultValueArray[countFormat]);
                                }
                            }

                        }

                        else if (strFormat.CompareTo(Constants.ALPHAcurrency) == 0)
                        {
                            currencyCode = strResultValueArray[countFormat];
                            amountValue = string.Empty;
                            Regex reg = new Regex(Constants.CURRENCYPATTERN);
                            if (!reg.IsMatch(strResultValueArray[countFormat]))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    strResultCodeArray[countFormat], strResultValueArray[countFormat]);
                                return false;
                            }

                            if (reg.IsMatch(strResultValueArray[countFormat]))
                            {

                                if (!SqlConnector.hashCurrencyCodeList.Contains(currencyCode))
                                {
                                    //								errorObject.AddError(errorCode, policyName, ruleName,
                                    //									strResultCodeArray[countFormat], strResultValueArray[countFormat]);
                                    return false;
                                }
                            }

                        }

                        else if (strFormat.CompareTo(Constants.ALPHAh) == 0)
                        {
                            currencyAmount = strResultValueArray[countFormat].TrimEnd(Constants.CHRSLASH);
                            currencyCode = currencyAmount.Substring(0, 3);
                            amountValue = currencyAmount.Substring(3);

                            Regex reg = new Regex(Constants.HPATTERN);
                            if (!reg.IsMatch(strResultValueArray[countFormat]))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    strResultCodeArray[countFormat], strResultValueArray[countFormat]);
                                return false;
                            }
                            if (reg.IsMatch(strResultValueArray[countFormat]))
                            {
                                isValid = CheckCurrencyAmount(currencyCode, amountValue, true,
                                    true, true, errorCode, Constants.ELEMENTCURRENCYNAME, strFormat, ruleName, policyName,
                                    errorObject);
                            }
                        }
                        else if (IsValidCodeFormatData(strResultValueArray[countFormat], strFormat) == false)
                        {
                            //Raise error if value of code does not satisfy the format.
                            errorObject.AddError(errorCode, policyName, ruleName,
                                strResultCodeArray[countFormat], strResultValueArray[countFormat]);
                            return false;
                        }

                        // e. if code /ACDS/ occurs in the data then check for its valid 4a enums
                        string strEnumList = GetFormatValue(htCodeEnum, strResultCodeArray[countFormat]);
                        if (strEnumList != string.Empty)
                        {
                            if (strEnumList.IndexOf(strResultValueArray[countFormat]) == -1)
                            {
                                //Raise error if value in xml doc does not exist in enum list
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    strFormat, strResultCodeArray[countFormat]);
                                return false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;
        }

        ///<method>
        ///		SWIFTSRG2001NetworkRule50
        ///</method>
        /// <summary>
        /// If field 35A and/or field 83a is present, the field 18A following that repetitive sequence
        /// must also be present (Error code(s): C50).
        /// Conversely, this field 18A may only be present if at least one of the preceding fields
        /// 35A or 83a is present (Error code(s): C50).
        /// </summary>
        /// <param name="xDocument">Input containing the XML Document Instance</param>
        /// <param name="xPath35A">Input containing the xPath of 35A Tag</param>
        /// <param name="xPath18A">Input containing the xPath of 18A Tag</param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Inutput containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        //public static bool SWIFTSRG2001NetworkRule50(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPath35A,
        //    string xPath18A,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    string messageType,
        //    string conditionalRuleName,
        //    string conditionalRuleNumber,
        //    ErrorCollection errorObject)
        //{

        //    if(xDocument == null ||
        //        xPath35A == null ||
        //        xPath35A.Length == 0 ||
        //        xPath18A == null ||
        //        xPath18A.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;
        //    }
        //    else
        //    {
        //        bool isValid = true;
        //        int sequenceCount = 0;
        //        int Tag18ACount = 0;
        //        //Select the root node
        //        XmlNode xRoot = xDocument.Document;
        //        //loop to check the number of repetitive Subsequence present
        //        XmlNodeList xList35A = xRoot.SelectNodes(xPath35A);
        //        if(xList35A.Count != 0)
        //        {
        //            foreach(XmlNode xNode in xList35A)
        //            {
        //                if(xNode != null &&
        //                    xNode.InnerText != null &&
        //                    xNode.InnerText.Length != 0)
        //                {
        //                    sequenceCount++;
        //                }
        //            }
        //        }
        //        //loop to check the number of 18A is present following the sequence
        //        XmlNodeList xList18A = xRoot.SelectNodes(xPath18A);
        //        if(xList18A.Count != 0)
        //        {
        //            foreach(XmlNode xNode in xList18A)
        //            {
        //                if(xNode != null &&
        //                    xNode.InnerText != null &&
        //                    xNode.InnerText.Length != 0)
        //                {
        //                    Tag18ACount++;
        //                }
        //            }
        //        }
        //        if(sequenceCount != 0 && Tag18ACount == 0)
        //        {
        //            errorObject.AddError(errorCode,policyName,ruleName,messageType,
        //                conditionalRuleName,conditionalRuleNumber);
        //            isValid = false;
        //        }
        //        else if(Tag18ACount != 0 && sequenceCount == 0)
        //        {
        //            errorObject.AddError(errorCode,policyName,ruleName,messageType,
        //                conditionalRuleName,conditionalRuleNumber);
        //            isValid = false;
        //        }
        //        return isValid;
        //    }
        //}

        /// <method>
        /// 	IsConditionSatisfied
        /// </method>
        /// <summary>
        /// 	This Function checks presence of Tag2 with particular value of
        /// 	Field1.
        /// </summary>
        /// <param name="xSequenceNode" type = "string">
        /// 	Input Reference of Sequence in which validation is to be performed.
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// 	Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="valueTag2" type = "string">
        /// 	Value of Field1 of Tag1
        /// </param>
        /// <returns>
        /// 	Boolean
        /// </returns>
        private static bool IsConditionSatisfied(XmlNode xSequenceNode,
            string xPathTag2List,
            string valueTag2)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsConditionSatisfied:");
            try
            {
                string[] xPathTag2ListArray = xPathTag2List.Split(
                    Constants.CHRCOMMA);
                XmlNodeList xNodeListTag2;
                string[] strArray = valueTag2.Split(Constants.CHRCOMMA);

                foreach (string qualifier in xPathTag2ListArray)
                {
                    xNodeListTag2 = xSequenceNode.SelectNodes(qualifier);
                    foreach (XmlNode xNode in xNodeListTag2)
                    {
                        foreach (string code in strArray)
                        {
                            if (xNode.InnerText.IndexOf(code) != -1)
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return false;

        }

        /// <method>
        /// 	CheckPresence
        /// </method>
        /// <summary>
        /// 	This method checks the presence of Tag2 with specified value of
        /// 	Field1 in SeqeunceX when Tag1 with Specified values of field1
        /// 	SequenceY.
        /// 	The check performed depends on value Of isPresent, which
        /// 	is passed as boolean parameter. if isPresent is true then
        /// 	check is performed for tag2 being MANDATORY in Sequence Y
        /// 	and when isPresent is false check is performed for tag2
        /// 	being NOT ALLOWED in SequenceY
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence1" type = "string">
        ///		Input reference of the sequence1 in which validation is to
        ///		performed.
        /// </param>
        /// <param name ="xPathSequence2" type = "string">
        ///		Input reference of the sequence2 in which validation is to
        ///		performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        /// 	Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        /// 	Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field1" type = "string">
        /// 	Value of Field2 of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// 	Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="valueTag2" type = "string">
        /// 	Value of Field1 of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        /// 	Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// 	boolean whose value depends upon the success of check performed.
        ///</returns>
        public static bool CheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence1,
            string xPathSequence2,
            string xPathTag1List,
            string xPathTag1Field1,
            string valueTag1Field1,
            bool isPresent,
            string xPathTag2List,
            string valueTag2)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckPresence:");
            try
            {

                if (xPathSequence1 == null ||
                    xPathSequence1.Length == 0 ||
                    xPathSequence2 == null ||
                    xPathSequence2.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0 ||
                    xPathTag1Field1 == null ||
                    xPathTag1Field1.Length == 0 ||
                    valueTag1Field1 == null ||
                    valueTag1Field1.Length == 0 ||
                    valueTag2 == null ||
                    valueTag2.Length == 0
                    )
                {
                    return false;
                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence1 = xRoot.SelectNodes(xPathSequence1);
                XmlNodeList xListSequence2 = xRoot.SelectNodes(xPathSequence2);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;


                foreach (XmlNode xSequenceNode1 in xListSequence1)
                {
                    foreach (XmlNode xSequenceNode2 in xListSequence2)
                    {
                        isTag1ConditionValid = IsConditionSatisfied(xSequenceNode1, xPathTag1List, xPathTag1Field1, valueTag1Field1);

                        isTag2ConditionValid = IsConditionSatisfied(xSequenceNode2, xPathTag2List, valueTag2);

                        if (isTag1ConditionValid & (isTag2ConditionValid ^ isPresent))
                        {
                            return false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;

        }

        /// <method>
        ///		IsValidCollateralDetails
        /// </method>
        /// <summary>
        ///		This method performs validation for the presence of Sequence B
        ///		with Rejected Collateral Details
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input containing the xPath of the Sequence B e.g. //SequenceB
        /// </param>
        /// <param name ="xPathTag25D" type = "string">
        ///		Input containing the xPath of the Tag 25D e.g. ./Status_B_25D
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Input containing the xPath of the Data Source Scheme e.g. ./DataSource/DataSourceScheme
        /// </param>
        /// <param name ="valueStatusCode" type = "string">
        ///		Input containing the value of the Status Code
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidCollateralDetails(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag25D,
            string xPathDataSourceScheme,
            string valueStatusCode)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCollateralDetails:");
            bool presence = false;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag25D == null ||
                    xPathTag25D.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    valueStatusCode == null ||
                    valueStatusCode.Length == 0)
                {
                    return false;
                }



                XmlNode xRoot = xDocument.Document;
                //Select all the nodes of the Sequence
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    //Select the node of the Tag 25D
                    XmlNode Node25D = xNodeSequence.SelectSingleNode(xPathTag25D);

                    //Check for the presence of Data Source Scheme and value
                    //of Status Code
                    if (Node25D != null && Node25D.LastChild != null &&
                        Node25D.SelectSingleNode(xPathDataSourceScheme) == null &&
                        Node25D.LastChild.InnerText.CompareTo(valueStatusCode) == 0)
                    {
                        presence = true;
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return presence;
        }

        /// <method>
        /// 	CheckPresence
        /// </method>
        /// <summary>
        /// 	This method checks the presence of Tag2 with specified value of
        /// 	Field1 in SeqeunceX when Tag1 with Specified values of field1
        /// 	is present in SequenceX.
        /// 	The check performed depends on value Of isPresent, which
        /// 	is passed as boolean parameter. if isPresent is true then
        /// 	check is performed for tag2 being MANDATORY in Sequence Y
        /// 	and when isPresent is false check is performed for tag2
        /// 	being NOT ALLOWED in SequenceY
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the sequence in which validation is to
        ///		performed.
        ///	</param>
        /// <param name="xPathTag1List" type = "string" >
        /// 	Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="value1Tag1" type = "string">
        /// 	Value of Field1 of Tag1
        /// </param>
        /// <param name="isPresent1" type = "boolean">
        /// 	Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <param name="isPresent2" type = "boolean">
        /// 	Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <param name="value2Tag1" type = "string">
        /// 	Value of Field2 of Tag1
        /// </param>
        /// <returns>
        /// 	boolean whose value depends upon the success of check performed.
        ///</returns>
        public static bool CheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathTag1List,
            string value1Tag1,
            bool isPresent1,
            bool isPresent2,
            string value2Tag1)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckPresence:");
            try
            {
                if (xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    value1Tag1 == null ||
                    value1Tag1.Length == 0 ||
                    value2Tag1 == null ||
                    value2Tag1.Length == 0
                    )
                {
                    return false;
                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;

                foreach (XmlNode xSequenceNode in xListSequence)
                {
                    isTag1ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag1List, value1Tag1);

                    isTag2ConditionValid = IsConditionSatisfied(xSequenceNode, xPathTag1List, value2Tag1);

                    if (!(isPresent1 ^ isTag1ConditionValid) & (isTag2ConditionValid ^ isPresent2))
                    {
                        return false;

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return true;
        }

        /// <method>
        ///		CheckNoPresence
        /// </method>
        /// <summary>
        ///		This method checks the presence of Tag2 with specified value of
        ///		 Field1 in particular occurance of SeqeunceX when Tag1 with
        ///		 Specified values of field1 and field2 is NOT present in SAME
        ///		OCCURANCE of SequenceY. The check performed depends on
        ///		 value Of isPresent, which is passed as boolean parameter.
        ///		 if isPresent is true then check is performed for tag2 being
        ///		 MANDATORY in Sequence X and when isPresent is false check is
        ///		 performed for tag2 being NOT ALLOWED in SequenceY
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence1" type = "string">
        ///		Input reference of the sequence in which validation is to
        ///		performed.
        /// </param>
        /// <param name ="xPathSequence2" type = "string">
        ///		Input reference of the sequence in which validation is to
        ///		performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        ///		Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        ///		Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag1Field1" type = "string">
        ///		Value of Field1 of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        ///		Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="valueTag2" type = "string">
        ///		Value of Field1 of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        ///		Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        ///		boolean whose value depends upon the success of check performed.
        ///</returns>
        public static bool CheckNoPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence1,
            string xPathSequence2,
            string xPathTag1List,
            string xPathTag1Field1,
            string xPathTag2List,
            bool isPresent,
            string valueTag1Field1,
            string valueTag2)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckNoPresence:");
            try
            {
                if (xPathSequence1 == null ||
                    xPathSequence1.Length == 0 ||
                    xPathSequence2 == null ||
                    xPathSequence2.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0 ||
                    xPathTag1Field1 == null ||
                    xPathTag1Field1.Length == 0 ||
                    valueTag1Field1 == null ||
                    valueTag1Field1.Length == 0 ||
                    valueTag2 == null ||
                    valueTag2.Length == 0
                    )
                {
                    return false;

                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence1 = xRoot.SelectNodes(xPathSequence1);
                XmlNodeList xListSequence2 = xRoot.SelectNodes(xPathSequence2);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;

                foreach (XmlNode xSequenceNode1 in xListSequence1)
                {
                    foreach (XmlNode xSequenceNode2 in xListSequence2)
                    {

                        isTag1ConditionValid = IsConditionSatisfied(xSequenceNode1, xPathTag1List, xPathTag1Field1, valueTag1Field1);

                        isTag2ConditionValid = IsConditionSatisfied(xSequenceNode2, xPathTag2List, valueTag2);


                        if (!isTag1ConditionValid & (isTag2ConditionValid ^ isPresent))
                        {
                            return false;

                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;
        }

        /// <method>
        /// 	SWIFTNetworkRule291
        /// </method>
        /// <summary>
        /// 	This function performs the validation for SWIFT network rule 291
        /// 	It is mandatory to specify a Delivering Agent for the Securities Settlement Parties
        /// 	(subsequences C1a1 and D1):In each occurrence of sequence C, if subsequence C1a1
        /// 	Securities Settlement Parties is present, then field :95a::DEAG must be present
        /// 	in one and only one occurrence of subsequence C1a1 (Error code(s): E91) within the same occurrence.																																																									of sequence C.
        /// </summary>
        /// <param name="xDocument">
        /// 	A4SWIFTXmlDocument
        /// </param>
        /// <param name="xPathSequence">
        /// 	xPath Of Sequence
        /// 	eg: //SequenceC
        /// </param>
        /// <param name="xPathSubSequence">
        /// 	Complete xPath of subsequence C1a1
        /// 	eg:./SequenceC1/SequenceC1a/SequenceC1a1
        /// </param>
        /// <param name="xPathTag">
        /// 	xPath of Tag
        /// 	./Party_C1a1_95P/Qualifier,./Party_C1a1_95P/Qualifier..
        /// </param>
        /// <param name="qualifierValue">
        /// 	Value of the qualifier
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="ruleName">
        /// 	ruleName
        /// </param>
        /// <param name="policyName">
        /// 	policyName
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	conditionalRuleName
        /// </param>
        /// <param name="messageType">
        /// 	messageType
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	conditionalRuleNumber
        /// </param>
        /// <param name="errorObj">
        /// 	Error Object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool SWIFTNetworkRule291(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPathTag,
            string qualifierValue,
            string errorCode,
            string ruleName,
            string policyName,
            string conditionalRuleName,
            string messageType,
            ErrorCollection errorObj,
            string conditionalRuleNumber)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule291" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    qualifierValue == null ||
                    qualifierValue.Length == 0)
                {
                    return false;
                }

                if (null == errorObj) throw new ArgumentNullException("errorObj");

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xNodeSequenceList = xRoot.SelectNodes(xPathSequence);
                string[] xPathTagList = xPathTag.Split(Constants.CHRCOMMA);
                string tempQualifierValue = string.Empty;

                foreach (XmlNode xNodeSequence in xNodeSequenceList)
                {
                    tempQualifierValue = qualifierValue;

                    XmlNodeList xSubSequenceNodeList = xNodeSequence.SelectNodes(xPathSubSequence);

                    foreach (XmlNode xSubSequencNode in xSubSequenceNodeList)
                    {
                        foreach (string xPath in xPathTagList)
                        {
                            XmlNodeList xNodeList = xSubSequencNode.SelectNodes(xPath);

                            foreach (XmlNode xNode in xNodeList)
                            {
                                if (xNode.InnerText != null && xNode.InnerText.CompareTo(qualifierValue) == 0)
                                {
                                    if (tempQualifierValue == Constants.BLANK)
                                    {
                                        errorObj.AddError(errorCode, policyName, ruleName, messageType,
                                            conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                    }

                                    // suriyan - 2/10/2006 - preSharp warning 56506 - tempQualififierValue can be null - how?
                                    //#pragma warning suppress 6506
                                    if (tempQualifierValue.CompareTo(Constants.BLANK) != 0)
                                        tempQualifierValue = Constants.BLANK;
                                }
                            }
                        }
                    }

                    if (xSubSequenceNodeList.Count != 0 && (tempQualifierValue.CompareTo(Constants.BLANK)) != 0)
                    {
                        errorObj.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName,
                            conditionalRuleNumber);
                        isValid = false;
                    }
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	IsValidYear
        /// </method>
        /// <summary>
        /// 	This function returns true if the text of the tag specified is a valid year in YYYY format i.e
        /// 	between "0001" and "9999".
        /// </summary>
        /// <param name="xDocument">
        /// 	A4SWIFTXmlDocument
        /// </param>
        /// <param name="xPath">
        /// 	xPath Of Tag
        /// 	eg: //Indicator_A1_22F/Indicator
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        //public static bool IsValidYear(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPath)
        //{
        //    if(xDocument == null ||
        //        xPath == null ||
        //        xPath.Length == 0)
        //    {
        //        return false;
        //    }
        //    bool isValid = true;
        //    char[] yearText;
        //    int year = 0;

        //    XmlNode xRoot = xDocument.Document;

        //    XmlNode xNode = xRoot.SelectSingleNode(xPath);

        //    if(xNode != null && xNode.InnerText != null)
        //    {
        //        yearText = xNode.InnerText.ToCharArray();

        //        foreach(char textChar in yearText)
        //        {
        //            if(Constants.NUMBERSET.IndexOf(textChar) == -1)
        //                return false;
        //        }
        //        year = Convert.ToInt16(xNode.InnerText, CultureInfo.InvariantCulture);


        //        if(year < Constants.INT1 || year > Constants.INT9999 || yearText.Length != Constants.INT4)
        //            isValid = false;
        //    }
        //    return isValid;
        //}


        /// <method>
        ///		CheckNoPresence
        /// </method>
        /// <summary>
        ///		This method checks the presence of Tag2 with specified value of
        ///		 Field1 in particular occurance of SeqeunceX when Tag1 with
        ///		 Specified values of field1 and field2 is NOT present in SAME
        ///		OCCURANCE of SequenceY. The check performed depends on
        ///		 value Of isPresent, which is passed as boolean parameter.
        ///		 if isPresent is true then check is performed for tag2 being
        ///		 MANDATORY in Sequence X and when isPresent is false check is
        ///		 performed for tag2 being NOT ALLOWED in SequenceY
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence1" type = "string">
        ///		Input reference of the sequence in which validation is to
        ///		performed.
        /// </param>
        /// <param name ="xPathSequence2" type = "string">
        ///		Input reference of the sequence in which validation is to
        ///		performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        ///		Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="valueTag1" type = "string">
        ///		Value of Field1 of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        ///		Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="xPathTag2Field1" type = "string">
        ///		Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="valueTag2" type = "string">
        ///		Value of Field1 of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        ///		Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        ///		boolean whose value depends upon the success of check performed.
        ///</returns>
        public static bool CheckNoPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence1,
            string xPathSequence2,
            string xPathTag1List,
            string valueTag1,
            bool isPresent,
            string xPathTag2List,
            string xPathTag2Field1,
            string valueTag2)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckNoPresence:");
            try
            {
                if (xPathSequence1 == null ||
                    xPathSequence1.Length == 0 ||
                    xPathSequence2 == null ||
                    xPathSequence2.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0 ||
                    xPathTag2Field1 == null ||
                    xPathTag2Field1.Length == 0 ||
                    valueTag1 == null ||
                    valueTag1.Length == 0 ||
                    valueTag2 == null ||
                    valueTag2.Length == 0
                    )
                {
                    return false;

                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence1 = xRoot.SelectNodes(xPathSequence1);
                XmlNodeList xListSequence2 = xRoot.SelectNodes(xPathSequence2);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;

                foreach (XmlNode xSequenceNode1 in xListSequence1)
                {
                    foreach (XmlNode xSequenceNode2 in xListSequence2)
                    {

                        isTag1ConditionValid = IsConditionSatisfied(xSequenceNode1, xPathTag1List, valueTag1);
                        isTag2ConditionValid = IsConditionSatisfied(xSequenceNode2, xPathTag2List, xPathTag2Field1,
                            valueTag2);

                        if (!isTag1ConditionValid & (isTag2ConditionValid ^ isPresent))
                        {
                            return false;

                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return true;
        }

        /// <method>
        ///		IsCheckPresence
        /// </method>
        /// <summary>
        ///		 This method checks the presence of Tag2 with specified value of
        ///		 Field1 in particular occurance of SeqeunceX when Tag1 with
        ///		 Specified values of field1 and field2 is present in SAME
        ///		 OCCURANCE of SequenceY or SeqeunceX. The check is performed using
        ///		 different checkpresence Functions, depending on the parameters passed.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence1List" type = "string">
        ///		Input reference of the sequence in which validation is to
        ///		performed.
        /// </param>
        /// <param name ="xPathSequence2List" type = "string">
        ///		Input reference of the sequence in which validation is to
        ///		performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        ///		Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="xPathTag1Field1" type = "string">
        ///		Input Reference of Field1 of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        ///		Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="xPathTag2Field1" type = "string">
        ///		Input Reference of Field1 of Tag2
        /// </param>
        /// <param name="valueListTag1Field1" type = "string">
        ///		Value of Field1 of Tag1
        /// </param>
        /// <param name="valueListTag2" type = "string">
        ///		Value of Field1 of Tag2
        /// </param>
        /// <param name="valueList" type = "string">
        ///		String of bool Values e.g True|False|True
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="policyName">
        /// 	policyName
        /// </param>
        /// <param name="ruleName">
        /// 	ruleName
        /// </param>
        /// <param name="errorObject">
        /// 	Error Object
        /// </param>
        /// <returns>
        ///		boolean whose value depends upon the success of check performed.
        /// </returns>
        //public static bool IsCheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence1List,
        //    string xPathSequence2List,
        //    string xPathTag1List,
        //    string xPathTag1Field1,
        //    string xPathTag2List,
        //    string xPathTag2Field1,
        //    string valueListTag1Field1,
        //    string valueListTag2,
        //    string valueList,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject
        //    )
        //{
        //    if(	xPathSequence1List == null ||
        //        xPathSequence1List.Length == 0 ||
        //        xPathSequence2List == null ||
        //        xPathSequence2List.Length == 0 ||
        //        xPathTag1List == null ||
        //        xPathTag1List.Length == 0 ||
        //        valueList == null ||
        //        valueList.Length == 0 ||
        //        xPathTag2List == null ||
        //        xPathTag2List.Length == 0 ||
        //        xPathTag1Field1 == null ||
        //        xPathTag1Field1.Length == 0 ||
        //        xPathTag2Field1 == null ||
        //        xPathTag2Field1.Length == 0 ||
        //        valueListTag1Field1 == null ||
        //        valueListTag1Field1.Length == 0 ||
        //        valueListTag2 == null ||
        //        valueListTag2.Length == 0||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null
        //        )

        //    {
        //        return false;

        //    }
        //    bool isValid = true;
        //    string [] sequence1Array = xPathSequence1List.Split(Constants.CHRPIPE);
        //    string [] sequence2Array = xPathSequence2List.Split(Constants.CHRPIPE);
        //    string [] tag1Array = xPathTag1List.Split(Constants.CHRPIPE);
        //    string [] tag1Field1Array = xPathTag1Field1.Split(Constants.CHRPIPE);
        //    string [] tag2Array = xPathTag2List.Split(Constants.CHRPIPE);
        //    string [] tag2Field1Array = xPathTag2Field1.Split(Constants.CHRPIPE);
        //    string [] valueTag1Field1Array = valueListTag1Field1.Split(Constants.CHRPIPE);
        //    string [] valueTag2Array = valueListTag2.Split(Constants.CHRPIPE);
        //    string [] valueArray = valueList.Split(Constants.CHRPIPE);


        //    for(int count = 0;count<= sequence1Array.Length - 1;count++)
        //    {
        //        if(sequence2Array[count] == string.Empty &&
        //            valueTag2Array[count] == string.Empty)
        //        {
        //            if( valueArray[count].CompareTo(Constants.FALSE) == 0)
        //            {
        //                isValid = CheckPresence(xDocument,sequence1Array[count],tag1Array[count],
        //                    tag1Field1Array[count],valueTag1Field1Array[count],tag2Array[count],false);
        //            }
        //            if( valueArray[count].CompareTo(Constants.TRUE) == 0)
        //            {
        //                isValid = CheckPresence(xDocument,sequence1Array[count],tag1Array[count],
        //                    tag1Field1Array[count],valueTag1Field1Array[count],tag2Array[count],true);
        //            }

        //        }
        //        if(sequence2Array[count] != string.Empty &&
        //            valueTag2Array[count] == string.Empty
        //            && tag2Field1Array[count] == string.Empty)
        //        {
        //            if( valueArray[count].CompareTo(Constants.FALSE) == 0)
        //            {
        //                isValid = CheckPresence(xDocument,sequence1Array[count],sequence2Array[count],tag1Array[count],
        //                    tag1Field1Array[count],valueTag1Field1Array[count],tag2Array[count],false);
        //            }
        //            if( valueArray[count].CompareTo(Constants.TRUE) == 0)
        //            {
        //                isValid = CheckPresence(xDocument,sequence1Array[count],sequence2Array[count],tag1Array[count],
        //                    tag1Field1Array[count],valueTag1Field1Array[count],tag2Array[count],false);
        //            }

        //        }
        //        if(sequence2Array[count] == string.Empty &&
        //            tag2Field1Array[count] != string.Empty)
        //        {
        //            if( valueArray[count].CompareTo(Constants.FALSE) == 0)
        //            {
        //                isValid = CheckPresence(xDocument,sequence1Array[count],tag1Array[count],
        //                    tag1Field1Array[count],valueTag1Field1Array[count],tag2Array[count]
        //                    ,tag2Field1Array[count],false,valueTag2Array[count]);
        //            }
        //            if( valueArray[count].CompareTo(Constants.TRUE) == 0)
        //            {
        //                isValid = CheckPresence(xDocument,sequence1Array[count],tag1Array[count],
        //                    tag1Field1Array[count],valueTag1Field1Array[count],tag2Array[count]
        //                    ,tag2Field1Array[count],true,valueTag2Array[count]);
        //            }
        //        }
        //        if(sequence2Array[count] != string.Empty &&
        //            tag2Field1Array[count] != string.Empty)
        //        {
        //            if( valueArray[count].CompareTo(Constants.FALSE) == 0)
        //            {
        //                isValid = CheckPresence(xDocument,sequence1Array[count],sequence2Array[count],
        //                    tag1Array[count],valueTag1Field1Array[count],false,tag2Array[count],
        //                    tag2Field1Array[count],valueTag2Array[count]);

        //            }
        //            if( valueArray[count].CompareTo(Constants.TRUE) == 0)
        //            {
        //                isValid = CheckPresence(xDocument,sequence1Array[count],sequence2Array[count],
        //                    tag1Array[count],valueTag1Field1Array[count],true,tag2Array[count],
        //                    tag2Field1Array[count],valueTag2Array[count]);
        //            }
        //        }

        //        if( sequence2Array[count] != string.Empty &&
        //            tag2Field1Array[count] == string.Empty
        //            && valueTag2Array[count] != string.Empty)
        //        {
        //            if( valueArray[count].CompareTo(Constants.FALSE) == 0)
        //            {
        //                isValid = CheckPresence(xDocument,sequence1Array[count],sequence2Array[count],tag1Array[count],
        //                    tag1Field1Array[count],valueTag1Field1Array[count],false,tag2Array[count],
        //                    valueTag2Array[count]);
        //            }
        //            if( valueArray[count].CompareTo(Constants.TRUE) == 0)
        //            {
        //                isValid = CheckPresence(xDocument,sequence1Array[count],sequence2Array[count],tag1Array[count],
        //                    tag1Field1Array[count],valueTag1Field1Array[count],true,tag2Array[count],
        //                    valueTag2Array[count]);
        //            }
        //        }
        //        if(!isValid)
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                sequence2Array[count], tag1Array[count]);
        //            break;
        //        }

        //    }

        //    return isValid;

        //}


        /// <method>
        ///		IsCheckPresence
        /// </method>
        /// <summary>
        ///		 This method checks the presence of Tag2 with specified value of
        ///		 Field1 in particular occurance of SeqeunceX when Tag1 with
        ///		 Specified values of field1 and field2 is present in SAME
        ///		 OCCURENCE of SequenceY or SeqeunceX. The check is performed using
        ///		 different checkpresence Functions, depending on the parameters passed.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequenceList" type = "string">
        ///		Input reference of the sequence in which validation is to
        ///		performed.
        /// </param>
        /// <param name="xPathTagList" type = "string" >
        ///		Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="valueList1Tag" type = "string">
        ///		Value of Tag1
        /// </param>
        /// <param name="valueList2Tag" type = "string">
        ///		Value of Tag2
        /// </param>
        /// <param name="value1List" type = "string">
        ///		String of bool Values e.g True|False|True
        /// </param>
        /// <param name="value2List" type = "string">
        ///		String of bool Values e.g True|False|True
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="policyName">
        /// 	policyName
        /// </param>
        /// <param name="ruleName">
        /// 	ruleName
        /// </param>
        /// <param name="errorObject">
        /// 	Error Object
        /// </param>
        /// <returns>
        ///		boolean whose value depends upon the success of check performed.
        ///</returns>
        //public static bool IsCheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequenceList,
        //    string xPathTagList,
        //    string valueList1Tag,
        //    string valueList2Tag,
        //    string value1List,
        //    string value2List,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject
        //    )
        //{
        //    if(	xPathSequenceList == null ||
        //        xPathSequenceList.Length == 0 ||
        //        xPathTagList == null ||
        //        xPathTagList.Length == 0 ||
        //        valueList1Tag == null ||
        //        valueList1Tag.Length == 0 ||
        //        valueList2Tag == null ||
        //        valueList2Tag.Length == 0 ||
        //        value1List == null ||
        //        value1List.Length == 0||
        //        value2List == null ||
        //        value2List.Length == 0||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null
        //        )

        //    {
        //        return false;

        //    }
        //    bool isValid = true;
        //    string [] sequenceArray = xPathSequenceList.Split(Constants.CHRPIPE);
        //    string [] tagArray = xPathTagList.Split(Constants.CHRPIPE);
        //    string [] value1Tag = valueList1Tag.Split(Constants.CHRPIPE);
        //    string [] value2Tag = valueList2Tag.Split(Constants.CHRPIPE);
        //    string [] value1Array = value1List.Split(Constants.CHRPIPE);
        //    string [] value2Array = value2List.Split(Constants.CHRPIPE);


        //    for(int count = 0;count<= sequenceArray.Length - 1;count++)
        //    {

        //        if( value1Array[count].CompareTo(Constants.FALSE) == 0 &&
        //            value2Array[count].CompareTo(Constants.FALSE) == 0)
        //        {
        //            isValid = CheckPresence(xDocument,sequenceArray[count],tagArray[count],
        //                value1Tag[count],false,false,value2Tag[count]);
        //        }

        //        if( value1Array[count].CompareTo(Constants.TRUE) == 0 &&
        //            value2Array[count].CompareTo(Constants.FALSE) == 0)
        //        {
        //            isValid = CheckPresence(xDocument,sequenceArray[count],tagArray[count],
        //                value1Tag[count],true,false,value2Tag[count]);

        //        }
        //        if(!isValid)
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                sequenceArray[count], tagArray[count]);
        //            break;
        //        }
        //    }

        //    return isValid;
        //}

        /// <method>
        /// 	CheckPresence
        /// </method>
        /// <summary>
        /// 	This method checks the presence of Tag2 with specified value of
        /// 	Field1 in SeqeunceX when Tag1 with Specified values of Tag1
        /// 	SequenceY.
        /// 	The check performed depends on value Of isPresent, which
        /// 	is passed as boolean parameter. if isPresent is true then
        /// 	check is performed for tag2 being MANDATORY in Sequence Y
        /// 	and when isPresent is false check is performed for tag2
        /// 	being NOT ALLOWED in SequenceY
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence1" type = "string">
        ///		Input reference of the sequence1 in which validation is to
        ///		performed.
        /// </param>
        /// <param name ="xPathSequence2" type = "string">
        ///		Input reference of the sequence2 in which validation is to
        ///		performed.
        /// </param>
        /// <param name="xPathTag1List" type = "string" >
        /// 	Comma seperated Input References of the List of Tag1
        /// </param>
        /// <param name="valueTag1" type = "string">
        /// 	Value of Tag1
        /// </param>
        /// <param name="xPathTag2List" type = "string">
        /// 	Comma seperated Input References of the List of Tag2
        /// </param>
        /// <param name="xPathTag2Field1" type = "string">
        /// 	Input Reference of Field1 of Tag2
        /// </param>
        /// <param name="valueTag2" type = "string">
        /// 	Value of Field1 of Tag2
        /// </param>
        /// <param name="isPresent" type = "boolean">
        /// 	Boolean parameter which decides the type of check to be performed.
        /// </param>
        /// <returns>
        /// 	boolean whose value depends upon the success of check performed.
        ///</returns>
        public static bool CheckPresence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence1,
            string xPathSequence2,
            string xPathTag1List,
            string valueTag1,
            bool isPresent,
            string xPathTag2List,
            string xPathTag2Field1,
            string valueTag2)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckPresence:");
            try
            {
                if (xPathSequence1 == null ||
                    xPathSequence1.Length == 0 ||
                    xPathSequence2 == null ||
                    xPathSequence2.Length == 0 ||
                    xPathTag1List == null ||
                    xPathTag1List.Length == 0 ||
                    xPathTag2List == null ||
                    xPathTag2List.Length == 0 ||
                    xPathTag2Field1 == null ||
                    xPathTag2Field1.Length == 0 ||
                    valueTag1 == null ||
                    valueTag1.Length == 0 ||
                    valueTag2 == null ||
                    valueTag2.Length == 0
                    )
                {
                    return false;
                }

                if (null == xDocument) throw new ArgumentNullException("xDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence1 = xRoot.SelectNodes(xPathSequence1);
                XmlNodeList xListSequence2 = xRoot.SelectNodes(xPathSequence2);
                bool isTag1ConditionValid = false;
                bool isTag2ConditionValid = false;


                foreach (XmlNode xSequenceNode1 in xListSequence1)
                {
                    foreach (XmlNode xSequenceNode2 in xListSequence2)
                    {

                        isTag1ConditionValid = IsConditionSatisfied(xSequenceNode1, xPathTag1List, valueTag1);

                        isTag2ConditionValid = IsConditionSatisfied(xSequenceNode2, xPathTag2List,
                            xPathTag2Field1, valueTag2);

                        if (isTag1ConditionValid && (isTag2ConditionValid ^ isPresent))
                        {
                            return false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return true;

        }

        /// <method>
        /// 	CheckValidDeliverySubsetName
        /// </method>
        /// <summary>
        /// 	The function validates for DeliverySubsetName which should be unique in the multiple
        /// 	occurences of the field and should not contain LTDIR as its first five characters.
        /// </summary>
        /// <param name="xDocument">
        /// 	A4SWIFTXmlDocument
        /// </param>
        /// <param name="xPathTagList">
        /// 	Xpath of the tag which you are validating
        /// 	eg://DeliverySubsetName_339
        /// </param>
        /// <param name="xPathDeliverySubsetName">
        /// 	xPath of the DeliverySubsetName field
        /// 	eg: ./DeliverySubsetName
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="elementName">
        /// 	Tag Name
        /// </param>
        /// <param name="ruleName">
        /// 	rule name
        /// </param>
        /// <param name="policyName">
        /// 	policy name
        /// </param>
        /// <param name="errorObj">
        /// 	Error Object
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool CheckValidDeliverySubsetName(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTagList,
            string xPathDeliverySubsetName,
            string errorCode,
            string elementName,
            string ruleName,
            string policyName,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidDeliverySubsetName" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTagList == null ||
                    xPathTagList.Length == 0 ||
                    xPathDeliverySubsetName == null ||
                    xPathDeliverySubsetName.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0)
                {
                    return false;
                }

                if (null == errorObj) throw new ArgumentNullException("errorObj");


                string DeliverySubsetName = string.Empty;
                string codeList = string.Empty;
                string code = string.Empty;


                XmlNode xRoot = xDocument.Document;
                string textDeliverySubsetName = string.Empty;

                //Splitting XpathTagList
                string[] arrxPath = xPathTagList.Split(Constants.CHRCOMMA);

                foreach (string xPathTag in arrxPath)
                {
                    //Selects all the occurences of the tag in the message
                    XmlNodeList xTagList = xRoot.SelectNodes(xPathTag);

                    foreach (XmlNode xNode in xTagList)
                    {
                        if (xNode.SelectSingleNode(xPathDeliverySubsetName) != null
                            && xNode.SelectSingleNode(xPathDeliverySubsetName).InnerText != null)
                        {

                            textDeliverySubsetName = xNode.SelectSingleNode(xPathDeliverySubsetName).InnerText.Substring(0, Constants.INT5);
                            code = xNode.InnerText;

                            if (String.Compare(textDeliverySubsetName, Constants.LTDIR) == 0)
                            {
                                //error
                                errorObj.AddError(errorCode, policyName, ruleName, xNode.Name, Constants.NOCONTENT);
                            }
                            else
                            {
                                if (codeList.IndexOf(code) != -1)
                                {
                                    //error
                                    errorObj.AddError(errorCode, policyName, ruleName, xNode.Name, Constants.NOCONTENT);
                                }
                                codeList = codeList + Constants.CHRCOMMA + code;
                            }

                        }


                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }

        /// <method>
        ///		IsValidSelectedCurrency
        /// </method>
        /// <summary>
        ///		This function performs validation whether the Selected Curency is present when
        ///		the Drawdown Currency and Facility. e.g MT643,Field 32E must be Present when the
        ///		Currency of Fields 32B and 26N are Different.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence . e.g //SequenceC
        /// </param>
        /// <param name ="xPathTag1" type = "string">
        ///		Input reference of the Element to be Validated. e.g. ./SelectedCurrency_C_32E
        /// </param>
        /// <param name ="xPathTag2" type = "string">
        ///		Input reference of the Element to be Validated. e.g. ./AmountOfDrawDown_C_32B
        /// </param>
        /// <param name ="xPathTag3" type = "string">
        ///		Input reference of the Element to be Validated. e.g. ./DrawingIdentification_C_26N
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        //public static bool IsValidSelectedCurrency(Microsoft.RuleEngine.TypedXmlDocument xDocument,
        //    string xPathSequence,
        //    string xPathTag1,
        //    string xPathTag2,
        //    string xPathTag3,
        //    string errorCode,
        //    string policyName,
        //    string ruleName,
        //    ErrorCollection errorObject)
        //{
        //    bool isValid = true;
        //    if(xDocument == null ||
        //        xPathSequence == null ||
        //        xPathSequence.Length == 0 ||
        //        xPathTag1 == null ||
        //        xPathTag1.Length == 0 ||
        //        xPathTag2 == null ||
        //        xPathTag2.Length == 0 ||
        //        xPathTag3 == null ||
        //        xPathTag3.Length == 0 ||
        //        errorCode == null ||
        //        errorCode.Length == 0 ||
        //        errorObject == null)
        //    {
        //        return false;

        //    }

        //    XmlNode xRoot = xDocument.Document;
        //    //Select all the nodes of Sequence
        //    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

        //    foreach(XmlNode xNode in xListSequence)
        //    {

        //        if(xNode.SelectSingleNode(xPathTag1) != null &&
        //            xNode.SelectSingleNode(xPathTag2) != null &&
        //            xNode.SelectSingleNode(xPathTag3) != null &&
        //            xNode.SelectSingleNode(xPathTag2).FirstChild != null &&
        //            xNode.SelectSingleNode(xPathTag3).FirstChild != null &&
        //            xNode.SelectSingleNode(xPathTag2).FirstChild.InnerText.CompareTo
        //            (xNode.SelectSingleNode(xPathTag3).FirstChild.InnerText) == 0)
        //        {
        //            errorObject.AddError(errorCode, policyName, ruleName,
        //                xNode.SelectSingleNode(xPathTag2).FirstChild.InnerText,
        //                xNode.SelectSingleNode(xPathTag1).InnerText);
        //            isValid = false;
        //        }
        //    }

        //    return isValid;
        //}


        /// <method>
        ///		IsValidDetailsOfAdjustments
        /// </method>
        /// <summary>
        ///		This function performs validation for the Currency Amount Fields present in First line
        ///		of Details of Adjustment. e.g MT643, Line1 : /8a/[3!a13d][additionalInformation]
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathTag" type = "string">
        ///		Input reference of the Element to be Validated. e.g. ./SelectedCurrency_C_32E
        /// </param>
        /// <param name ="currencyAmountCodeList" type = "string">
        ///		Input containing the list of CurrencyCodes and the No of Zeroes to be present in the
        ///		Amount Field for a particular Currency.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="elementName" type = "string">
        ///		Input containing the elementName.
        /// </param>
        /// <param name ="elementValue" type = "string">
        ///		Input containing the elementValue.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidDetailsOfAdjustments(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            //string currencyAmountCodeList,
            string errorCode,
            string ruleName,
            string policyName,
            string elementName,
            string elementValue,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidDetailsOfAdjustments" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0)//||
                //				currencyAmountCodeList == null ||
                //				currencyAmountCodeList.Length == 0)
                {
                    return false;
                }


                XmlNode xRoot = xDocument.Document;
                string lineText = string.Empty;
                string tempText = string.Empty;
                string currency = string.Empty;
                string amount = string.Empty;

                XmlNodeList xNodeList = xRoot.SelectNodes(xPathTag);

                //Creates a hash table of currency codes and their corresponding
                //decimal places
                //			string[] data = currencyAmountCodeList.Split(Constants.CHRPIPE);
                //			Hashtable currencyList = new Hashtable();
                //			BuildCurrencyList(data,ref currencyList);

                //bool currencycodeExists = false;
                int position = 0;
                int count = 0;

                foreach (XmlNode xNode in xNodeList)
                {
                    XmlNodeList xChildList = xNode.ChildNodes;

                    foreach (XmlNode xChildNode in xChildList)
                    {
                        //currencycodeExists = false;
                        if (xChildNode.InnerText != null)
                        {
                            lineText = xChildNode.InnerText;

                            if (lineText.Substring(1, 1) != Constants.SLASH)
                            {
                                position = 0;

                                position = lineText.Substring(1).IndexOf(Constants.SLASH);

                                if (lineText.Length > (position + Constants.INT1 + Constants.INT4))
                                {
                                    count = 0;

                                    currency = lineText.Substring(position + Constants.INT2, Constants.INT3);

                                    tempText = lineText.Substring(position + Constants.INT2 + Constants.INT3);

                                    while (count < tempText.Length &&
                                        (Constants.NUMBERSET.IndexOf(tempText.Substring(count, Constants.INT1)) != -1
                                        || Constants.COMMA.IndexOf(tempText.Substring(count, Constants.INT1)) != -1))
                                    {
                                        count++;
                                    }

                                    amount = lineText.Substring(position + Constants.INT2 + Constants.INT3, count);

                                    //if(SqlConnector.hashCurrencyCodeList.Contains(currency))
                                    //{
                                    //	currencycodeExists = true;
                                    //}

                                    //if( currencycodeExists || (!currencycodeExists && amount.Length != 0))
                                    //{
                                    isValid = CheckCurrencyAmount(currency, amount,
                                        true, true, true, errorCode, elementName, elementValue,
                                        ruleName, policyName, errorObject) && isValid;
                                    //}

                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        /// 	CheckValidSignCurrencyAmount
        /// </method>
        /// <summary>
        /// 	This function will return false if the validation of sign currency and
        /// 	amount is false depending on boolean values set.
        /// </summary>
        /// <param name="xDocument">
        /// 	XmlDocument
        /// </param>
        /// <param name="xPathTag">
        /// 	Comma seperated list of xPath of tags
        /// 	eg.//Amount_E3_19A/SignCurrencyAmount
        /// </param>
        /// <param name="allowLeadingZero">
        /// 	determines whether leading zero check is allowed
        /// </param>
        /// <param name="isCurrencyValidationRequired">
        /// 	determines whether currency code check is required
        /// </param>
        /// <param name="isCurrencyAmountValidationRequired">
        /// 	determines whether Amount deciamal places check is required for a particular currency
        /// </param>
        /// <param name="currencyAmountList">
        /// 	currency amount code list
        /// </param>
        /// <param name="typeList">
        /// 	Type code list
        /// </param>
        /// <param name="errorCode">
        /// 	error code
        /// </param>
        /// <param name="currencyName">
        /// 	Currency
        /// </param>
        /// <param name="amountName">
        /// 	amount
        /// </param>
        /// <param name="ruleName">
        /// 	rule name
        /// </param>
        /// <param name="policyName">
        /// 	policyname
        /// </param>
        /// <param name="errorobj">
        /// 	error object
        /// </param>
        /// <returns>
        /// 	bool
        ///	</returns>
        public static bool CheckValidSignCurrencyAmount(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            bool allowLeadingZero,
            bool isCurrencyValidationRequired,
            bool isCurrencyAmountValidationRequired,
            //string currencyAmountList,
            string typeList,
            string errorCode,
            string currencyName,
            string amountName,
            string ruleName,
            string policyName,
            ErrorCollection errorobj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidSignCurrencyAmount" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (typeList == null ||
                    typeList.Length == 0)
                {
                    return false;
                }
                //				//			currencyAmountList += Constants.CHRPIPE + Constants.HYPHEN +
                //				//				Constants.INT1 + Constants.CHRPIPE + typeList;
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return CheckValidSignCurrencyAmount(xDocument,
                xPathTag, allowLeadingZero,
                isCurrencyValidationRequired,
                isCurrencyAmountValidationRequired,
                //currencyAmountList,
                errorCode,
                currencyName,
                amountName,
                ruleName,
                policyName,
                errorobj);

        }

        /// <method>
        ///		IsValidStartEndDate
        /// </method>
        /// <summary>
        /// 	The first field 177 must be a date not older than 30 days from the current date.
        /// 	The second field 177 must not be more than seven days after the date in the first field 177.
        /// 	Applicable to Tag 177 of Cat 0 messages
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPathStartDate">
        /// 	xPath of Start Date
        /// </param>
        /// <param name="xPathEndDate">
        /// 	xPath of End Date
        /// </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Inutput containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        public static bool IsValidStartEndDate(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathStartDate,
            string xPathEndDate,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidStartEndDate" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPathStartDate == null ||
                    xPathStartDate.Length == 0 ||
                    xPathStartDate == null ||
                    xPathStartDate.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    bool isValid = true;
                    string strStartDate = string.Empty;
                    string strEndDate = string.Empty;
                    DateTime startDate;
                    DateTime endDate;
                    TimeSpan dayDiff;

                    XmlNode xRoot = xDocument.Document;
                    XmlNode xNodeStartDate = xRoot.SelectSingleNode(xPathStartDate);
                    XmlNode xNodeEndDate = xRoot.SelectSingleNode(xPathEndDate);
                    if (xNodeStartDate == null || xNodeStartDate.InnerText == null ||
                        xNodeStartDate.InnerText.Length == 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType,
                            xNodeStartDate.Name, xNodeStartDate.InnerText);
                        isValid = false;

                    }
                    else if (xNodeEndDate == null || xNodeEndDate.InnerText == null ||
                        xNodeEndDate.InnerText.Length == 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType,
                            xNodeEndDate.Name, xNodeEndDate.InnerText);
                        isValid = false;

                    }
                    else
                    {
                        strStartDate = xNodeStartDate.InnerText;
                        strEndDate = xNodeEndDate.InnerText;

                        int yy = Int32.Parse(strStartDate.Substring(0, 2), CultureInfo.InvariantCulture);
                        int mm = Int32.Parse(strStartDate.Substring(2, 2), CultureInfo.InvariantCulture);
                        int dd = Int32.Parse(strStartDate.Substring(4, 2), CultureInfo.InvariantCulture);

                        // Year 2000 Issue - only 2 digits for the year...
                        if (yy >= 69 && yy <= 99) yy += 1900;
                        else yy += 2000;

                        startDate = new DateTime(yy, mm, dd);

                        yy = Int32.Parse(strEndDate.Substring(0, 2), CultureInfo.InvariantCulture);
                        mm = Int32.Parse(strEndDate.Substring(2, 2), CultureInfo.InvariantCulture);
                        dd = Int32.Parse(strEndDate.Substring(4, 2), CultureInfo.InvariantCulture);

                        // Year 2000 Issue - only 2 digits for the year...
                        if (yy >= 69 && yy <= 99) yy += 1900;
                        else yy += 2000;

                        endDate = new DateTime(yy, mm, dd);

                        dayDiff = endDate - startDate;
                        if (dayDiff.Days > Constants.INT7 || dayDiff.Days < 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                xNodeStartDate.Name, xNodeStartDate.InnerText);
                            isValid = false;
                        }
                        dayDiff = startDate - DateTime.Today;
                        if (dayDiff.Days > Constants.INT30)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                xNodeStartDate.Name, xNodeStartDate.InnerText);
                            isValid = false;
                        }

                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        /// <method>
        ///		IsValidText
        /// </method>
        /// <summary>
        ///		This method performs validation for the Tag 311.
        ///		Text is in lines of 65 characters separated by CrLf.
        ///		Maximum size of text is 1800 characters.
        ///		The maximum size of this field is limited to 9800 characters.
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathText">
        ///		Input reference of the element Text to be validated.
        /// </param>
        /// <param name="lineLength">
        ///		Reference containing the Max line length of Text element which is 61 as CrLf is of 4 length.
        /// </param>
        /// <param name="textMaxLength">
        ///		Reference containing the Max text length which is 1800
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="elementName">
        ///		Input containing the element name.
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidText(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathText,
            int lineLength,
            int textMaxLength,
            string errorCode,
            string policyName,
            string ruleName,
            string elementName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidText" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int intNumOfLines = 0;
            int intNumOfText = 0;
            int lengthText = 0;

            if (xDocument == null ||
                xPathText == null ||
                xPathText.Length == 0 ||
                errorCode == null ||
                errorCode.Length == 0 ||
                errorObject == null)
            {
                return false;
            }

            try
            {
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xText = xRoot.SelectNodes(xPathText.ToString());

                foreach (XmlNode xNode in xText)
                {
                    lengthText += xNode.FirstChild.InnerText.Length + xNode.LastChild.InnerText.Length;
                    intNumOfLines += xNode.ChildNodes.Count;

                    intNumOfText = intNumOfText + Constants.INT1;

                    if (intNumOfText != xText.Count)
                    {
                        if (xNode.FirstChild.InnerText.Length > lineLength ||
                            xNode.LastChild.InnerText.Length > lineLength)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, elementName, xPathText.ToString());
                        }
                    }
                    else
                    {
                        if (xNode.ChildNodes.Count == Constants.INT2 &&
                            xNode.FirstChild.InnerText.Length > lineLength)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, elementName, xPathText.ToString());
                        }
                    }

                }
                lengthText = lengthText + (intNumOfLines - Constants.INT1) * Constants.INT4;

                if (lengthText > textMaxLength)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, elementName, xPathText.ToString());
                }

            }
            catch (ApplicationException _appException)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}", _appException.StackTrace + "Reason" + _appException.Message);
                throw _appException;
            }

            return isValid;
        }

        /// <method>
        /// 	IsValidExpiryDate
        /// </method>
        /// <summary>
        /// The maximum expiry date (YYMM) that may be requested is 1 year from the current month.(MT075)
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the XML Document Instance
        /// </param>
        /// <param name="xPathExpiryDate"> xPath of Expiry date tag </param>
        /// <param name="errorCode" type = "string">
        /// 	Input containing the error code.
        /// </param>
        /// <param name="policyName" type = "string">
        /// 	Input containing the Policy Name.
        /// </param>
        /// <param name="ruleName" type = "string">
        /// 	Input containing the Rule Name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name ="errorObject" type = "ErrorCollection">
        /// 	Inutput containing the error Object.
        /// </param>
        /// <returns type = "boolean">
        /// 	True if validation succeeded, false otherwise.
        /// </returns>
        public static bool IsValidExpiryDate(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathExpiryDate,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidExpiryDate" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPathExpiryDate == null ||
                    xPathExpiryDate.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    bool isValid = true;

                    string strExpiryDate = string.Empty;
                    string strMonth = string.Empty;
                    string monthYear = string.Empty;
                    int monthDiff = 0;
                    int month = 0;
                    int year = 0;


                    XmlNode xRoot = xDocument.Document;
                    XmlNode xNodeExpiryDate = xRoot.SelectSingleNode(xPathExpiryDate);
                    if (xNodeExpiryDate == null || xNodeExpiryDate.InnerText == null ||
                        xNodeExpiryDate.InnerText.Length == 0)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType,
                            xNodeExpiryDate.Name, xNodeExpiryDate.InnerText);
                        isValid = false;
                    }
                    else
                    {
                        //In YYMM format
                        strExpiryDate = xNodeExpiryDate.InnerText;

                        //Calculate the future valid YYMM from current date
                        month = Convert.ToInt16(DateTime.Today.Month, CultureInfo.InvariantCulture) - 1;

                        if (month <= Constants.INT9)
                        {
                            strMonth = Constants.CHR0 + Convert.ToString(month, CultureInfo.InvariantCulture);
                        }
                        else
                        {
                            strMonth = Convert.ToString(month, CultureInfo.InvariantCulture);
                        }
                        year = Convert.ToInt16(DateTime.Today.Year, CultureInfo.InvariantCulture) + 1;
                        monthYear = Convert.ToString(year, CultureInfo.InvariantCulture).Substring(Constants.YEARSTARTPOS, Constants.YEARENDPOS)
                            + strMonth;
                        monthDiff = Convert.ToInt16(strExpiryDate, CultureInfo.InvariantCulture) - Convert.ToInt16(monthYear, CultureInfo.InvariantCulture);
                        if (monthDiff > 0)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                xNodeExpiryDate.Name, xNodeExpiryDate.InnerText);
                            isValid = false;
                        }

                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }

        /// <method>
        /// 	CheckValidSignDateCurrencyAmount
        /// </method>
        /// <summary>
        /// 	This function performs the sing currency amount validation for a tag which
        /// 	has sign,date,currency and amount in a single field.
        /// </summary>
        /// <param name="xDocument">
        /// 	XmlDocument
        /// </param>
        /// <param name="xPath">
        /// 	xPath of the tag
        /// 	eg.//InterestAmount_B_34N/InterestAmount
        /// </param>
        /// <param name="currencyAmountList">
        /// 	Currency Code List
        /// </param>
        /// <param name="allowLeadingZero">
        /// 	bool
        /// </param>
        /// <param name="isCurrencyValidationRequired">
        /// 	bool
        /// </param>
        /// <param name="isCurrencyAmountValidationRequired">
        /// 	bool
        /// </param>
        /// <param name="errorCode">
        /// 	error codes C03,T40,T43
        /// </param>
        /// <param name="currencyName">
        /// 	"Currency"
        /// </param>
        /// <param name="amountName">
        /// 	"Amount"
        /// </param>
        /// <param name="ruleName">
        /// 	Rule name
        /// </param>
        /// <param name="policyName">
        /// 	Policy Name
        /// </param>
        /// <param name="errorObject">
        /// 	error object
        /// </param>
        /// <returns>
        /// 	returns true if it is a valid tag,
        /// 	else returns false.
        /// </returns>
        public static bool CheckValidSignDateCurrencyAmount(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            //string currencyAmountList,
            bool allowLeadingZero,
            bool isCurrencyValidationRequired,
            bool isCurrencyAmountValidationRequired,
            string errorCode,
            string currencyName,
            string amountName,
            string ruleName,
            string policyName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidSignDateCurrencyAmount" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0)// ||
                //currencyAmountList == null ||
                //currencyAmountList.Length == 0)
                {
                    return false;
                }

                if (null == errorObject) throw new ArgumentNullException("errorObject");

                XmlNode xRoot = xDocument.Document;
                string xNodeValue = string.Empty;

                string amount = string.Empty; ;
                string currency = string.Empty; ;
                string sign = string.Empty; ;

                XmlNodeList xNodeList = xRoot.SelectNodes(xPath);

                foreach (XmlNode xNode in xNodeList)
                {
                    sign = String.Empty;
                    xNodeValue = xNode.InnerText;

                    if (xNodeValue.Substring(0, 1).Equals(Constants.ALPHAN) ||
                        xNodeValue.Substring(0, 1).Equals(Constants.NEGATIVESIGN))
                    {
                        sign = xNodeValue.Substring(0, 1);

                        currency = xNodeValue.Substring(Constants.CURRENCYSTARTPOS1, Constants.CURRENCYENDPOS1);

                        amount = xNodeValue.Substring(Constants.AMOUNTVALUE1);

                        //checks if amount is zero
                        if (Convert.ToDouble(amount.Replace(Constants.CHRCOMMA, charDecimalSeparator), CultureInfo.InvariantCulture) == 0.0)
                        {
                            errorObject.AddError(Constants.ERRORT14, policyName, ruleName, amountName, amount);
                            isValid = false;
                        }
                    }
                    else
                    {
                        currency = xNodeValue.Substring(Constants.CURRENCYSTARTPOS2, Constants.CURRENCYENDPOS2);

                        amount = xNodeValue.Substring(Constants.AMOUNTVALUE2);
                    }

                    //performs currency and amount validations
                    isValid = CheckCurrencyAmount(currency, amount, allowLeadingZero,
                        isCurrencyValidationRequired, isCurrencyAmountValidationRequired, errorCode,
                        currencyName, amountName, ruleName, policyName, errorObject) && isValid;

                }
            }

            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <summary>
        /// Function that validates International Bank Account Number
        /// per spec given in - http://www.ecbs.org/Download/EBS204_V3.2.pdf
        /// </summary>
        /// <param name="bankAccntNumber">International Bank Account Number</param>
        /// <returns>bool</returns>
        public static bool A4SWIFTIBANValidator(string bankAccntNumber)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function A4SWIFTIBANValidator:");
            try
            {
                if (bankAccntNumber == null || bankAccntNumber.Length == 0)
                {
                    return false;
                }

                //If the IBAN is in paper format, convert to basic format by deleting all
                // non-alphanumeric characters.
                string tempIBANNumber = bankAccntNumber.Replace(" ", "");

                //Move the first four characters of the IBAN to the right of the number.
                StringBuilder tempibanSB = new StringBuilder();
                tempibanSB.Append(tempIBANNumber.Substring(4, tempIBANNumber.Length - 4));
                tempibanSB.Append(tempIBANNumber.Substring(0, 4));
                char[] chOrigArray = tempibanSB.ToString().ToCharArray();

                //Convert the letters into numerics in accordance with the conversion table
                //char a = 'A';
                StringBuilder IBANString = new StringBuilder();
                foreach (char c in chOrigArray)
                {
                    if (Char.IsLetter(c))
                        IBANString.Append(Convert.ToInt32(c, CultureInfo.InvariantCulture) - 55);
                    else
                        IBANString.Append(c);
                }

                int val = 0;

                //Apply MOD 97-10 (see ISO 7064). For the check digits to be correct,
                //the remainder after calculating the modulus 97 must be 1.

                //fixed QFE 2274 and changed this for loop condition from >2 to >1 for handling some cases
                for (int i = 0; IBANString.Length > 1; i++)
                {
                    /*
                        Calculate the modulo 97 of the first 9 (or 18) digits of the number.
                        Construct the next integer of 9 (or 18) digits from the remainder,
                        followed by the next 7/8 (or 16/17) digits of the number. Calculate
                        the modulo 97.
                        - Repeat this step until all the digits of the number have been processed.
                    */
                    string s = IBANString.Length > 9 ? IBANString.ToString().Substring(0, 9) : IBANString.ToString().Substring(0, IBANString.Length);
                    if (s.Length == 9)
                    {
                        val = Convert.ToInt32(s, CultureInfo.InvariantCulture) % 97;
                        IBANString.Remove(0, 9);
                        IBANString.Insert(0, val.ToString(CultureInfo.InvariantCulture));
                    }

                    else
                    {
                        val = Convert.ToInt32(s, CultureInfo.InvariantCulture) % 97;
                        if (val > 97)
                        {
                            continue;
                        }

                        else if (val < 97 & val == 1)
                        {
                            return true;
                        }

                        else
                        {
                            return false;
                        }
                    }
                }

                if (val == 1)
                {
                    return true;
                }
            }

            catch (System.ArgumentOutOfRangeException)
            {
                return false;
            }
            catch (FormatException)
            {
                return false;
            }

            return false;
        }

        /// <method>
        /// 	SWIFTNetworkRule58_SRG2005
        /// </method>
        /// <summary>
        /// In sequence A, if field 77D is present and if the 6 first characters of the first line are equal to "/VALD/" then the next 8
        /// characters must contain a date expressed as YYYYMMDD and followed by the end of line code.
        /// </summary>
        /// <param name="xDocument"></param>
        /// XmlDocument
        /// <param name="xPathline1"></param>
        /// Xpath of 77D's Line1 element
        /// <param name="code"></param>
        /// THe code which needs to be checked i.e /VALD/
        /// <param name="errorCode"></param>
        /// Error Code C58
        /// <param name="policyName"></param>
        /// Policy name to be passed
        /// <param name="ruleName"></param>
        /// Rule name to be passed
        /// <param name="messageType"></param>
        /// Message Type to be passed
        /// <param name="conditionalRuleName"></param>
        /// COnditional Rule Name to be passed
        /// <param name="conditionalRuleNumber"></param>
        /// COnditional Rule Number to be passed
        /// <param name="errorObject"></param>
        /// error object
        /// <returns type = "bool">
        /// True if validation succeeds, False otherwise.
        /// </returns>


        public static bool SWIFTNetworkRule58_SRG2005(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathline1,
            string code,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule58_SRG2005" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPathline1 == null ||
                    xPathline1.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                string xNodeValue = string.Empty;
                //bool isValid = true;

                XmlNodeList xNodeList = xRoot.SelectNodes(xPathline1);
                foreach (XmlNode xNodeP in xNodeList)
                {
                    int lineNo = 0;
                    foreach (XmlNode xNode in xNodeP.ChildNodes)
                    {
                        xNodeValue = xNode.InnerText;
                        if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                        {
                            if (
                                (xNode.InnerText.StartsWith(code) && lineNo > 0) ||  //IF VALD Exist other than 1st Line
                                (xNode.InnerText.IndexOf(code) > 0) || //If VALD id note in the 1st 6 Characters
                                (xNode.InnerText.StartsWith(code) && (xNode.InnerText.Length != 14 || !IsValidDateYYYYMMDDFormat(xNodeValue.Substring(6, 8)))) //length of line1 is not equal to 14.Check the date format is correct or not.
                                )
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNode.ParentNode.Name, xNode.InnerText);
                                return false;
                            }
                        }
                        lineNo++;
                    }
                }
                return true;
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        // RFH 2713.

        /// <method>
        /// 	SwiftNetworkRuleT80
        /// </method>
        /// <summary>
        /// If either of these REJT and RETN codes is used in the first position of the first line of field 72, 
        /// placed between slashes ('/'), then it is mandatory to follow Generic Payment Reject Return 
        /// Mechanism(Rule T80)for field 72.
        /// </summary>
        /// <param name="xDocument">
        /// 	XmlDocument
        /// </param>
        /// <param name="xPathline1">
        /// 	xPath of the Line 1 of field 72.
        /// </param>
        /// <param name="xPathline2">
        /// 	xPath of the Line 2 of field 72.
        /// </param>
        /// <param name="reasonCodesList">
        /// 	Reasons codes List for 2!c2!n format in Line 2.
        /// </param>
        /// <param name="xPathline3">
        /// 	xPath of the Line 3 of field 72.
        /// </param>
        /// <param name="xPathline4">
        /// 	xPath of the Line 4 of field 72.
        /// </param>
        /// <param name="xPathline5">
        /// 	xPath of the Line 5 of field 72.
        /// </param>
        /// <param name="xPathline6">
        /// 	xPath of the Line 6 of field 72.
        /// </param>
        /// <param name="currencyCodesList">
        /// 	Currency Codes List
        /// </param>
        /// <param name="errorCode">
        /// 	error code T80
        /// </param>
        /// <param name="policyName">
        /// 	Policy Name
        /// </param>
        /// <param name="ruleName">
        /// 	Rule name
        /// </param>
        /// <param name="errorObject">
        /// 	error object
        /// </param>
        /// <returns>
        /// 	returns true if validation succeeds,
        /// 	else returns false.
        /// </returns>
        /// 
        public static bool SwiftNetworkRuleT80(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string reasonCodesList,
            //string currencyCodesList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRuleT80" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                String currency = String.Empty;
                String amount = String.Empty;
                String currencyAmount = String.Empty;


                bool line5TEXT = false;
                bool line6TEXT = false;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList nodeList = xRoot.SelectNodes(xPathTag);
                foreach (XmlNode node in nodeList)
                {
                    if (node.InnerText != null && node.InnerText.Length != 0)
                    {
                        XmlNode xNodeLine1 = node.ChildNodes[0];
                        XmlNode xNodeLine2 = node.ChildNodes[1];
                        XmlNode xNodeLine3 = node.ChildNodes[2];
                        XmlNode xNodeLine4 = node.ChildNodes[3];
                        XmlNode xNodeLine5 = node.ChildNodes[4];
                        XmlNode xNodeLine6 = node.ChildNodes[5];

                        //If the first line starts with either "/REJT/" or "/RETN/", then other validations are performed.
                        if ((xNodeLine1.InnerText.StartsWith(Constants.CODEREJT)) ||
                            (xNodeLine1.InnerText.StartsWith(Constants.CODERETN)))
                        {
                            //If any of the lines 2 or 3 is null.
                            if (xNodeLine2 == null || xNodeLine3 == null)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, xNodeLine1.ParentNode.Name, Constants.BLANK);
                                isValid = false;
                            }

                            //Line 1,Line2 and Line 3 are mandatory lines.
                            if (!(Regex.IsMatch(xNodeLine1.InnerText, Constants.LINE1FORMAT)))
                            {
                                //Throw error, format for line1 not suppeoted.
                                errorObject.AddError(errorCode, policyName, ruleName, xNodeLine1.Name, xNodeLine1.InnerText);
                                isValid = false;
                            }

                            if ((Regex.IsMatch(xNodeLine2.InnerText, Constants.LINE2FORMAT)))
                            {
                                string reasonCode = xNodeLine2.InnerText.Substring(0, 6);
                                if (!((reasonCodesList.IndexOf(reasonCode) != -1) ||
                                     (Regex.IsMatch(reasonCode, Constants.REASONCODEPATTERN))))
                                {
                                    // Throw an error Reason code for line 2 is not valid.
                                    errorObject.AddError(errorCode, policyName, ruleName, Constants.REASONCODE, reasonCode);
                                    isValid = false;
                                }
                            }
                            //Throw error, format for line2 not suppeoted.
                            else
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, xNodeLine2.Name, xNodeLine2.InnerText);
                                isValid = false;
                            }
                            if (!(Regex.IsMatch(xNodeLine3.InnerText, Constants.LINE3FORMAT)))
                            {
                                //Throw error, format for line 3 not supported.
                                errorObject.AddError(errorCode, policyName, ruleName, xNodeLine3.Name, xNodeLine3.InnerText);
                                isValid = false;
                            }

                            if (xNodeLine5 != null)
                            {
                                if (xNodeLine5.InnerText.StartsWith(Constants.CODETEXT))
                                    line5TEXT = true;
                            }

                            if (xNodeLine6 != null)
                            {
                                if (xNodeLine6.InnerText.StartsWith(Constants.CODETEXT))
                                    line6TEXT = true;
                            }

                            //If any of the optional lines 4 , 5 or 6 exists.
                            if (xNodeLine4 != null || xNodeLine5 != null || xNodeLine6 != null)
                            {
                                //If line 4, 5 or 6th line contains /TEXT/
                                if ((xNodeLine4.InnerText.StartsWith(Constants.CODETEXT)) || line5TEXT || line6TEXT)
                                {
                                    //If line 4 starts with TEXT, simply match the format of //TEXT.
                                    if (xNodeLine4.InnerText.StartsWith(Constants.CODETEXT))
                                    {
                                        if (!Regex.IsMatch(xNodeLine4.InnerText, Constants.LINE6FORMAT))
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, xNodeLine4.Name,
                                                                 xNodeLine4.InnerText);
                                            isValid = false;
                                        }
                                        else if (xNodeLine5 != null || xNodeLine6 != null)
                                        {
                                            //If /TEXT/ is at line 4, and if either of the lines 5 or 6 exists, 
                                            //it has to be of format //33x
                                            if (xNodeLine6 != null)
                                            {
                                                if (!Regex.IsMatch(xNodeLine5.InnerText, Constants.XPATTERN33x))
                                                {
                                                    errorObject.AddError(errorCode, policyName, ruleName, xNodeLine5.Name,
                                                                         xNodeLine5.InnerText);
                                                    isValid = false;
                                                }
                                                if (!Regex.IsMatch(xNodeLine6.InnerText, Constants.XPATTERN33x))
                                                {
                                                    errorObject.AddError(errorCode, policyName, ruleName, xNodeLine6.Name,
                                                                         xNodeLine6.InnerText);
                                                    isValid = false;
                                                }
                                            }
                                            //line6 is null but Line 5 exists, it has to be //33x
                                            else if (!Regex.IsMatch(xNodeLine5.InnerText, Constants.XPATTERN33x))
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, xNodeLine5.Name,
                                                                     xNodeLine5.InnerText);
                                                isValid = false;
                                            }
                                        }
                                    }

                                    //If /TEXT/ is at line 5
                                    else if (xNodeLine5.InnerText.StartsWith(Constants.CODETEXT))
                                    {
                                        if (Regex.IsMatch(xNodeLine5.InnerText, Constants.LINE6FORMAT))
                                        {
                                            //line 4 has to be either /TREF/ or /CHGS/
                                            if (((Regex.IsMatch(xNodeLine4.InnerText, Constants.LINE4FORMAT)) ||
                                                 (Regex.IsMatch(xNodeLine4.InnerText, Constants.LINE5FORMAT))))
                                            {

                                                //If line 4 is /CHGS/, extract currency and amount.
                                                if (xNodeLine4.InnerText.StartsWith(Constants.CODECHGS))
                                                {
                                                    if (Regex.IsMatch(xNodeLine4.InnerText, Constants.LINE5FORMAT))
                                                    {
                                                        currencyAmount = xNodeLine4.InnerText.Substring(6);
                                                    }
                                                    else
                                                    {
                                                        errorObject.AddError(errorCode, policyName, ruleName, xNodeLine4.Name,
                                                                             xNodeLine4.InnerText);
                                                        isValid = false;
                                                    }
                                                }
                                                //Line 5 is /TEXT/ , if line 6 exists, it has to be of format //33x.
                                                if (xNodeLine6 != null)
                                                {
                                                    if (!Regex.IsMatch(xNodeLine6.InnerText, Constants.XPATTERN33x))
                                                    {
                                                        errorObject.AddError(errorCode, policyName, ruleName, xNodeLine6.Name,
                                                                             xNodeLine6.InnerText);
                                                        isValid = false;
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, xNodeLine4.Name,
                                                                    xNodeLine4.InnerText);
                                                isValid = false;
                                            }
                                        }
                                        //Throw error, format for line 5 not supported.
                                        else
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, xNodeLine5.Name,
                                                                 xNodeLine5.InnerText);
                                            isValid = false;
                                        }
                                    }

                                    // If /TEXT/ is at line 6
                                    else if (xNodeLine6.InnerText.StartsWith(Constants.CODETEXT))
                                    {
                                        if ((Regex.IsMatch(xNodeLine6.InnerText, Constants.LINE6FORMAT)))
                                        {
                                            //Line 4 has to be /TREF/ and line 5 has to be /CHGS/
                                            if (!(Regex.IsMatch(xNodeLine4.InnerText, Constants.LINE4FORMAT)))
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, xNodeLine4.Name,
                                                                     xNodeLine4.InnerText);
                                                isValid = false;
                                            }
                                            if (!(Regex.IsMatch(xNodeLine5.InnerText, Constants.LINE5FORMAT)))
                                            {
                                                errorObject.AddError(errorCode, policyName, ruleName, xNodeLine5.Name,
                                                                     xNodeLine5.InnerText);
                                                isValid = false;
                                            }
                                            else
                                                currencyAmount = xNodeLine5.InnerText.Substring(6);
                                        }
                                        else
                                        {
                                            currencyAmount = xNodeLine5.InnerText.Substring(6);
                                            errorObject.AddError(errorCode, policyName, ruleName, xNodeLine6.Name,
                                                                 xNodeLine6.InnerText);
                                            isValid = false;
                                        }
                                    }
                                }

                                //If /TEXT/ does not exist in the document.
                                else
                                {
                                    //If line 5 exists in the document,then line 5 has to be /CHGS/ and line 4 has to be /TREF/
                                    if (xNodeLine5 != null)
                                    {
                                        if (!(Regex.IsMatch(xNodeLine4.InnerText, Constants.LINE4FORMAT)))
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, xNodeLine4.Name,
                                                                 xNodeLine4.InnerText);
                                            isValid = false;
                                        }
                                        if (!(Regex.IsMatch(xNodeLine5.InnerText, Constants.LINE5FORMAT)))
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, xNodeLine5.Name,
                                                                 xNodeLine5.InnerText);
                                            isValid = false;
                                        }
                                        else
                                            currencyAmount = xNodeLine5.InnerText.Substring(6);
                                    }
                                    // If only line 4 exists in the document.
                                    else if (xNodeLine4 != null)
                                    {
                                        //Line can be /TREF/ or /CHGS/
                                        if (!((Regex.IsMatch(xNodeLine4.InnerText, Constants.LINE4FORMAT)) ||
                                             (Regex.IsMatch(xNodeLine4.InnerText, Constants.LINE5FORMAT))))
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, xNodeLine4.Name,
                                                                 xNodeLine4.InnerText);
                                            isValid = false;
                                        }
                                        else if (Regex.IsMatch(xNodeLine4.InnerText, Constants.LINE5FORMAT))
                                            currencyAmount = xNodeLine4.InnerText.Substring(6);
                                    }
                                    //If Line 6 exists without having /TEXT/, Throw an error.
                                    if (xNodeLine6 != null)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, xNodeLine6.Name,
                                                             xNodeLine6.InnerText);
                                        isValid = false;
                                    }
                                }


                                // If Currency and amount exists
                                if (!(currencyAmount.Equals("")))
                                {
                                    currency = currencyAmount.Substring(0, 3);
                                    amount = currencyAmount.Substring(3);

                                    // Amount length should lie in the range of {1,15}
                                    if (amount.Length >= 1 && amount.Length <= 15)
                                    {
                                        //Check the Currency code and corresponding amount allowed for the specifed currency.
                                        bool isValidCurrencyAmount = CheckCurrencyAmount(currency, amount,
                                         true, true, true,
                                        Constants.ERRORC03, Constants.ELEMENTCURRENCYNAME,
                                        Constants.AMOUNT, ruleName, policyName,
                                        errorObject);
                                    }
                                    else
                                    {
                                        errorObject.AddError(Constants.ERRORC03, policyName, ruleName, Constants.AMOUNT, amount);
                                        isValid = false;
                                    }
                                }
                            }
                        }
                    }
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        ///QFE2844
        ////// <method>
        ///		SwiftNetworkRuleT51
        /// </method>
        /// <summary>
        ///		This function performs validation to ensure that the Indicator subfield 
        ///		does not start with more than two slash.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SwiftNetworkRuleT51(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRuleT51" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;

                }


                string[] xPathTagArray = xPath.Split(Constants.CHRCOMMA);
                int lengthxPathTag = xPathTagArray.Length;

                for (int nCount = 0; nCount < lengthxPathTag; nCount++)
                {
                    XmlNode xRoot = xDocument.Document;
                    XmlNodeList nodeList = xRoot.SelectNodes(xPathTagArray[nCount]);
                    if (nodeList.Count != 0)
                    {
                        foreach (XmlNode xNode in nodeList)
                        {
                            if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                            {
                                if (xNode.InnerText.StartsWith(Constants.DOUBLESLASH))
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        xNode.ParentNode.ParentNode.Name, xNode.InnerText);

                                    isValid = false;
                                }

                            }
                            else
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNode.ParentNode.ParentNode.Name, Constants.NOCONTENT);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        ///<method>
        ///		SWIFTNetworkRule59_SRG2005
        ///</method>
        /// <summary>
        /// 	In sequence B, the presence of field 19A of the Next Interest Due Date (field :98A::INTR) depends
        /// 	on the Type of Loan/Deposit Event (field
        ///		:22H::TLDE) in sequence A. Message Number MT321.The Validation are as follows:
        ///
        ///		Sequence A			Sequence B		Sequence B		Sequence B		Sequence B		Sequence B
        ///		if field			then field		then field		then field		then field		then field
        /// 	22H::TLDE			:98A::INTR		:19A::SETT		:19A::RODI		:19A::CINT		:19A::NINT
        ///		Indicator is... 	is...			is...			is...			is...			is...
        /// 	CONF 				Mandatory 		Not allowed		Not allowed 	Not allowed 	Mandatory
        ///		ROLL				Mandatory 		Mandatory		Optional 		Optional		Mandatory
        ///		MATU 				Not allowed 	Mandatory 		Not allowed 	Optional 		Not allowed

        ///
        /// </summary>
        /// <param name="xDocument">
        /// 	Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPath22H">
        /// 	Input xPath of Field 22H
        /// </param>
        /// <param name="xPath98A">
        /// 	Input xPath of Field 98A
        /// </param>
        /// <param name="qualifier22H">
        /// 	Qualifier codelist of field 22H
        /// </param>
        /// <param name="qualifierList19A">
        /// 	Qualifier codelist of field 19A(comma seperated)
        /// </param>
        /// <param name="qualifier98A">
        /// 	Qualifier codelist of field 98A
        /// </param>
        /// <param name="xPathQualifier">
        /// 	Input xPath of Qualifier
        /// </param>
        /// <param name="xPathIndicator22H">
        /// 	Input Indicator of field 22H in comma separated list
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="codeList">
        ///		Input containing the code list.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        /// 	The Message Type that callls the function
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	ConditionalRule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	ConditionalRule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "bool">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule59_SRG2005(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath22H,
            string xPath19A,
            string xPath98A,
            string qualifier22H,
            string qualifierList19A,
            string qualifier98A,
            string xPathQualifier,
            string xPathIndicator22H,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule59_SRG2005" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPath22H == null ||
                    xPath22H.Length == 0 ||
                    xPath19A == null ||
                    xPath19A.Length == 0 ||
                    xPath98A == null ||
                    xPath98A.Length == 0 ||
                    qualifier22H == null ||
                    qualifier22H.Length == 0 ||
                    qualifierList19A == null ||
                    qualifierList19A.Length == 0 ||
                    qualifier98A == null ||
                    qualifier98A.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathIndicator22H == null ||
                    xPathIndicator22H.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    //Declare and Initialize all the function specific variables
                    bool isValid = true;
                    bool isFound = false;
                    bool isError = false;
                    bool isSETT = false;
                    bool isRODI = false;
                    bool isCINT = false;
                    bool isNINT = false;
                    int int98A = 0;

                    XmlNode xRoot = xDocument.Document;
                    //Select the nodeSequence A, field 22H
                    XmlNode xNode22H = xRoot.SelectSingleNode(xPath22H);
                    //Select the Qualifier of field 22H
                    XmlNode xNode22HQualifier = xNode22H.SelectSingleNode(xPathQualifier);

                    if (xNode22HQualifier != null && xNode22HQualifier.InnerText.Length != 0)
                    {
                        if (xNode22HQualifier.InnerText.CompareTo(qualifier22H) == 0)
                        {
                            //Store the comma separated list codeList in an string array
                            string[] codeListArray = codeList.Split(Constants.COMMA.ToCharArray());
                            string[] codeListQualifier19A = qualifierList19A.Split(Constants.COMMA.ToCharArray());
                            //Store the number of field 19A occurings in int19A and check if qualifer containes the list of
                            //qualifier supplied
                            XmlNodeList xListNode19A = xRoot.SelectNodes(xPath19A);
                            if (xListNode19A.Count != 0)
                            {
                                foreach (XmlNode xNode19A in xListNode19A)
                                {
                                    XmlNode xNode19AQualifier = xNode19A.SelectSingleNode(xPathQualifier);
                                    if (xNode19AQualifier != null && xNode19AQualifier.InnerText.Length != 0)
                                    {

                                        if (xNode19AQualifier.InnerText.CompareTo(codeListQualifier19A[0]) == 0)
                                        {
                                            isSETT = true;


                                        }
                                        else if (xNode19AQualifier.InnerText.CompareTo(codeListQualifier19A[1]) == 0)
                                        {
                                            isRODI = true;

                                        }
                                        else if (xNode19AQualifier.InnerText.CompareTo(codeListQualifier19A[2].ToString())
                                            == 0)
                                        {
                                            isCINT = true;

                                        }
                                        else if (xNode19AQualifier.InnerText.CompareTo(codeListQualifier19A[3].ToString())
                                            == 0)
                                        {
                                            isNINT = true;

                                        }

                                    }
                                }
                                //Store the number of field 98A::INTR occurings in int98A
                                XmlNodeList xListNode98A = xRoot.SelectNodes(xPath98A);
                                if (xListNode98A.Count != 0)
                                {
                                    foreach (XmlNode xNode98A in xListNode98A)
                                    {
                                        XmlNode xNode98AQualifier = xNode98A.SelectSingleNode(xPathQualifier);
                                        if (xNode98AQualifier != null && xNode98AQualifier.InnerText.Length != 0 && xNode98AQualifier.InnerText.CompareTo(qualifier98A) == 0)
                                            int98A++;
                                    }
                                }
                                //Select the node Indicator, field 22H
                                XmlNode xNode22HIndicator = xNode22H.SelectSingleNode(xPathIndicator22H);
                                //loop through all the codelist values
                                for (int count = 0; count <= codeListArray.Length - 1; count++)
                                {
                                    if (codeListArray[count] == xNode22HIndicator.InnerText)
                                        isFound = true;
                                    if (isFound)
                                    {
                                        if (count == 0 && (!isNINT || int98A == 0 || isCINT || isRODI || isSETT))

                                            isError = true;

                                        else if (count == 1 && (!isNINT || !isSETT || int98A == 0))

                                            isError = true;

                                        else if (count == 2 && (isNINT || isRODI || !isSETT || int98A > 0))

                                            isError = true;
                                    }

                                    isFound = false;
                                    if (isError)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                        isError = false;

                                    }
                                }
                            }
                        }

                    }
                    return isValid;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }
        /// <method>
        /// 	SwiftNetworkRule59
        /// </method>
        /// <summary>
        /// In sequence A, if field 77D is present and if the first six characters of the first line are equal to /VALD/, 
        /// then the second line must be present and contain /SETC/ followed by a currency code and the 
        /// end of line code, ie CrLf (Error code(s): C59)
        /// </summary>
        /// <param name="xDocument">
        /// 	XmlDocument
        /// </param>
        /// <param name="xPathTag">
        /// 	xPathTag of field 
        /// </param>
        /// <param name="errorCode">
        /// 	error code C59
        /// </param>
        /// <param name="policyName">
        /// 	Policy Name
        /// </param>
        /// <param name="ruleName">
        /// 	Rule name
        /// </param>
        /// <param name="ruleName">
        /// 	MessageType
        /// </param>
        /// <param name="errorObject">
        /// 	error object
        /// </param>
        /// <returns>
        /// 	returns true if validation succeeds,
        /// 	else returns false.
        /// </returns>
        public static bool SwiftNetworkRule59_2008(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SwiftNetworkRule59_2008" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                String currency = String.Empty;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList nodeList = xRoot.SelectNodes(xPathTag);
                foreach (XmlNode node in nodeList)
                {
                    //Check if /SETC/ if present other than line 2
                    if (!IsAtValidLine(node, Constants.CODESETC, 2))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, node.Name, Constants.BLANK);
                        return isValid = false;
                    }
                    //Check if /SRCE/ if present other than line 3
                    if (!IsAtValidLine(node, Constants.CODESRCE, 3))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, node.Name, Constants.BLANK);
                        return isValid = false;
                    }
                    if (node.InnerText != null && node.InnerText.Length != 0)
                    {
                        XmlNode xNodeLine1 = node.ChildNodes[0];
                        XmlNode xNodeLine2 = node.ChildNodes[1];
                        XmlNode xNodeLine3 = node.ChildNodes[2];

                        #region Check1
                        // Check if  field 77D starts with /VALD/ or not.
                        if (xNodeLine1.InnerText.StartsWith(Constants.CODEVALD))
                        {
                            // Check if line2 of field 77D present and starts with code /SETC/ or not.
                            if (xNodeLine2 == null)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, xNodeLine1.ParentNode.Name, Constants.BLANK);
                                return isValid = false;
                            }

                            if (xNodeLine2.InnerText.StartsWith(Constants.CODESETC))
                            {

                                if (xNodeLine2.InnerText.Length != 9)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        xNodeLine2.ParentNode.Name, xNodeLine2.InnerText);
                                    isValid = false;
                                }
                                else
                                {
                                    //check whether Currency used is valid ISO currency
                                    currency = xNodeLine2.InnerText.Substring(6);

                                    if (!SqlConnector.hashCurrencyCodeList.ContainsKey(currency))
                                    {

                                        errorObject.AddError(errorCode, policyName, ruleName,
                                            "CurrencyCode", currency);
                                        isValid = false;

                                    }
                                }
                            }

                            else
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNodeLine2.ParentNode.Name, xNodeLine2.InnerText);
                                isValid = false;
                            }
                        }
                        #endregion
                        #region Check1ViceVersa
                        //Case to check Vice Versa
                        if (!xNodeLine1.InnerText.StartsWith(Constants.CODEVALD))
                        {
                            if (xNodeLine2 != null)
                            {
                                if ((xNodeLine2.InnerText.StartsWith(Constants.CODESETC) || (xNodeLine2.InnerText.IndexOf(Constants.CODESETC) > 0)))
                                {
                                    //Adding error when line2 is /SETC/ while Line 1 is not /VALD/
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        xNodeLine2.ParentNode.Name, xNodeLine2.InnerText);
                                    isValid = false;

                                    if (xNodeLine2.InnerText.Length != 9)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName,
                                            xNodeLine2.ParentNode.Name, xNodeLine2.InnerText);
                                        isValid = false;
                                    }
                                    else
                                    {
                                        //Check whether Currency used is valid ISO currency
                                        currency = xNodeLine2.InnerText.Substring(6);
                                        if (!SqlConnector.hashCurrencyCodeList.ContainsKey(currency))
                                        {

                                            errorObject.AddError(errorCode, policyName, ruleName,
                                                "CurrencyCode", currency);
                                            isValid = false;

                                        }
                                    }
                                }
                            }
                        }
                        #endregion
                        #region //Adding error when line2 is not /SETC/ while Line 3 is not /SRCE/
                        if (xNodeLine3 != null)
                        {
                            if ((xNodeLine3.InnerText.StartsWith(Constants.CODESRCE) || (xNodeLine3.InnerText.IndexOf(Constants.CODESRCE) > 0)))
                            {
                                if (!xNodeLine2.InnerText.StartsWith(Constants.CODESETC))
                                {
                                    //Adding error when line2 is not /SETC/ while Line 3 is not /SRCE/
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        xNodeLine3.ParentNode.Name, xNodeLine3.InnerText);
                                    isValid = false;
                                }
                            }
                        }
                        #endregion
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }
        /// <method>
        ///		SWIFTNetworkRule291_SRG2005
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 291.
        ///		In each occurrence of Sequence C, the field 22H::PRIT//APCP or IPCP
        ///		must contain 95a::CDEA in one occurrence of Sequence C1 or
        ///		22H::PRIT//APFM or IPFM must contain 95a::ACCW in one occurrence of
        ///		Sequence C1
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath22H" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath95List" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathSequenceC" type = "string">
        ///		Input reference of the element to be validated - //SequenceC.
        /// </param>
        /// <param name ="xPathSequenceC1" type = "string">
        ///		Input reference of the element to be validated - ./SequenceC1.
        /// </param>
        /// <param name ="qualifier95List" type = "string">
        ///		Input containing the qualifier CDEA,ACCW.
        /// </param>
        /// <param name ="CodesList" type = "string">
        ///		Input containing the qualifier APCP,IPCP,APFM,IPFM.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>

        public static bool SWIFTNetworkRule291_SRG2005(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath22H,
            string xPath95List,
            string xPathSequenceC,
            string xPathSequenceC1,
            string qualifier95List,
            string codesList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {

            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule291_SRG2005" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            try
            {
                if (xDocument == null ||
                    xPath22H == null ||
                    xPath22H.Length == 0 ||
                    xPathSequenceC == null ||
                    xPathSequenceC.Length == 0 ||
                    xPathSequenceC1 == null ||
                    xPathSequenceC1.Length == 0 ||
                    xPath95List == null ||
                    xPath95List.Length == 0 ||
                    qualifier95List == null ||
                    qualifier95List.Length == 0 ||
                    codesList == null ||
                    codesList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                string[] xPath95Array = xPath95List.Split(Constants.CHRCOMMA);
                int lengthxPath = xPath95Array.Length;
                string[] xPathcodesArray = codesList.Split(Constants.CHRCOMMA);

                string[] qualifier95Array = qualifier95List.Split(Constants.CHRCOMMA);
                XmlNode xRoot = xDocument.Document;
                XmlNodeList xNodeSequenceCList = xRoot.SelectNodes(xPathSequenceC);

                foreach (XmlNode xNodeSequenceC in xNodeSequenceCList)
                {
                    bool isError = false;
                    bool isCodeAPCPorIPCP = false;
                    bool isCodeAPFMorIPFM = false;
                    bool isQualifierCDEA = false;
                    bool isQualifierACCW = false;
                    XmlNode xNode22H = xNodeSequenceC.SelectSingleNode(xPath22H);
                    if (xNode22H.InnerText != null && xNode22H.InnerText.Length != 0)
                    {
                        if ((xNode22H.LastChild.InnerText.ToString().CompareTo(xPathcodesArray[0].ToString()) == 0) ||
                            (xNode22H.LastChild.InnerText.ToString().CompareTo(xPathcodesArray[1].ToString()) == 0))
                        {
                            isCodeAPCPorIPCP = true;
                        }
                        else if ((xNode22H.LastChild.InnerText.ToString().CompareTo(xPathcodesArray[2].ToString()) == 0) ||
                            (xNode22H.LastChild.InnerText.ToString().CompareTo(xPathcodesArray[3].ToString()) == 0))
                        {
                            isCodeAPFMorIPFM = true;
                        }

                    }
                    for (int i = 0; i < xPath95Array.Length; i++)
                    {
                        string xPath95a = xPathSequenceC1 + xPath95Array[i];
                        XmlNodeList xNode95a = xNodeSequenceC.SelectNodes(xPath95a);



                        foreach (XmlNode xNode95 in xNode95a)
                        {
                            if (xNode95.InnerText != null && xNode95.InnerText.Length != 0)
                            {
                                if (xNode95.FirstChild.InnerText.ToString().CompareTo(qualifier95Array[0].ToString()) == 0)
                                {
                                    isQualifierCDEA = true;
                                }
                                else if (xNode95.FirstChild.InnerText.ToString().CompareTo(qualifier95Array[1].ToString()) == 0)
                                {
                                    isQualifierACCW = true;
                                }

                            }
                        }

                    }
                    if (isCodeAPCPorIPCP && !isQualifierCDEA)
                    {
                        isError = true;
                    }
                    else if (isCodeAPFMorIPFM && !isQualifierACCW)
                    {
                        isError = true;
                    }

                    if (isError)
                    {
                        errorObject.AddError(errorCode, policyName,
                            ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        return false;
                    }



                }

                return true;

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


        }
        /// <method>
        ///		IsValidCurrencyInSignCodeAmount
        /// </method>
        /// <summary>
        ///		This method performs a check on the Currencies of all tags specified in xPath1.
        ///		This is an overloaded function which takes into account the structure of signcodeamount
        ///		and then performs validation for currency for tags using this structure.
        /// </summary>
        /// <param name="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPath1" type = "string">
        ///		List of Comma Separated xPath which contain Currency Clubbed with other fields i.e. SignCodeAmount.
        ///		Here Code part Contains Currency.
        /// </param>
        /// <param name="errorCode" type = "string">
        ///		Error code to be displayed.
        /// </param>
        /// <param name="policyName" type = "string">
        ///		Input Containing PolicyName
        /// </param>
        /// <param name="ruleName" type = "string">
        ///		Input Containing Rule Name
        /// </param>
        ///	<param name="messageType" type = "string">
        ///		Input Containing MessageType.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        ///		Input Containing Conditional Rule Name
        /// </param>
        /// <param name="conditionalRuleNumber" type = "string">
        ///		Input containing Conditional Rule number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing Object Of ErrorCollection Class.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>

        public static bool IsValidCurrencyInSignCodeAmount_SRG2005(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath1,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidCurrencyInSignCodeAmount_SRG2005" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);

            bool isValid = true;
            int lengthxPath1 = 0;
            string currency = string.Empty;
            string tempValue = string.Empty;
            try
            {
                if (xDocument == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                string currencyCode = string.Empty;


                XmlNode xRoot = xDocument.Document;
                if (xPath1 != null)
                {
                    string[] xPath1Array = xPath1.Split(Constants.CHRCOMMA);
                    lengthxPath1 = xPath1Array.Length;

                    for (int nCount = 0; nCount <= lengthxPath1 - 1; nCount++)
                    {
                        XmlNodeList xList = xRoot.SelectNodes(xPath1Array[nCount].ToString());

                        foreach (XmlNode xNode in xList)
                        {
                            if (xNode.InnerText != null && xNode.InnerText.Length != 0)
                            {
                                int startPositionOfCurrency = 0;
                                currency = string.Empty;
                                tempValue = xNode.InnerText.Substring(3, 1);

                                if (Constants.ALPHASET.IndexOf(tempValue) == -1)
                                {
                                    startPositionOfCurrency = 0;
                                }

                                else
                                {
                                    startPositionOfCurrency = 1;
                                }

                                currency = xNode.InnerText.Substring(startPositionOfCurrency, 3);

                                if (currencyCode.CompareTo(Constants.BLANK) == 0)
                                {
                                    currencyCode = currency;
                                }

                                if (currency.CompareTo(currencyCode) != 0)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    isValid = false;
                                }
                            }
                            else
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNode.ParentNode.ParentNode.Name, Constants.NOCONTENT);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }
        /// <summary>
        /// If Sequence A contains 22a::COLA with indicator not equal to SLEB and DSS absent then 19A::TRAA must be present
        /// in the sequence whose xPath is passed as a parameter to function.
        /// </summary>
        /// <param name="xDocument">
        /// Input Reference to XML document
        /// </param>
        /// <param name="xPathTag22F">
        /// Input Reference to Tag 22F in Sequence A
        /// </param>
        /// <param name="xPathTag22H">
        /// Input Reference to Tag 22H in Sequence A
        /// </param>
        /// <param name="xPathSequence19A">
        /// Input Reference to the Sequence containing Tag 19A
        /// </param>
        /// <param name="xPathTag19A">
        /// Input Reference to Tag 19A
        /// </param>
        /// <param name="xPathQualifier">
        /// Input xPath of Qualifier
        /// </param>
        /// <param name="xPathIndicator">
        /// Input xPath of Indicator
        /// </param>
        /// <param name="xPathDataSourceScheme">
        /// Input xPath of DataSourceScheme
        /// </param>
        /// <param name="qualifier22a">
        /// Qualifier codelist of field 22a
        /// </param>
        /// <param name="quailfier19A">
        /// Qualifier codelist of field 19A
        /// </param>
        /// <param name="indicator22a">
        /// Indicator codelist of field 22F,22H
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        /// 	The Message Type that callls the function
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	ConditionalRule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	ConditionalRule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule265_SRG2005(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag22F,
            string xPathTag22H,
            string xPathSequence19A,
            string xPathTag19A,
            string xPathQualifier,
            string xPathIndicator,
            string xPathDataSourceScheme,
            string qualifier22a,
            string quailfier19A,
            string indicator22a,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule265_SRG2005" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag22F == null ||
                    xPathTag22F.Length == 0 ||
                    xPathTag22H == null ||
                    xPathTag22H.Length == 0 ||
                    xPathSequence19A == null ||
                    xPathSequence19A.Length == 0 ||
                    xPathTag19A == null ||
                    xPathTag19A.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathIndicator == null ||
                    xPathIndicator.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    errorObject == null)
                {
                    isValid = false;
                }
                else
                {
                    XmlNode xRoot = xDocument.Document;
                    //Get all the nodes from 22H
                    XmlNodeList xNodeList22H = xRoot.SelectNodes(xPathTag22H);
                    bool isPresent = false;// checks if any occurrences of 22H with COLA as a
                    //qualifier,indicator other than SLEB and DSS absent

                    // Check the functionality for 22H
                    foreach (XmlNode xNode22H in xNodeList22H)
                    {
                        XmlNode xNode22HQualifier = xNode22H.SelectSingleNode(xPathQualifier);

                        if (xNode22HQualifier != null && xNode22HQualifier.InnerText.CompareTo(qualifier22a) == 0)
                        {
                            XmlNode xNode22Hindicator = xNode22H.SelectSingleNode(xPathIndicator);
                            if (xNode22Hindicator != null && xNode22Hindicator.InnerText.CompareTo(indicator22a) != 0)
                            {
                                isPresent = true;
                                break;
                            }
                        }
                    }

                    XmlNodeList xNodeList22F = xRoot.SelectNodes(xPathTag22F);
                    // Check the functionality for 22F
                    foreach (XmlNode xNode22F in xNodeList22F)
                    {
                        XmlNode xNode22FQualifier = xNode22F.SelectSingleNode(xPathQualifier);
                        if (xNode22FQualifier != null && xNode22FQualifier.InnerText.CompareTo(qualifier22a) == 0)
                        {
                            XmlNode xNode22Findicator = xNode22F.SelectSingleNode(xPathIndicator);
                            XmlNode xNode22FDataSourceScheme = xNode22F.SelectSingleNode(xPathDataSourceScheme);
                            if (xNode22Findicator != null && xNode22Findicator.InnerText.CompareTo(indicator22a) != 0 && xNode22FDataSourceScheme == null)
                            {
                                isPresent = true;
                                break;
                            }
                        }
                    }
                    //once 22a check is done, check whether 19ATRAA exists in specified sequence
                    if (isPresent && !CheckIfFieldPresent_SRG2005(xRoot, xPathSequence19A, xPathTag19A, xPathQualifier, quailfier19A))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        /// <summary>
        /// If Sequence C contains 22a::COLA with indicator not equal to SLEB and DSS absent then  sequence C1 and 19A::TRAA must be present
        /// in the sequence C1a whose xPath is passed as a parameter to function.
        /// </summary>
        /// <param name="xDocument">
        /// Input Reference to XML document
        /// </param>
        /// <param name="xPathTag22F">
        /// Input Reference to Tag 22F in Sequence C
        /// </param>
        /// <param name="xPathSequenceC1">
        /// Input Reference to the Sequence C1
        /// </param>
        /// <param name="xPathTag19A">
        /// Input Reference to Tag 19A
        /// </param>
        /// <param name="xPathQualifier">
        /// Input xPath of Qualifier
        /// </param>
        /// <param name="xPathIndicator">
        /// Input xPath of Indicator
        /// </param>
        /// <param name="xPathDataSourceScheme">
        /// Input xPath of DataSourceScheme
        /// </param>
        /// <param name="qualifier22a">
        /// Qualifier codelist of field 22a
        /// </param>
        /// <param name="quailfier19A">
        /// Qualifier codelist of field 19A
        /// </param>
        /// <param name="indicator22a">
        /// Indicator codelist of field 22F,22H
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        /// 	The Message Type that callls the function
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	ConditionalRule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	ConditionalRule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule265_SRG2005(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag22F,
            string xPathSequenceC1,
            string xPathTag19A,
            string xPathQualifier,
            string xPathIndicator,
            string xPathDataSourceScheme,
            string qualifier22a,
            string quailfier19A,
            string indicator22a,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule265_SRG2005" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPathTag22F == null ||
                    xPathTag22F.Length == 0 ||
                    xPathSequenceC1 == null ||
                    xPathSequenceC1.Length == 0 ||
                    xPathTag19A == null ||
                    xPathTag19A.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathIndicator == null ||
                    xPathIndicator.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    errorObject == null)
                {
                    isValid = false;
                }
                else
                {
                    XmlNode xRoot = xDocument.Document;
                    XmlNodeList xNodeList22F = xRoot.SelectNodes(xPathTag22F);
                    bool isPresent = false;
                    // Check the functionality for 22F
                    foreach (XmlNode xNode22F in xNodeList22F)
                    {
                        XmlNode xNode22FQualifier = xNode22F.SelectSingleNode(xPathQualifier);
                        if (xNode22FQualifier != null && xNode22FQualifier.InnerText.CompareTo(qualifier22a) == 0)
                        {
                            XmlNode xNode22Findicator = xNode22F.SelectSingleNode(xPathIndicator);
                            XmlNode xNode22FDataSourceScheme = xNode22F.SelectSingleNode(xPathDataSourceScheme);
                            if (xNode22Findicator != null && xNode22Findicator.InnerText.CompareTo(indicator22a) != 0 && xNode22FDataSourceScheme == null)
                            {
                                isPresent = true;
                                break;
                            }
                        }
                    }
                    bool c1Present = false;
                    if (xRoot.SelectNodes(xPathSequenceC1).Count > 1)
                    {
                        c1Present = true;
                    }
                    //once 22a check is done, check whether 19ATRAA exists in specified sequence
                    if ((isPresent && !CheckIfFieldPresent_SRG2005(xRoot, xPathSequenceC1, xPathTag19A, xPathQualifier, quailfier19A)) || (isPresent && !c1Present))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }

        //SWIFTNetworkRule263
        /// <summary>
        /// If Sequence B contains 98a::ISSU then  sequence B 98a::RELD must be present.
        /// </summary>
        /// <param name="xDocument">
        /// Input Reference to XML document
        /// </param>
        /// <param name="xPathSequenceB">
        /// Input Reference to the Sequence B
        /// </param>
        /// <param name="xPathTag98A">
        /// Input Reference to Tag 98a in Sequence B
        /// </param>
        /// <param name="xPathTag98C">
        /// Input Reference to Tag 98a in Sequence B
        /// </param>
        /// <param name="xPathTag98">
        /// Input Reference to Tag 98a in Sequence B
        /// </param>
        /// <param name="xPathQualifier">
        /// Input xPath of Qualifier
        /// </param>
        /// <param name="qualifierIssu">
        /// Qualifier codelist of field 98a
        /// </param>
        /// <param name="quailfierReld">
        /// Qualifier codelist of field 98a
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        /// 	The Message Type that callls the function
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	ConditionalRule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	ConditionalRule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule263(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceB,
            string xPathTag98A,
            string xPathTag98C,
            string xPathTag98,
            string xPathQualifier,
            string qualifierIssu,
            string quailfierReld,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule263" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;

            try
            {
                if (xDocument == null ||
                    xPathSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPathTag98A == null ||
                    xPathTag98A.Length == 0 ||
                    xPathTag98C == null ||
                    xPathTag98C.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    qualifierIssu == null ||
                    qualifierIssu.Length == 0 ||
                    quailfierReld == null ||
                    quailfierReld.Length == 0 ||
                    errorObject == null)
                {
                    isValid = false;
                }
                else
                {
                    XmlNode xRoot = xDocument.Document;
                    //Get all the nodes from 98A
                    XmlNodeList xNodeList98A = xRoot.SelectNodes(xPathTag98A);
                    bool isPresent = false;
                    // checks if any occurrences of 98A with qualifier other than ISSU.

                    // Check the functionality for 98A
                    foreach (XmlNode xNode98A in xNodeList98A)
                    {
                        XmlNode xNode98AQualifier = xNode98A.SelectSingleNode(xPathQualifier);

                        if (xNode98AQualifier != null && xNode98AQualifier.InnerText.CompareTo(qualifierIssu) == 0)
                        {
                            isPresent = true;
                            break;

                        }
                    }

                    XmlNodeList xNodeList98C = xRoot.SelectNodes(xPathTag98C);

                    // checks if any occurrences of 98C with qualifier other than ISSU.				
                    // Check the functionality for 98C
                    foreach (XmlNode xNode98C in xNodeList98C)
                    {
                        XmlNode xNode98CQualifier = xNode98C.SelectSingleNode(xPathQualifier);

                        if (xNode98CQualifier != null && xNode98CQualifier.InnerText.CompareTo(qualifierIssu) == 0)
                        {
                            isPresent = true;
                            break;

                        }
                    }
                    if ((!isPresent && !CheckIfFieldPresent(xRoot, xPathSequenceB, xPathTag98, xPathQualifier, quailfierReld)))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;

        }
        /// <summary>
        /// This is private helper function. It checks whether the specified tag contains the
        /// specified value in a specified sequence.
        /// </summary>
        /// <param name="xRoot">
        /// Input reference to the XMLnode in which the search to be performed.
        /// </param>
        /// <param name="xPathSequence">
        /// Input reference to Sequence.
        /// </param>
        /// <param name="xPathTag">
        /// Input reference to tag.
        /// </param>
        /// <param name="xPathField">
        /// Input reference to the field.
        /// </param>
        /// <param name="Value">
        /// It specifies the value for the specified tag.
        /// </param>
        /// <returns>
        /// true if the condition is met for every occurence of the specified sequence other wise false.
        /// </returns>
        private static bool CheckIfFieldPresent_SRG2005(XmlNode xRoot,
            string xPathSequence,
            string xPathTag,
            string xPathField,
            string Value)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckIfFieldPresent_SRG2005:");
            bool isValid = true;
            try
            {
                if (xRoot == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathField == null ||
                    xPathField.Length == 0)
                {
                    isValid = false;
                }
                else
                {
                    //Get all occurences of the specified sequence
                    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                    // if no sequence is found true value is to be returned.
                    foreach (XmlNode xSequence in xListSequence)
                    {
                        XmlNodeList xNodeList = xSequence.SelectNodes(xPathTag);
                        isValid = false;//initialisation to false at the beginning of search.
                        foreach (XmlNode xNode in xNodeList)
                        {
                            XmlNode xNodeField = xNode.SelectSingleNode(xPathField);
                            if (xNodeField != null && xNodeField.InnerText.CompareTo(Value) == 0)
                            {
                                isValid = true;//occurence found so make it true
                                //break the search for the current sequence.
                                break;
                            }
                        }
                        if (!isValid) break;// Return if the sequence doesnt have the specified tag with the
                        // specified value.
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }


        /// <summary>
        /// This is private helper function. It checks whether the specified tag contains the
        /// specified value in a specified sequence.
        /// </summary>
        /// <param name="xRoot">
        /// Input reference to the XMLnode in which the search to be performed.
        /// </param>
        /// <param name="xPathSequence">
        /// Input reference to Sequence.
        /// </param>
        /// <param name="xPathTag">
        /// Input reference to tag.
        /// </param>
        /// <param name="xPathField">
        /// Input reference to the field.
        /// </param>
        /// <param name="Value">
        /// It specifies the value for the specified tag.
        /// </param>
        /// <returns>
        /// true if the condition is met for every occurence of the specified sequence other wise false.
        /// </returns>
        private static bool CheckIfFieldPresent(XmlNode xRoot,
            string xPathSequence,
            string xPathTag,
            string xPathField,
            string Value)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckIfFieldPresent:");
            bool isValid = true;
            try
            {
                if (xRoot == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    xPathField == null ||
                    xPathField.Length == 0)
                {
                    isValid = false;
                }
                else
                {
                    string[] xPathTagArray = xPathTag.Split(Constants.CHRCOMMA);
                    int lengthxPath = xPathTagArray.Length;
                    isValid = false;//initialisation to false at the beginning of search.
                    for (int count = 0; count < lengthxPath; count++)
                    {
                        //Get all occurences of the specified sequence
                        XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                        // if no sequence is found true value is to be returned.
                        foreach (XmlNode xSequence in xListSequence)
                        {
                            XmlNodeList xNodeList = xSequence.SelectNodes(xPathTagArray[count]);

                            foreach (XmlNode xNode in xNodeList)
                            {
                                XmlNode xNodeField = xNode.SelectSingleNode(xPathField);
                                if (xNodeField != null && xNodeField.InnerText.CompareTo(Value) == 0)
                                {
                                    isValid = true;//occurence found so make it true
                                    //break the search for the current sequence.
                                    break;
                                }
                            }
                            if (!isValid) break;// Return if the sequence doesnt have the specified tag with the
                            // specified value.
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <summary>
        /// In each occurrence of sequence D, E and E1, if field :92E::TAXC or/and :92J::TAXC is/are present more than once,
        /// then for each occurrence of field :92a::TAXC, the Rate Type Code must be different (Error code(s): E78).
        /// </summary>
        /// <param name="xDocument">
        /// Input Reference to XML document
        /// </param>
        /// <param name="xPathSequenceList">
        /// Input Reference to the Sequences in which the check is to be made.
        /// </param>
        /// <param name="xPathList">
        /// Input Reference to List of Tags in which the check is to be made.
        /// </param>
        /// <param name="xPathQualifier">
        /// Input xPath of Qualifier
        /// </param>
        /// <param name="xPathRateTypeCode">
        /// Input xPath of RateTypeCode
        /// </param>
        /// <param name="qualifier92a">
        /// Qualifier codelist for 92a
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        /// 	The Message Type that callls the function
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	ConditionalRule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	ConditionalRule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule278_SRG2005(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequenceList,
            string xPathList,
            string xPathQualifier,
            string xPathRateTypeCode,
            string qualifier92a,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule278_SRG2005" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequenceList == null ||
                    xPathSequenceList.Length == 0 ||
                    xPathList == null ||
                    xPathList.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathRateTypeCode == null ||
                    xPathRateTypeCode.Length == 0 ||
                    errorObject == null)
                {
                    isValid = false;
                }
                else
                {
                    if (null == qualifier92a) throw new ArgumentNullException("qualifier92a");

                    int lengthxPath = 0;
                    int lengthxPathSequence = 0;

                    string[] xPathSequenceArray = xPathSequenceList.Split(Constants.CHRCOMMA);
                    lengthxPathSequence = xPathSequenceArray.Length;
                    string[] xPathArray = xPathList.Split(Constants.CHRCOMMA);
                    lengthxPath = xPathArray.Length;
                    XmlNode xRoot = xDocument.Document;
                    // Create Hash RateTypeCodeHashTablele to check for different RateTypeCodes at multiple occurence
                    // of Tag 92a with specfied Qualifier Values.
                    Hashtable RateTypeCodeHashTable = new Hashtable();
                    for (int i = 0; i <= lengthxPathSequence - 1; i++)
                    {
                        XmlNodeList xSequenceList = xRoot.SelectNodes(xPathSequenceArray[i].ToString());

                        foreach (XmlNode xSequenceNode in xSequenceList)
                        {
                            for (int j = 0; j <= lengthxPath - 1; j++)
                            {
                                XmlNodeList xList = xSequenceNode.SelectNodes(xPathArray[j].ToString());
                                foreach (XmlNode xNode in xList)
                                {
                                    XmlNode xNodeQualifier = xNode.SelectSingleNode(xPathQualifier);

                                    if (xNodeQualifier != null && xNodeQualifier.InnerText != null)
                                    {
                                        string[] qualifierArray = qualifier92a.Split(Constants.CHRCOMMA);
                                        foreach (string code in qualifierArray)
                                        {
                                            if (xNodeQualifier.InnerText.IndexOf(code) != -1)
                                            {
                                                XmlNode xNodeRateTypeCode = xNode.SelectSingleNode(xPathRateTypeCode);
                                                if (xNodeRateTypeCode != null)
                                                {
                                                    try
                                                    {
                                                        RateTypeCodeHashTable.Add(xNodeQualifier.InnerText + ":" + xNodeRateTypeCode.InnerText, "RateTypeCode");
                                                    }
                                                    // if RateTypeCode contains same values at multiple occurences
                                                    // of 92a then HashRateTypeCodeHashTablele with the same keyvalues throws ArgumentException
                                                    catch (ArgumentException)
                                                    {
                                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                        isValid = false;
                                                        return isValid;
                                                    }
                                                }
                                                break;
                                            }

                                        }
                                    }

                                }
                            }
                            RateTypeCodeHashTable.Clear();
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <summary>
        /// If field :70E::NAME is used in sequence D, then field 22F:CAEV//NAME must be present in Seq. A. (Error code(s):
        /// D99).
        /// </summary>
        /// <param name="xDocument">
        /// Input Reference to XML document
        /// </param>
        /// <param name="xPathTag22F">
        /// Input Reference to Tag 22F in Sequence A
        /// </param>
        /// <param name="xPathTag70E">
        /// Input Reference to Tag 70E
        /// </param>
        /// <param name="xPathQualifier">
        /// Input xPath of Qualifier
        /// </param>
        /// <param name="xPathIndicator">
        /// Input xPath of Indicator
        /// </param>
        /// <param name="xPathDataSourceScheme">
        /// Input xPath of DataSourceScheme
        /// </param>
        /// <param name="qualifier22F">
        /// Qualifier codelist of field 22a
        /// </param>
        /// <param name="quailfier70E">
        /// Qualifier codelist of field 19A
        /// </param>
        /// <param name="indicator22F">
        /// Indicator codelist of field 22F,22H
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        /// 	The Message Type that callls the function
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	ConditionalRule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	ConditionalRule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule199_SRG2005(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag22F,
            string xPathTag70E,
            string xPathQualifier,
            string xPathIndicator,
            string xPathDataSourceScheme,
            string qualifier22F,
            string qualifier70E,
            string indicator22F,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule199_SRG2005" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag22F == null ||
                    xPathTag22F.Length == 0 ||
                    xPathTag70E == null ||
                    xPathTag70E.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathIndicator == null ||
                    xPathIndicator.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    errorObject == null)
                {
                    isValid = false;
                }
                else
                {
                    XmlNode xRoot = xDocument.Document;
                    XmlNodeList xNodeList70E = xRoot.SelectNodes(xPathTag70E);

                    foreach (XmlNode xNode70E in xNodeList70E)
                    {
                        XmlNode xNode70EQualifier = xNode70E.SelectSingleNode(xPathQualifier);
                        if (xNode70EQualifier != null && xNode70EQualifier.InnerText.CompareTo(qualifier70E) == 0)
                        {
                            isValid = false;// Initialization to false when Tag 70E with specified Qualifier
                            //is present.
                            XmlNodeList xNodeList22F = xRoot.SelectNodes(xPathTag22F);
                            foreach (XmlNode xNode22F in xNodeList22F)
                            {
                                XmlNode xNode22FQualifier = xNode22F.SelectSingleNode(xPathQualifier);
                                XmlNode xNode22Findicator = xNode22F.SelectSingleNode(xPathIndicator);
                                XmlNode xNode22FDataSourceScheme = xNode22F.SelectSingleNode(xPathDataSourceScheme);
                                // InValid condition if Tag22F with specified pair of Qualifier and Indicator
                                // is not present and if DSS is present.

                                if (xNode22FQualifier != null && xNode22FQualifier.InnerText.CompareTo(qualifier22F) == 0
                                    && xNode22Findicator != null && xNode22Findicator.InnerText.CompareTo(indicator22F) == 0
                                    && (xNode22FDataSourceScheme == null || xNode22FDataSourceScheme.InnerText.Length == 0))
                                {
                                    isValid = true;
                                    break;
                                }
                            }
                        }
                    }

                }
                if (!isValid)
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule152_SRG2005
        /// </method>
        /// <summary>
        ///		This function performs validation to ensure that the maximum and minimum occurrence
        ///		for the Sequence is within specified limits.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="nCountMinRepetition" type ="int">
        ///		Input Count for Minimum number of Repeatition
        /// </param>
        /// <param name ="nCountMaxRepetition" type ="int">
        ///		Input Count for Maximum number of Repetition
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the Conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule152_SRG2005(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathList,
            int nCountMinRepetition,
            int nCountMaxRepetition,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule152_SRG2005" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int nCount = 0;
            try
            {
                if (xDocument == null ||
                    xPathList == null ||
                    xPathList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                string[] xPathArray = xPathList.Split(Constants.CHRCOMMA);
                for (int i = 0; i < xPathArray.Length; i++)
                {
                    XmlNodeList xList = xRoot.SelectNodes(xPathArray[i]);
                    nCount += xList.Count;
                }

                if (nCount > nCountMaxRepetition || nCount < nCountMinRepetition)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }
        ///<method>
        ///		SWIFTNetworkRule50_SRG2006
        /// </method>
        /// <summary>
        ///		If field :36B: is present in minimum one occurrence of sequence A1, 
        ///		then the type of settlement transaction must be a pair-off or turn-around; ie, 
        ///		sequence E field :22F::SETR//PAIR or :22F::SETR//TURN must be present
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath36B" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="indicatorList" type = "string">
        ///		Input containing the indicatorList = PAIR and TURN.
        /// </param>
        /// <param name ="qualifierSETR" type = "string">
        ///		Input containing the qualifier SETR.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule50_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath36B,
            string xPath22F,
            string xPathDataSource,
            string indicatorList,
            string qualifierSETR,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule50_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            string x22FStr = String.Empty;
            try
            {
                if (xDocument == null ||
                    xPath36B == null ||
                    xPath36B.Length == 0 ||
                    xPath22F == null ||
                    xPath22F.Length == 0 ||
                    xPathDataSource == null ||
                    xPathDataSource.Length == 0 ||
                    indicatorList == null ||
                    qualifierSETR == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                // get the 36B nodelist.
                XmlNodeList xNodeList36B = xRoot.SelectNodes(xPath36B);

                string xPathIndicator = Constants.XPATH + Constants.INDICATOR;
                XmlNodeList xNodes22F = xRoot.SelectNodes(xPath22F);
                XmlNode xDataSourceScheme;
                XmlNode xNodeIndicator;


                if (xNodeList36B != null && xNodeList36B.Count > 0)
                {
                    foreach (XmlNode xNode36B in xNodeList36B)
                    {
                        // check for presence of node 36B in sequence A1
                        if (xNode36B != null)
                        {
                            isValid = true;
                            break;
                        }
                        else
                        {
                            isValid = false;
                        }
                    }
                }
                else
                {
                    return true;
                }


                if (isValid)
                {
                    foreach (XmlNode xNode22F in xNodes22F)
                    {
                        // if 36B: is present then sequence E::22F node must be SETR
                        if (xNode22F != null && xNode22F.FirstChild != null)
                        {
                            if (xNode22F.FirstChild.InnerText.CompareTo(qualifierSETR) == 0)
                            {
                                xDataSourceScheme = xNode22F.SelectSingleNode(xPathDataSource);
                                xNodeIndicator = xNode22F.SelectSingleNode(xPathIndicator);

                                // check for absence of datasource scheme and presence for indicator under 22F::SETR which should be PAIR or TURN
                                if (xDataSourceScheme == null && xNodeIndicator != null && indicatorList.IndexOf(xNodeIndicator.InnerText) != -1)
                                {
                                    isValid = true;
                                    break;
                                }
                                else
                                {
                                    isValid = false;
                                }
                            }
                        }
                    }
                }
                if (!isValid)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }
        ///<method>
        ///		SWIFTNetworkRule73_SRG2006
        /// </method>
        /// <summary>
        /// A reference to the previously received message must be specified for each transaction reported,
        ///  i.e. in each occurrence of subsequence B2 Transaction, field :20C::RELA must be present in one 
        ///  and only one occurrence of subsequence B2a Linkages; field :20C::RELA is not allowed in all 
        ///  other occurrences of subsequence B2a 
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        ///		Reference path of the sequence
        /// </param>
        /// <param name ="xPath20C" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the qualifier RELA.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule73_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath20C,
            string xPathQualifier,
            string qualifierValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule73_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int fieldCount = 0;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPath20C == null ||
                    xPathQualifier == null ||
                    qualifierValue == null ||
                    xPathSequence.Length == 0 ||
                    xPath20C.Length == 0 ||
                    xPathQualifier.Length == 0 ||
                    qualifierValue.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xNodeList = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNode in xNodeList)
                {
                    // Gets the node for 20C
                    XmlNodeList xNodeList20C = xNode.SelectNodes(xPath20C);
                    fieldCount = 0;  //Resets Field Count to 0 for next sequence

                    //check if the node has an Field 20C tag
                    if (xNodeList20C != null)
                    {
                        foreach (XmlNode xNode20C in xNodeList20C)
                        {
                            XmlNode xNodeQualifier = xNode20C.SelectSingleNode(xPathQualifier);

                            //check for one occurence of qualifier RELA
                            if (xNodeQualifier != null && xNodeQualifier.InnerText.CompareTo(qualifierValue) == 0)
                            {
                                fieldCount += 1;
                                if (fieldCount > 1)
                                {
                                    break;
                                }
                            }
                        }
                    }
                    if (fieldCount != 1)  // adds error to the error object if field 20C:RELA is not found once or found more than once
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        ///<method>
        ///		SWIFTNetworkRule74_SRG2006
        /// </method>
        /// <summary>
        /// A reference to the previously received message must be specified for each transaction reported,
        ///  i.e. in each occurrence of subsequence B2 Transaction, field :20C::RELA must be present in one 
        ///  and only one occurrence of subsequence B2a Linkages; field :20C::RELA is not allowed in all 
        ///  other occurrences of subsequence B2a 
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        ///		Reference path of the sequence
        /// </param>
        /// <param name ="xPath20C" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="qualifierValue" type = "string">
        ///		Input containing the qualifier RELA.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule74_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath20C,
            string xPathQualifier,
            string qualifierValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule74_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int fieldCount = 0;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPath20C == null ||
                    xPathQualifier == null ||
                    qualifierValue == null ||
                    xPathSequence.Length == 0 ||
                    xPath20C.Length == 0 ||
                    xPathQualifier.Length == 0 ||
                    qualifierValue.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xNodeList = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNode in xNodeList)
                {
                    // Gets the node for 20C
                    XmlNodeList xNodeList20C = xNode.SelectNodes(xPath20C);
                    fieldCount = 0;  //Resets Field Count to 0 for next sequence

                    //check if the node has an Field 20C tag
                    if (xNodeList20C != null)
                    {
                        foreach (XmlNode xNode20C in xNodeList20C)
                        {
                            XmlNode xNodeQualifier = xNode20C.SelectSingleNode(xPathQualifier);

                            //check for one occurence of qualifier RELA
                            if (xNodeQualifier != null && xNodeQualifier.InnerText.CompareTo(qualifierValue) == 0)
                            {
                                fieldCount += 1;
                                if (fieldCount > 1)
                                {
                                    break;
                                }
                            }
                        }
                    }
                    if (fieldCount != 1)  // adds error to the error object if field 20C:RELA is not found once or found more than once
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <summary>
        /// If the message is an instruction status or a cancellation request status (:23G:INST or CAST), 
        /// AND Sequence B is present, AND an instruction has been received (:25D::IPRC//NOIN is NOT present 
        /// in the message), then sequence B should contain a CA option number and code (:13A::CAON and :22a::CAOP 
        /// are mandatory) (Error code(s):D29).
        /// </summary>
        /// <param name="xDocument">
        ///		Input Reference to XML document
        /// </param>
        /// <param name="xPathTag23G">
        ///		Input Reference to Tag 23G in Sequence A
        /// </param>
        /// <param name="xPathFunction">
        ///		Input xPath of Function
        /// </param>
        /// <param name="xPathSequenceB">
        ///		Input xPath of Sequence B
        /// </param>
        /// <param name="xPathTag25D">
        ///		Input Reference to Tag 25D in Sequence A2
        /// </param>
        /// <param name="xPathQualifier">
        ///		Input xPath of Qualifier 
        /// </param>
        /// <param name="xPathStatusCode">
        ///		Input xPath of Status Code
        /// </param>
        /// <param name="xPathDataSourceScheme">
        ///		Input xPath of DataSourceScheme
        /// </param>
        /// <param name="function23GValue">
        ///		Function codelist of field 23G
        /// </param>
        /// <param name="qualifier25DValue">
        ///		Qualifier codelist of field 25D
        /// </param>
        /// <param name="statusCode25DValue">
        ///		Status Code codelist of field 25D
        /// </param>
        /// <param name="xPathTag13A">
        ///		Input Reference to Tag 13A in Sequence B
        /// </param>
        /// <param name="xPathTag22aOptionH">
        ///		Input Reference to Tag 22a in Sequence B with optionH
        /// </param>
        /// <param name="xPathTag22aOptionF">
        ///		Input Reference to Tag 22a in Sequence B with optionF
        /// </param>
        /// <param name="qualifier13AValue">
        ///		Qualifier codelist of field 13a 
        /// </param>
        /// <param name="qualifier22aValue">
        ///		Qualifier codelist of field 22a 
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        /// 	The Message Type that callls the function
        /// </param>
        /// <param name="conditionalRuleName">
        /// 	ConditionalRule Name
        /// </param>
        /// <param name="conditionalRuleNumber">
        /// 	ConditionalRule Number
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule129_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag23G,
            string xPathFunction,
            string xPathSequenceB,
            string xPathTag25D,
            string xPathQualifier,
            string xPathStatusCode,
            string xPathDataSourceScheme,
            string function23GValue,
            string qualifier25DValue,
            string statusCode25DValue,
            string xPathTag13A,
            string xPathTag22aOptionH,
            string xPathTag22aOptionF,
            string qualifier13AValue,
            string qualifier22aValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule129_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool requiresMandatoryCheck = false;
            string[] Function23GVal;
            try
            {
                if (xDocument == null ||
                    xPathTag23G == null ||
                    xPathTag23G.Length == 0 ||
                    xPathFunction == null ||
                    xPathFunction.Length == 0 ||
                    xPathSequenceB == null ||
                    xPathSequenceB.Length == 0 ||
                    xPathTag25D == null ||
                    xPathTag25D.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathStatusCode == null ||
                    xPathStatusCode.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathTag13A == null ||
                    xPathTag13A.Length == 0 ||
                    xPathTag22aOptionH == null ||
                    xPathTag22aOptionH.Length == 0 ||
                    xPathTag22aOptionF == null ||
                    xPathTag22aOptionF.Length == 0 ||
                    function23GValue == null ||
                    function23GValue.Length == 0 ||
                    qualifier25DValue == null ||
                    qualifier25DValue.Length == 0 ||
                    statusCode25DValue == null ||
                    statusCode25DValue.Length == 0 ||
                    qualifier13AValue == null ||
                    qualifier13AValue.Length == 0 ||
                    qualifier22aValue == null ||
                    qualifier22aValue.Length == 0 ||
                    errorObject == null)
                {
                    isValid = false;
                }
                else
                {
                    XmlNode xRoot = xDocument.Document;
                    XmlNode xNode23G = xRoot.SelectSingleNode(xPathTag23G);


                    if (xNode23G != null)
                    {
                        XmlNode xNode23GFunction = xNode23G.SelectSingleNode(xPathFunction);
                        Function23GVal = function23GValue.Split(Constants.CHRCOMMA);


                        XmlNode xNodeSequenceB = xRoot.SelectSingleNode(xPathSequenceB);


                        for (int i = 0; i < Function23GVal.Length; i++)
                        {
                            //checks for the presence of 23G field with the specified qualifiers(INST/CAST)
                            if (xNode23GFunction != null && xNode23GFunction.InnerText.CompareTo(Function23GVal[i]) == 0)
                            {
                                //checks for the presence of Sequence B
                                if (xNodeSequenceB != null)
                                {
                                    requiresMandatoryCheck = true;
                                }
                            }
                        }
                    }
                    if (requiresMandatoryCheck)
                    {
                        //checks the presence of 13a & 22a field with the specified qualifiers
                        XmlNode xNode13a = xRoot.SelectSingleNode(xPathTag13A);
                        XmlNode xNode22H = xRoot.SelectSingleNode(xPathTag22aOptionH);
                        XmlNode xNode22F = xRoot.SelectSingleNode(xPathTag22aOptionF);
                        if (xNode13a != null && (xNode22H != null || xNode22F != null))
                        {
                            XmlNode xNodequalifier13a = xNode13a.SelectSingleNode(xPathQualifier);
                            XmlNode xNodequalifier22a;
                            if (xNode22H != null)
                            {
                                xNodequalifier22a = xNode22H.SelectSingleNode(xPathQualifier);
                            }
                            else
                            {
                                xNodequalifier22a = xNode22F.SelectSingleNode(xPathQualifier);
                            }
                            if (xNodequalifier13a != null && xNodequalifier13a.InnerText.CompareTo(qualifier13AValue) != 0
                                || xNodequalifier22a != null && xNodequalifier22a.InnerText.CompareTo(qualifier22aValue) != 0)
                            {
                                isValid = false; //Set to false when fields 13a or 22a are not present with specified Qualifier
                            }
                        }
                        else
                        {
                            isValid = false; //Set to false when fields 13a or 22a are not present
                        }
                    }
                }
                //Adds the error to the error object if message is not valid
                if (!isValid)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		IsValidLegacyCurrencyCode_SRG2006
        /// </method>
        /// <summary>
        ///		This function performs validation for Legacy Currency Code
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathCurrencyCode" type = "string">
        ///		Input reference of the element having the currency code.
        /// </param>
        /// <param name ="xPathValueDate" type = "string">
        ///		Input reference of the element having the Date.
        /// </param>
        /// <param name ="legacyCurrencyCodeList" type = "string">
        ///		Input containing the list of Legacy Currency Codes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidLegacyCurrencyCode_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathCurrencyCode,
            string xPathValueDate,
            //string legacyCurrencyCodeList,
            //string SITCurrencyCodeList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidLegacyCurrencyCode_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //if (null == legacyCurrencyCodeList) throw new ArgumentNullException("currencyList");

            bool isValid = true;
            DateTime dateValue;
            //DateTime legacyDate = Convert.ToDateTime(Constants.LEGACYCURRENCYDATE, Constants.INVARIANTCULTURE);
            //DateTime SITCurrencyDate = Convert.ToDateTime(Constants.SITCURRENCYDATE, Constants.INVARIANTCULTURE);
            string Year = null;
            string Month = null;
            string Day = null;
            string[] CurrencyNodes;
            string date = string.Empty;
            try
            {
                if (xDocument == null ||
                    xPathCurrencyCode == null ||
                    xPathCurrencyCode.Length == 0 ||
                    xPathValueDate == null ||
                    xPathValueDate.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;

                }

                XmlNode xRoot = xDocument.Document;

                //gets the different currency nodes that are separated by comma
                CurrencyNodes = xPathCurrencyCode.Split(Constants.CHRCOMMA);

                //Select the node for Date
                XmlNode xNodeDate = xRoot.SelectSingleNode(xPathValueDate);

                for (int i = 0; i < CurrencyNodes.Length; i++)
                {
                    //Select the node for Currency Code
                    XmlNodeList xListCurrency = xRoot.SelectNodes(CurrencyNodes[i]);

                    if (xListCurrency != null)
                    {
                        foreach (XmlNode xNodeCurrency in xListCurrency)
                        {
                            if (xNodeCurrency != null && xNodeCurrency.InnerText.Length != 0)
                            {
                                //If the currencyCode is a legacy Currency code, then do the date check
                                if (SqlConnector.hashLegacyCurrencyCodeList.Contains(xNodeCurrency.InnerText)) //|| (SITCurrencyCodeList.Equals(xNodeCurrency.InnerText
                                {
                                    String strDate = xNodeDate.InnerText;
                                    int dateLength = strDate.Length;

                                    if (dateLength == 6) //when date is in YYMMDD Format
                                    {
                                        Year = strDate.Substring(0, 2);
                                        Month = strDate.Substring(2, 2);
                                        Day = strDate.Substring(4, 2);
                                    }
                                    else if (dateLength == 8)  //when date is in YYYYMMDD Format
                                    {
                                        Year = strDate.Substring(0, 4);
                                        Month = strDate.Substring(4, 2);
                                        Day = strDate.Substring(6, 2);
                                    }

                                    strDate = Month + Constants.SLASH + Day + Constants.SLASH + Year;

                                    dateValue = Convert.ToDateTime(strDate, Constants.INVARIANTCULTURE); //gets the Date in DateFormat

                                    //Get the date value of currency from Hash Table
                                    date = GetFormatValue(SqlConnector.hashLegacyCurrencyCodeList, xNodeCurrency.InnerText);
                                    //get the date in DateFormat
                                    DateTime legacyDate = Convert.ToDateTime(date, Constants.INVARIANTCULTURE);

                                    //Adds Error if the date is greater than date value of specific currency
                                    if ((SqlConnector.hashLegacyCurrencyCodeList.Contains(xNodeCurrency.InnerText)) && (dateValue.CompareTo(legacyDate) > 0))//&& !(SqlConnector.hashLegacyCurrencyCodeList.Contains(strDate)))  
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName,
                                            "Currency", xNodeCurrency.InnerText);
                                        isValid = false;
                                    }

                                    /*if (SITCurrencyCodeList.Equals(xNodeCurrency.InnerText) && (dateValue.CompareTo(SITCurrencyDate) > 0))
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName,
                                            "Currency", xNodeCurrency.InnerText);
                                        isValid = false;
                                    }*/
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		IsValidLegacyCurrencyCode_SRG2006
        /// </method>
        /// <summary>
        ///		This function performs validation for Legacy Currency Code
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathAmountNode" type = "string">
        ///		Input reference of the element having the Amount.
        /// </param>
        /// <param name ="xPathCurrency" type = "string">
        ///		Input reference of the Currency.
        /// </param>
        /// <param name ="xPathDate" type = "string">
        ///		Input reference of the Date.
        /// </param>
        /// <param name ="legacyCurrencyCodeList" type = "string">
        ///		Input containing the list of Legacy Currency Codes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidLegacyCurrencyCode_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathAmountNode,
            string xPathCurrency,
            string xPathDate,
            //string legacyCurrencyCodeList,
            //string SITCurrencyCodeList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidLegacyCurrencyCode_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //if (null == legacyCurrencyCodeList) throw new ArgumentNullException("currencyList");

            bool isValid = true;
            DateTime dateValue;
            //DateTime legacyDate = Convert.ToDateTime(Constants.LEGACYCURRENCYDATE, Constants.INVARIANTCULTURE);
            //DateTime SITCurrencyDate = Convert.ToDateTime(Constants.SITCURRENCYDATE, Constants.INVARIANTCULTURE);
            string Year = null;
            string Month = null;
            string Day = null;
            string[] AmountNodes;
            string date = string.Empty;
            try
            {

                if (xDocument == null ||
                    xPathAmountNode == null ||
                    xPathAmountNode.Length == 0 ||
                    xPathCurrency == null ||
                    xPathCurrency.Length == 0 ||
                    xPathDate == null ||
                    xPathDate.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;

                }

                XmlNode xRoot = xDocument.Document;

                //gets the different currency nodes that are separated by comma
                AmountNodes = xPathAmountNode.Split(Constants.CHRCOMMA);

                for (int i = 0; i < AmountNodes.Length; i++)
                {
                    //Select the node for Currency Code
                    XmlNodeList xListAmount = xRoot.SelectNodes(AmountNodes[i]);

                    if (xListAmount != null)
                    {
                        foreach (XmlNode xNodeAmount in xListAmount)
                        {
                            if (xNodeAmount != null && xNodeAmount.InnerText.Length != 0)
                            {
                                //Select the node for Date
                                XmlNode xNodeDate = xNodeAmount.SelectSingleNode(xPathDate);

                                //Select the node for Date
                                XmlNode xNodeCurrency = xNodeAmount.SelectSingleNode(xPathCurrency);

                                if (xNodeCurrency != null && xNodeCurrency.InnerText.Length != 0)
                                {
                                    //If the currencyCode is a legacy Currency code, then do the check
                                    if ((SqlConnector.hashLegacyCurrencyCodeList.Contains(xNodeCurrency.InnerText)))// || (SITCurrencyCodeList.Equals(xNodeCurrency.InnerText)))
                                    {
                                        String strDate = xNodeDate.InnerText;
                                        int dateLength = strDate.Length;

                                        if (dateLength == 6) //when date is in YYMMDD Format
                                        {
                                            Year = strDate.Substring(0, 2);
                                            Month = strDate.Substring(2, 2);
                                            Day = strDate.Substring(4, 2);
                                        }
                                        else if (dateLength == 8)  //when date is in YYYYMMDD Format
                                        {
                                            Year = strDate.Substring(0, 4);
                                            Month = strDate.Substring(4, 2);
                                            Day = strDate.Substring(6, 2);
                                        }

                                        strDate = Month + Constants.SLASH + Day + Constants.SLASH + Year;

                                        dateValue = Convert.ToDateTime(strDate, Constants.INVARIANTCULTURE); //gets the Date in DateFormat

                                        //Get the date of currency from Hash Table
                                        date = GetFormatValue(SqlConnector.hashLegacyCurrencyCodeList, xNodeCurrency.InnerText);
                                        //get the date in DateFormat
                                        DateTime legacyDate = Convert.ToDateTime(date, Constants.INVARIANTCULTURE);

                                        ////Adds Error if the date is greater than date value of specific currency
                                        if ((SqlConnector.hashLegacyCurrencyCodeList.Contains(xNodeCurrency.InnerText)) && (dateValue.CompareTo(legacyDate) > 0)) //Adds Error if the date is greater than 01/12/31 
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName,
                                                "Currency", xNodeCurrency.InnerText);
                                            isValid = false;
                                        }

                                        /* if (SITCurrencyCodeList.Equals(xNodeCurrency.InnerText) && (dateValue.CompareTo(SITCurrencyDate) > 0))   //Adds Error if the date is greater than 06/12/31
                                         {
                                             errorObject.AddError(errorCode, policyName, ruleName,
                                                 "Currency", xNodeCurrency.InnerText);
                                             isValid = false;
                                         }*/
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		IsValidLegacyCurrencyCode_SRG2006
        /// </method>
        /// <summary>
        ///		This function performs validation for Legacy Currency Code
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath19A" type = "string">
        ///		Input reference of the element having the Amount Filed 19A.
        /// </param>
        /// <param name ="xPath98A" type = "string">
        ///		Input reference of the element having the Date/Time Filed 98A.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Input reference of the qualifier.
        /// </param>
        /// <param name ="xPathSignCodeAmount" type = "string">
        ///		Input reference of the SignCodeAmount.
        /// </param>
        /// <param name ="xPathDate" type = "string">
        ///		Input reference of the Date.
        /// </param>
        /// <param name ="qualifierDateValue" type = "string">
        ///		qualifier value for date field
        /// </param>
        /// <param name ="qualifierCurrencyValue" type = "string">
        ///		qualifier value for currency amount
        /// </param>
        /// <param name ="legacyCurrencyCodeList" type = "string">
        ///		Input containing the list of Legacy Currency Codes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool IsValidLegacyCurrencyCode_SRG2006(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath19A,
            string xPath98a,
            string xPathQualifier,
            string xPathSignCodeAmount,
            string xPathDate,
            string qualifierDateValue,
            string qualifierCurrencyValue,
            //string legacyCurrencyCodeList,
            //string SITCurrencyCodeList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidLegacyCurrencyCode_SRG2006" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            //if (null == legacyCurrencyCodeList) throw new ArgumentNullException("currencyList");

            bool isValid = true;
            DateTime dateValue;
            //DateTime legacyDate = Convert.ToDateTime(hashLegacyCurrencyCodeList.LEGACYCURRENCYDATE, Constants.INVARIANTCULTURE);
            //DateTime SITCurrencyDate = Convert.ToDateTime(Constants.SITCURRENCYDATE, Constants.INVARIANTCULTURE);
            string Year = null;
            string Month = null;
            string Day = null;
            string[] AmountNodes;
            string[] DateTimeNodes;
            string[] DateNodes;
            string sign = string.Empty;
            string currencyCode = string.Empty;
            string signCodeAmount = string.Empty;
            string date = string.Empty;
            try
            {

                if (xDocument == null ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPath19A == null ||
                    xPath19A.Length == 0 ||
                    xPath98a == null ||
                    xPath98a.Length == 0 ||
                    xPathSignCodeAmount == null ||
                    xPathSignCodeAmount.Length == 0 ||
                    xPathDate == null ||
                    xPathDate.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;

                }

                XmlNode xRoot = xDocument.Document;

                //gets the different currency nodes that are separated by comma
                AmountNodes = xPath19A.Split(Constants.CHRCOMMA);

                for (int i = 0; i < AmountNodes.Length; i++)
                {
                    //Select the node for Currency Code
                    XmlNodeList xListAmount = xRoot.SelectNodes(AmountNodes[i]);

                    if (xListAmount != null)
                    {
                        foreach (XmlNode xNodeAmount in xListAmount)
                        {
                            if (xNodeAmount != null && xNodeAmount.InnerText.Length != 0)
                            {
                                //Select the node for Date
                                XmlNode xNodeSignCodeAmount = xNodeAmount.SelectSingleNode(xPathSignCodeAmount);

                                if (xNodeSignCodeAmount != null && xNodeSignCodeAmount.InnerText.Length != 0)
                                {
                                    //Get the value of SignCodeAmount
                                    signCodeAmount = xNodeSignCodeAmount.InnerText.ToString().Trim();

                                    if (signCodeAmount.Length > 3)
                                    {
                                        //Select the fourth character of the SignCodeAmount
                                        sign = signCodeAmount.Substring(3, 1);
                                    }

                                    //Check if the fourth character is a number or alphabet in order to check whether the Sign is present or not
                                    if (sign[0] >= Constants.CHR0 && sign[0] <= Constants.CHR9)
                                    {
                                        //Select the first three characters of the SignCodeAmount, if Sign is not present
                                        currencyCode = signCodeAmount.Substring(0, 3);
                                    }
                                    else
                                    {
                                        //Select the second,third and fourth characters of the SignCodeAmount, if Sign is present
                                        currencyCode = signCodeAmount.Substring(1, 3);
                                    }
                                }
                                if (xNodeAmount.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifierCurrencyValue) == 0)
                                {

                                    //If the currencyCode is a legacy Currency code, then do the date check
                                    if ((SqlConnector.hashLegacyCurrencyCodeList.Contains(currencyCode)))// || (SITCurrencyCodeList.Equals(currencyCode)))
                                    {
                                        DateTimeNodes = xPath98a.Split(Constants.CHRCOMMA); //gets the different date nodes that are separated by ,
                                        DateNodes = xPathDate.Split(Constants.CHRCOMMA);

                                        for (int j = 0; j < DateTimeNodes.Length; j++)
                                        {
                                            //Select the node for DateTime
                                            XmlNodeList xListDateTime = xRoot.SelectNodes(DateTimeNodes[j]);

                                            if (xListDateTime != null)
                                            {
                                                foreach (XmlNode xNodeDatetime in xListDateTime)
                                                {
                                                    if (xNodeDatetime != null && xNodeDatetime.InnerText.Length != 0 &&
                                                        xNodeDatetime.SelectSingleNode(xPathQualifier).InnerText.CompareTo(qualifierDateValue) == 0)
                                                    {
                                                        //Select the node for Date
                                                        XmlNode xNodeDate = xNodeDatetime.SelectSingleNode(DateNodes[j]);

                                                        if (xNodeDate != null && xNodeDate.InnerText.Length != 0)
                                                        {
                                                            String strDate = xNodeDate.InnerText;
                                                            int dateLength = strDate.Length;

                                                            if (dateLength == 6) //when date is in YYMMDD Format
                                                            {
                                                                Year = strDate.Substring(0, 2);
                                                                Month = strDate.Substring(2, 2);
                                                                Day = strDate.Substring(4, 2);
                                                            }
                                                            else if (dateLength == 8)  //when date is in YYYYMMDD Format
                                                            {
                                                                Year = strDate.Substring(0, 4);
                                                                Month = strDate.Substring(4, 2);
                                                                Day = strDate.Substring(6, 2);
                                                            }

                                                            strDate = Month + Constants.SLASH + Day + Constants.SLASH + Year;

                                                            dateValue = Convert.ToDateTime(strDate, Constants.INVARIANTCULTURE); //gets the Date in DateFormat

                                                            //Get the date of currency from Hash Table
                                                            date = GetFormatValue(SqlConnector.hashLegacyCurrencyCodeList, currencyCode);
                                                            //Get the date in DateFormat
                                                            DateTime legacyDate = Convert.ToDateTime(date, Constants.INVARIANTCULTURE);

                                                            //Adds Error if the date is greater than date value of specific currency
                                                            if ((SqlConnector.hashLegacyCurrencyCodeList.Contains(currencyCode)) && (dateValue.CompareTo(legacyDate) > 0)) //Adds Error if the date is greater than 01/12/31 
                                                            {
                                                                errorObject.AddError(errorCode, policyName, ruleName,
                                                                    "Currency", currencyCode);
                                                                isValid = false;
                                                            }

                                                            /*if (SITCurrencyCodeList.Equals(currencyCode) && (dateValue.CompareTo(SITCurrencyDate) > 0))   //Adds Error if the date is greater than 06/12/31
                                                            {
                                                                errorObject.AddError(errorCode, policyName, ruleName,
                                                                    "Currency", currencyCode);
                                                                isValid = false;
                                                            }*/
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		CheckValidCountryCode
        /// </method>
        /// <summary>
        /// This function performs validation for Country Code
        /// </summary>
        /// <param name="xDocument"  type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathCountry"  type = "string">
        /// Input reference of the country.
        /// </param>
        /// <param name="ruleName"  type = "string">
        /// Input containing the rule name.
        /// </param>
        /// <param name="policyName"  type = "string">
        /// Input containing the policy name.
        /// </param>
        ///  <param name="errorCode"  type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name="errorObject"  type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>

        public static bool CheckValidCountryCode(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathCountry,
            string ruleName,
            string policyName,
            string errorCode,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidCountryCode" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);

            bool isValid = true;
            try
            {
                //int lengthxPathCountry = 0;
                string sign = string.Empty;
                string countryCode = string.Empty;
                string country = string.Empty;

                if (xDocument == null ||
                    xPathCountry == null ||
                    xPathCountry.Length == 0 ||
                    errorObject == null)
                {
                    return false;

                }

                //			string[] xPathCountryArray = xPathCountry.Split(Constants.CHRCOMMA);
                //			lengthxPathCountry = xPathCountryArray.Length;
                //			for(int nCount = 0;nCount<= lengthxPathCountry - 1;nCount++)
                //			{

                XmlNode xRoot = xDocument.Document;
                //Select all the nodes of element SignCodeAmount
                XmlNodeList xListCountry = xRoot.SelectNodes(xPathCountry);
                if (xListCountry != null)
                {

                    foreach (XmlNode xNodeCountry in xListCountry)
                    {
                        ////Get the value of SignCodeAmount
                        country = xNodeCountry.InnerText.ToString();

                        if (!SqlConnector.hashCountryCodeList.ContainsValue(country))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                "CountryCode", country);
                            isValid = false;

                        }
                    }
                }
                //			}
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;
        }

        /// <method>
        ///		CheckValidCurrencyCode
        /// </method>
        /// <summary>
        /// This function performs validation for Currency Code
        /// </summary>
        /// <param name="xDocument"  type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathCurrency"  type = "string">
        /// Input reference of the currency.
        /// </param>
        /// <param name="ruleName"  type = "string">
        /// Input containing the rule name.
        /// </param>
        /// <param name="policyName"  type = "string">
        /// Input containing the policy name.
        /// </param>
        ///  <param name="errorCode"  type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name="errorObject"  type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckValidCurrencyCode(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathCurrency,
            string ruleName,
            string policyName,
            string errorCode,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckValidCurrencyCode" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                int lengthxPathCurrency = 0;
                string sign = string.Empty;
                string currency = string.Empty;

                if (xDocument == null ||
                    xPathCurrency == null ||
                    xPathCurrency.Length == 0 ||
                    errorObject == null)
                {
                    return false;

                }

                string[] xPathCurrencyArray = xPathCurrency.Split(Constants.CHRCOMMA);
                lengthxPathCurrency = xPathCurrencyArray.Length;
                for (int nCount = 0; nCount <= lengthxPathCurrency - 1; nCount++)
                {

                    XmlNode xRoot = xDocument.Document;
                    //Select all the nodes of element SignCodeAmount
                    XmlNodeList xListCurrency = xRoot.SelectNodes(xPathCurrencyArray[nCount].ToString());
                    if (xListCurrency != null)
                    {

                        foreach (XmlNode xNodeCurrency in xListCurrency)
                        {
                            //Get the value of Currency
                            currency = xNodeCurrency.InnerText.ToString();

                            //Check the value of the currency from the hashtable.
                            if (!SqlConnector.hashCurrencyCodeList.ContainsKey(currency))
                            {

                                errorObject.AddError(errorCode, policyName, ruleName,
                                    "CurrencyCode", currency);
                                isValid = false;

                            }

                        }
                    }
                }


            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }
        /// <method>
        ///		SWIFTNetworkRule21
        /// </method>
        /// <summary>
        /// This function performs validation of 
        /// </summary>
        /// /// <param name="xDocument"  type = "Microsoft.RuleEngine.TypedXmlDocument">
        /// Input containing the xml document to be validated.
        /// </param>
        /// <param name="sequenceC">
        /// Input containing sequenceC.
        /// </param>
        /// <param name="sequenceD">
        /// Input containing sequenceD.
        /// </param>
        /// /// Input containing the policy name.
        /// </param>		
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        ///  <param name="errorCode"  type = "string">
        ///		Input containing the error code.
        /// </param>	

        /// <param name="messageType">
        ///		Input containing messageType.
        /// </param>
        /// <param name="ruleType">
        /// 	Input containing ruleType.
        /// </param>
        /// <param name="errorObject">
        /// 	Input containing errorObject.
        /// </param>
        /// <returns>
        /// </returns>
        public static bool SWIFTNetworkRule21(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string sequenceC,
            string sequenceD,
            string policyName,
            string ruleName,
            string errorCode,
            string messageType,
            string ruleType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule21" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xDocument) throw new ArgumentNullException("xDocument");


                XmlNode xRoot = xDocument.Document;

                XmlNode nodeSeqC = xRoot.SelectSingleNode(sequenceC);
                XmlNode nodeSeqD = xRoot.SelectSingleNode(sequenceD);
                if (nodeSeqC == null)
                {
                    if (nodeSeqD == null)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, ruleType);
                        isValid = false;
                    }

                    else
                    {
                        isValid = true;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        //Added for SRG2010
        /// <method>
        /// 	IsValidOccurrence
        /// </method>
        /// <summary>
        /// 	This function checks if a pirtucular Node exist N no of times depending on the 
        /// 	operator that has been passed as argument for comparision
        /// </summary>
        /// <param name="xDocument">
        /// 	Xml Document
        /// </param>
        /// <param name="xPathSequence">
        /// 	XPath of Sequence, for which occurrence count is to be checked.
        /// </param>
        /// <param name="occurrenceCompare">
        /// 	Integer count for occurrance comparision.
        /// </param>
        /// <param name="operatorType">
        /// 	Operaor to use for comparsion, POssible values eq,gt and lt
        /// </param>
        /// <param name="policyName">
        /// 	Name of policy to check
        /// </param>
        /// <param name="ruleName">
        /// 	Name of the Rule
        /// </param>
        /// <param name="errorCode">
        /// 	Errorcode
        /// </param>
        /// <param name="messageType">
        /// 	MT name
        /// </param>
        /// <param name="ruleType">
        /// 	Rule Type
        /// </param>
        /// <param name="errorObject">
        /// 	Instance of error object
        /// </param>
        /// <returns>
        /// 	True, if occurrence of the sequence is as per the expression, False otherwise.
        /// </returns>
        public static bool IsValidOccurrence(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string occurrenceCompare,
            string operatorType,
            string policyName,
            string ruleName,
            string errorCode,
            string messageType,
            string ruleType,
            ErrorCollection errorObject
            )
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function IsValidOccurrence:");
            bool result = false;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    occurrenceCompare == null ||
                    occurrenceCompare.Length == 0 ||
                    operatorType == null ||
                    operatorType.Length == 0
                    )
                {
                    throw new System.ArgumentException("Parameter cannot be null", "original");
                }

                XmlNode xRoot = xDocument.Document;
                switch (operatorType)
                {
                    case "eq": //Equal
                        {
                            if (xRoot.SelectNodes(xPathSequence).Count == Convert.ToInt16(occurrenceCompare))
                                result = true;
                            break;
                        }
                    case "gt": //Greater Than
                        {
                            if (xRoot.SelectNodes(xPathSequence).Count > Convert.ToInt16(occurrenceCompare))
                                result = true;
                            break;
                        }
                    case "lt": //Less Than
                        {
                            if (xRoot.SelectNodes(xPathSequence).Count < Convert.ToInt16(occurrenceCompare))
                                result = true;
                            break;
                        }
                    default:
                        throw new System.ArgumentException("Invalid Operator value for comparision", "original");

                }
                if (result)
                    errorObject.AddError(errorCode, policyName, ruleName, xPathSequence, Constants.BLANK);

                return result;
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
        }

        #region SRG 2011 MT670 Message Network Rules

        /// <method>
        ///		SWIFTNetworkRule108
        /// </method>
        /// <summary>
        ///		In subsequence A2 Distribution Parameter, either field :95P::SSIR SSI Recipient or 
        ///		field :94C::SSIR SSI Recipient Country or field :22H::SSIR SSI Recipient Indicator must be present
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSeq">
        ///		Input reference of the element Sequence
        ///		e.g. //SequenceA2
        /// </param>
        /// <param name="xPathSeqTag95PQualifier">
        ///		Input reference of the element Tag 95P of Sequence
        ///		e.g. //Party_A2_95P/Qualifier
        /// </param>
        /// <param name="xPathSeqTag94CQualifier">
        ///		Input reference of the element Tag 94C qualifier of SubSequence
        ///		e.g. /Place_A2_94C/Qualifier
        /// </param>
        /// <param name="xPathSeqTag22HQualifier">
        ///		Input containing the value of Tag 22H qualifier of given subSequence
        ///		e.g. //Indicator_A2_22H/Qualifier
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT670
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule108(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSeq,
            string xPathSeqTag95PQualifier,
            string xPathSeqTag94CQualifier,
            string xPathSeqTag22HQualifier,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule108" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSeq == null ||
                    xPathSeqTag95PQualifier == null ||
                    xPathSeqTag94CQualifier == null ||
                    xPathSeqTag22HQualifier == null ||
                    xPathSeq.Length == 0 ||
                    xPathSeqTag95PQualifier.Length == 0 ||
                    xPathSeqTag94CQualifier.Length == 0 ||
                    xPathSeqTag22HQualifier.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                XmlNode xRoot = xDocument.Document;
                XmlNodeList xNodeListSeq = xRoot.SelectNodes(xPathSeq);

                foreach (XmlNode xNodeSeq in xNodeListSeq)
                {
                    XmlNode xNodeTag95P = xNodeSeq.SelectSingleNode(xPathSeqTag95PQualifier);
                    XmlNode xNodeTag94C = xNodeSeq.SelectSingleNode(xPathSeqTag94CQualifier);
                    XmlNode xNodeTag22H = xNodeSeq.SelectSingleNode(xPathSeqTag22HQualifier);
                    if (!((xNodeTag95P != null && xNodeTag94C == null && xNodeTag22H == null) ||
                             (xNodeTag95P == null && xNodeTag94C != null && xNodeTag22H == null) ||
                                (xNodeTag95P == null && xNodeTag94C == null && xNodeTag22H != null)))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule109
        /// </method>
        /// <summary>
        ///		In sequence A General Information, field :95P::SUBM Submitting Party must specify the same registered BIC as 
        ///		the Sender in the basic header. If the branch code of the Sender's BIC is XXX, then the branch code is 
        ///		not required in field :95P::SUBM Submitting Party. If the branch code of the Sender's BIC is not XXX, 
        ///		then the branch code in field :95P::SUBM Submitting Party must be the same. If the branch code of :95P::SUBM 
        ///		Submitting Party is present, then the branch code of the Sender's BIC must be the same (Error code(s): D09).
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSeq">
        ///		Input reference of the element Sequence
        ///		e.g. //SequenceA
        /// </param>
        /// <param name="xPathSeqTag95P">
        ///		Input reference of the element Tag 19A of Sequence
        ///		e.g. 95P
        /// </param>
        /// <param name="fieldName">
        ///		Input reference of the element Tag 19A of Sequence
        ///		e.g. Party
        /// </param>
        /// <param name="xPathSubSeqTag95PQualifier">
        ///		Input reference of the element Tag 195P qualifier of SubSequence
        ///		e.g. SUBM
        /// </param>      
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT670
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule109(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            Microsoft.RuleEngine.TypedXmlDocument xHeaderDocument,
            string xPathSeq,
            string xPathSeqTag95P,
            string fieldName,
            string xPathSubSeqTag95PQualifier,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule109" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSeq == null ||
                    xPathSeqTag95P == null ||
                    xPathSubSeqTag95PQualifier == null ||
                    xPathSeq.Length == 0 ||
                    xPathSeqTag95P.Length == 0 ||
                    xPathSubSeqTag95PQualifier.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                if (null == xHeaderDocument) throw new ArgumentNullException("xHeaderDocument");

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xNodeListSeq = xRoot.SelectNodes(xPathSeq);

                XmlNode xHeaderRoot = xHeaderDocument.Document;
                XmlNode xHeaderBic = xHeaderRoot.SelectSingleNode("//BasicHeaderBlock/LTAddress");
                string PartyQualifier = Constants.DOUBLESLASH + fieldName + Constants.UNDERSCORE + xPathSeq.Substring(10) + Constants.UNDERSCORE + xPathSeqTag95P + Constants.SLASH + Constants.QUALIFIER;
                String BankIdentifier = Constants.DOUBLESLASH + fieldName + Constants.UNDERSCORE + xPathSeq.Substring(10) + Constants.UNDERSCORE + xPathSeqTag95P + Constants.SLASH + "BankIdentifier";

                String SenderBic = xHeaderBic.InnerText.Substring(0, 8);
                String SenderBicbranchCode = (xHeaderBic.InnerText.Length == 12) ? xHeaderBic.InnerText.Substring(9, 3) : "";

                foreach (XmlNode xNodeSeq in xNodeListSeq)
                {
                    XmlNode xNodeSeqTag95P = xNodeSeq.SelectSingleNode(PartyQualifier);

                    if (xNodeSeqTag95P != null && xNodeSeqTag95P.InnerText != null && xNodeSeqTag95P.InnerText.Length != 0)
                    {
                        XmlNodeList xNodeListSubSeqTag19A = xNodeSeq.SelectNodes(PartyQualifier);
                        foreach (XmlNode xNodeSubSeqTag19A in xNodeListSubSeqTag19A)
                        {
                            if (xNodeSubSeqTag19A.InnerText.CompareTo(xPathSubSeqTag95PQualifier) == 0)
                            {
                                XmlNode xBankIdentifierNode = xNodeSeq.SelectSingleNode(BankIdentifier);

                                if (xBankIdentifierNode != null)
                                {
                                    XmlNode XNodeBankCode = xBankIdentifierNode.ChildNodes[0];
                                    XmlNode XNodeCountryCode = xBankIdentifierNode.ChildNodes[1];
                                    XmlNode XAreaCode = xBankIdentifierNode.ChildNodes[2];
                                    XmlNode XBranchBankCode = xBankIdentifierNode.ChildNodes[3];

                                    string PathBankCode = XNodeBankCode.InnerText + XNodeCountryCode.InnerText + XAreaCode.InnerText;
                                    if (PathBankCode.CompareTo(SenderBic) != 0)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                        break;
                                    }

                                    if (SenderBicbranchCode.Length != 0 && SenderBicbranchCode.CompareTo("XXX") != 0)
                                    {
                                        if (XBranchBankCode == null || XBranchBankCode.InnerText == null ||
                                            XBranchBankCode.InnerText.Length == 0 ||
                                            SenderBicbranchCode.CompareTo(XBranchBankCode.InnerText) != 0)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isValid = false;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule223
        /// </method>
        /// <summary>
        ///		In sequence A General Information, field :95P::TRAD Trade Party may only be present once. 
        ///		Field :95Q::TRAD Trade Party may only be present once. Both fields :95P::TRAD Trade 
        ///		Party and :95Q::TRAD Trade Party may be present
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        ///		Input reference of the element Sequence
        ///		e.g. //SequenceA
        /// </param>
        /// <param name="xPath">
        ///		Input reference of the element Tag 95a of Sequence
        ///		e.g. 95P,95Q
        /// </param>  
        /// <param name="fieldName">
        ///		Input containing the value of Tag 95a qualifier 
        ///		e.g. Party
        /// </param>
        /// <param name="qualifier">
        ///		Input containing the value of Tag 95a qualifier 
        ///		e.g. TRAD
        /// </param>       
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT670
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule223(Microsoft.RuleEngine.TypedXmlDocument xDocument,
             string xPathSequence,
            string xPath,
            string fieldName,
            string qualifier,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule223" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (null == xPath) throw new ArgumentNullException("xPath");
                if (null == xPathSequence) throw new ArgumentNullException("xPathSequence");
                if (null == qualifier) throw new ArgumentNullException("qualifierList");

                //Variables used
                int lengthXpath = 0;

                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);
                string[] xPathSeqArray = xPathSequence.Split(Constants.CHRCOMMA);

                string qualifierTemp = qualifier;

                ArrayList xPathArrayTemp = new ArrayList();
                lengthXpath = xPathArray.Length;
                ArrayList arrayQualifier = new ArrayList();

                //creating required xPaths)
                for (int j = 0; j <= xPathSeqArray.Length - 1; j++)
                {
                    for (int i = 0; i <= xPathArray.Length - 1; i++)
                    {
                        string tempHoldValue = Constants.DOUBLESLASH + fieldName + Constants.UNDERSCORE + xPathSeqArray[j].Substring(10) + Constants.UNDERSCORE + xPathArray[i] + Constants.SLASH + Constants.QUALIFIER;
                        xPathArrayTemp.Add(tempHoldValue);
                    }
                }

                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //Check for Number of occurences of the field in the input instance
                XmlNode xRoot = xDocument.Document;
                for (int nCount = 0; nCount <= xPathArrayTemp.Count - 1; nCount++)
                {
                    XmlNodeList xList = xRoot.SelectNodes(xPathArrayTemp[nCount].ToString());
                    if (xList.Count != 0)
                    {
                        string strQualifier = string.Empty;
                        qualifierTemp = qualifier;
                        foreach (XmlNode xNode in xList)
                        {
                            strQualifier = xNode.InnerText;

                            if (strQualifier == qualifier && qualifierTemp.IndexOf(strQualifier) == -1)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                    conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                                break;
                            }
                            qualifierTemp = qualifierTemp.Replace(strQualifier, Constants.BLANK);
                        }

                    }
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule111
        /// </method>
        /// <summary>
        ///		In each occurrence of sequence B SSI Details, if subsequence B1 Cash Parties contains :95a::INT2 Second 
        ///		Intermediary then :95a::INT1 Intermediary must be present in another subsequence B1 Cash Parties (Error code(s): D11).
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        ///		Input reference of the element Sequence
        ///		e.g. //SequenceB
        /// </param>
        /// <param name="xPathSubSequence">
        ///		Input reference of the element Sub Sequence
        ///		e.g. ./SequenceB1
        /// </param>
        /// <param name="xPath95a">
        ///		Input reference of the element Tag 95a SubSequenceB1
        ///		e.g. ./Party_B1_95P,./Party_B1_95Q,./Party_B1_95R
        /// </param>
        /// <param name="xPathQualifier">
        ///		Input containing the value of Tag 95a qualifier of given subSequenceB1
        ///		e.g. ./Qualifier
        /// </param>
        /// <param name="codeList">
        ///		Input containing the value of Tag 95a qualifier of given subSequenceB1
        ///		e.g. INT2,INT1
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT670
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule111(Microsoft.RuleEngine.TypedXmlDocument xDocument,
           string xPathSequence,
            string xPathSubSequence,
            string xPath95a,
            string xPathQualifier,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule111" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    xPath95a == null ||
                    xPath95a.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //Store the comma separated list codeList in an array
                string[] codeListArray = codeList.Split(Constants.COMMA.ToCharArray());
                string[] xPath95aList = xPath95a.Split(Constants.COMMA.ToCharArray());

                XmlNode xRoot = xDocument.Document;

                //Select the Sequence(SequenceB)
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                if (xListSequence != null && xListSequence.Count != 0)
                {
                    foreach (XmlNode xNodeSequence in xListSequence)
                    {
                        for (int count = 0; count <= codeListArray.Length - 1; count++)
                        {
                            XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);
                            if (xListSubSequence != null && xListSubSequence.Count != 0)
                            {
                                bool isINT1present = false;
                                bool isINT2present = false;
                                foreach (XmlNode xNodeSubSequence in xListSubSequence)
                                {
                                    foreach (string xPath in xPath95aList)
                                    {

                                        XmlNodeList xNode95aList = xNodeSubSequence.SelectNodes(xPath);

                                        foreach (XmlNode xNode95a in xNode95aList)
                                        {
                                            if (xNode95a != null && xNode95a.InnerText.Length != 0)
                                            {
                                                XmlNode xNodeQualifier95a = xNode95a.SelectSingleNode(xPathQualifier);
                                                if (xNodeQualifier95a != null && xNodeQualifier95a.InnerText.Length != 0)
                                                {
                                                    if (xNodeQualifier95a.InnerText == codeListArray[0].ToString())
                                                    {
                                                        isINT2present = true;
                                                    }
                                                    else
                                                        if (xNodeQualifier95a.InnerText == codeListArray[1].ToString())
                                                        {
                                                            isINT1present = true;
                                                        }
                                                }

                                            }
                                        }
                                    }
                                }
                                //check if INT1 is not present and then INT2 present or not.
                                if ((!isINT1present) && isINT2present)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    return isValid = false;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;

        }

        /// <method>
        ///		SWIFTNetworkRule112
        /// </method>
        /// <summary>
        ///		In each occurrence of sequence B SSI Details, in subsequence B1 Cash Parties, field :95P::BENM or :95Q::BENM or 
        ///		:95R::BENM Beneficiary of Money must be present. All three may be present but once only (Error code(s): D12).
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        ///		Input reference of the SequenceB
        ///		e.g. //SequenceB
        /// </param>
        /// <param name="xPathSubSequence">
        ///		Input reference of the Sub SequenceB1
        ///		e.g. ./SequenceB1
        /// </param>
        /// <param name="xPath95a">
        ///		Input reference of the element Tag 95a of Sub SubSequenceB1
        ///		e.g. ./Party_B1_95P,./Party_B1_95Q,./Party_B1_95R
        /// </param>
        /// <param name="xPathQualifier">
        ///		Input containing the value of Tag 95a qualifier of given subSequenceB1
        ///		e.g. ./Qualifier
        /// </param>
        /// <param name="codeList">
        ///		Input containing the value of Tag 95a qualifier of given subSequenceB1
        ///		e.g. BENM
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT670
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule112(Microsoft.RuleEngine.TypedXmlDocument xDocument,
           string xPathSequence,
           string xPathSubSequence,
           string xPath95a,
           string xPathQualifier,
           string codeList,
           string errorCode,
           string policyName,
           string ruleName,
           string messageType,
           string conditionalRuleName,
           string conditionalRuleNumber,
           ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule112" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    xPath95a == null ||
                    xPath95a.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                else
                {
                    //Store the comma separated list codeList in an array
                    string[] codeListArray = codeList.Split(Constants.COMMA.ToCharArray());
                    string[] xPath95aList = xPath95a.Split(Constants.COMMA.ToCharArray());
                    XmlNode xRoot = xDocument.Document;
                    string qualifierTemp = xPathQualifier;
                    //Select the nodeSequence
                    XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                    ArrayList xPathArrayTemp = new ArrayList();
                    bool flag = false;
                    int count95a = 1;

                    //creating required xPaths)
                    for (int i = 0; i <= xPath95aList.Length - 1; i++)
                    {
                        string tempHoldValue = xPath95aList[i] + Constants.SLASH + Constants.QUALIFIER;
                        xPathArrayTemp.Add(tempHoldValue);
                    }
                    if (xListSequence.Count != 0)
                    {
                        foreach (XmlNode xNodeSequence in xListSequence)
                        {
                            XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);
                            flag = false;
                            count95a = 1;
                            if (xListSubSequence.Count != 0)
                            {
                                foreach (XmlNode xNodeSubSequence in xListSubSequence)
                                {

                                    string strQualifier = string.Empty;

                                    for (int nCount = 0; nCount <= xPathArrayTemp.Count - 1; nCount++)
                                    {
                                        XmlNodeList xList = xNodeSubSequence.SelectNodes(xPathArrayTemp[nCount].ToString());
                                        if (xList.Count != 0)
                                        {
                                            flag = true;
                                            qualifierTemp = codeList;
                                            foreach (XmlNode xNode in xList)
                                            {
                                                strQualifier = xNode.InnerText;

                                                if (strQualifier == codeList && qualifierTemp.IndexOf(strQualifier) == -1 || strQualifier == codeList && flag == true && count95a > 1)
                                                {
                                                    errorObject.AddError(errorCode, policyName, ruleName, messageType,
                                                        conditionalRuleName, conditionalRuleNumber);
                                                    isValid = false;
                                                    break;
                                                }
                                                qualifierTemp = qualifierTemp.Replace(strQualifier, Constants.BLANK);
                                            }
                                        }
                                    }
                                    if (strQualifier == codeList && flag == true) count95a++;
                                }
                            }
                        }
                    }

                    if (count95a == 1)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType,
                            conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                    }

                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule115
        /// </method>
        /// <summary>
        ///		In each occurrence of subsequence B1 SSI Details, fields :95P::ACCW (INT1 or INT2), :95Q::ACCW (INT1 or INT2) and 
        ///		:95R::ACCW (INT1 or INT2) Account with Institution may all be present but once only (Error code(s): D15).
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        ///		Input reference of the SequenceB
        ///		e.g. //SequenceB
        /// </param>
        /// <param name="xPathSubSequence">
        ///		Input reference of the Sub SequenceB1
        ///		e.g. ./SequenceB1
        /// </param>
        /// <param name="xPath95a">
        ///		Input reference of the element Tag 95a qualifier of SubSequenceB1
        ///		e.g. ./Party_B1_95P,./Party_B1_95Q,./Party_B1_95R
        /// </param>
        /// <param name="xPathQualifier">
        ///		Input containing the value of Tag 95a qualifier of given subSequenceB1
        ///		e.g. ./Qualifier
        /// </param>
        /// <param name="codeList">
        ///		Input containing the value of Tag 95a qualifier of given subSequenceB1
        ///		e.g. INT2,INT1
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT670
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule115(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPath95a,
            string xPathQualifier,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule115" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    xPath95a == null ||
                    xPath95a.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                //Store the comma separated xPaths in an array.
                string[] xPath95aList = xPath95a.Split(Constants.COMMA.ToCharArray());

                XmlNode xRoot = xDocument.Document;

                //Select the all Sequences(SequenceB) 
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                if (xListSequence != null && xListSequence.Count != 0)
                {
                    foreach (XmlNode xNodeSequence in xListSequence)
                    {
                        //Select the all sub Sequences(SequenceB1) 
                        XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);
                        if (xListSubSequence != null && xListSubSequence.Count != 0)
                        {
                            //Select the all nodes of SequenceB1
                            foreach (XmlNode xNodeSubSequence in xListSubSequence)
                            {
                                //Check In each occurrence of subsequence B1 SSI Details, fields 95P,95Q,95R present only once or not.
                                foreach (string xPath in xPath95aList)
                                {
                                    Hashtable hashQualifierList = new Hashtable();
                                    XmlNodeList xNode95aList = xNodeSubSequence.SelectNodes(xPath);
                                    foreach (XmlNode xNode95a in xNode95aList)
                                    {
                                        if (xNode95a.InnerText.Length != 0)
                                        {
                                            XmlNode xNodeQualifier95a = xNode95a.SelectSingleNode(xPathQualifier);

                                            if (codeList.Contains(xNodeQualifier95a.InnerText))
                                            {
                                                if (hashQualifierList[xNodeQualifier95a.InnerText] != null && hashQualifierList[xNodeQualifier95a.InnerText].ToString() == xPath)
                                                {
                                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                    return isValid = false;
                                                }
                                                else
                                                {
                                                    hashQualifierList.Add(xNodeQualifier95a.InnerText, xPath);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule114
        /// </method>
        /// <summary>
        ///		In subsequence A2 Distribution Parameter, if field :95P::SSIR SSI Recipient is not present, 
        ///		then in subsequence B2 Other Details and sequence C Other Details, field :22F::PMTH Payment 
        ///		Method Indicator must not be present. In sequence C Other Details, field :22F::PMTH Payment 
        ///		Method Indicator is only allowed when subsequence B2 Other Details field :22F::PMTH Payment 
        ///		Method Indicator is not present (Error code(s): D14).
        /// </summary>
        /// <param name="xDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSeqTag95PQualifier">
        ///		Input reference of the element Sequence
        ///		e.g. //Party_A2_95P/Qualifier
        /// </param>
        /// <param name="xPathSeqB2Tag22FQualifier">
        ///		Input reference of the element Sequence
        ///		e.g. //Indicator_B2_22F/Qualifier
        /// </param>
        /// <param name="xPathSeqCTag22FQualifier">
        ///		Input reference of the element Tag 19A qualifier of SubSequence
        ///		e.g. //Indicator_C_22F/Qualifier
        /// </param>
        /// <param name="qualifier95P">
        ///		Input containing the value of Tag 19A qualifier of given subSequence
        ///		e.g. SSIR
        /// </param>
        /// <param name="qualifier22F">
        ///		Input containing the value of Tag 19A qualifier of given subSequence
        ///		e.g. PMTH
        /// </param>
        /// <param name="errorCode">
        ///		Input containing the error code.
        /// </param>
        /// <param name="policyName">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="ruleName">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType">
        ///		Input containing the Message Number
        ///		For e.g. MT670
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name="errorObject">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule114(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSeqTag95PQualifier,
            string xPathSeqB2Tag22FQualifier,
            string xPathSeqCTag22FQualifier,
            string qualifier95P,
            string qualifier22F,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule108" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSeqTag95PQualifier == null ||
                    xPathSeqB2Tag22FQualifier == null ||
                    xPathSeqCTag22FQualifier == null ||
                    xPathSeqTag95PQualifier.Length == 0 ||
                    xPathSeqB2Tag22FQualifier.Length == 0 ||
                    xPathSeqCTag22FQualifier.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                XmlNode xRoot = xDocument.Document;
                XmlNodeList xNodeListSeq = xRoot.SelectNodes("/");

                foreach (XmlNode xNodeSeq in xNodeListSeq)
                {
                    XmlNode xNodeTag95P = xNodeSeq.SelectSingleNode(xPathSeqTag95PQualifier);
                    XmlNode xNodeB2Tag22FQualifier = xNodeSeq.SelectSingleNode(xPathSeqB2Tag22FQualifier);
                    XmlNode xNodeCTag22FQualifier = xNodeSeq.SelectSingleNode(xPathSeqCTag22FQualifier);

                    //If In A2 :95P:SSIR Not Present but 22F:PMTH is allowed in B2 or C Other Details
                    bool bCase1 = (xNodeTag95P == null) && ((xNodeB2Tag22FQualifier != null && xNodeB2Tag22FQualifier.InnerText == qualifier22F.Trim())
                                                            || (xNodeCTag22FQualifier != null && xNodeCTag22FQualifier.InnerText == qualifier22F.Trim()));

                    //If In A2 :95P:SSIR Present and In B2 :22F::PMTH Present but 22F:PMTH is allowed in C Other Details
                    bool bCase2 = ((xNodeTag95P != null && xNodeTag95P.InnerText == qualifier95P.Trim())
                                 && (xNodeB2Tag22FQualifier != null && xNodeB2Tag22FQualifier.InnerText == qualifier22F.Trim()))
                                 && (xNodeCTag22FQualifier != null && xNodeCTag22FQualifier.InnerText == qualifier22F.Trim());


                    if (bCase1 || bCase2)
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        #endregion SRG 2011 MT670 Message Network Rules

        /// <method>
        ///		SWIFTNetworkRule208_SRG2011
        /// </method>
        /// <summary>
        /// 	This method checks if the Function Of Message (Field 23G) is CANC. If yes,
        /// 	it checks whether the SubSequence A1 is present and the Field 20C within
        /// 	SubSequence A1 is present and having a qualifier PREV (only once).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xpathSubField" type = "string">
        ///		Input reference of the sub field to be checked.
        /// </param>
        /// <param name ="qualifier23G" type = "string">
        ///		Input reference of the sub field to be checked.
        /// </param>
        /// <param name ="qualifier20C" type = "string">
        ///		Input reference of the sub field to be checked.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing message number
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing name of the conditional rule
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing number of the conditional rule
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule208_SRG2011(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath,
            string xpathSubField,
            string qualifier23G,
            string qualifier20C,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule208" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    xpathSubField == null ||
                    xpathSubField.Length == 0 ||
                    policyName == null ||
                    policyName.Length == 0 ||
                    ruleName == null ||
                    ruleName.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }


                int countError = 0;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xList = xRoot.SelectNodes(xPath);

                foreach (XmlNode xNode in xList)
                {
                    if (xNode.FirstChild != null && xNode.FirstChild.InnerText != null)
                    {
                        if (xNode.FirstChild.InnerText.CompareTo(qualifier23G) == 0)
                        {
                            //get the node for sub sequence
                            XmlNodeList chkSubField = xRoot.SelectNodes(xpathSubField);

                            foreach (XmlNode xSubNode in chkSubField)
                            {
                                if (xSubNode.FirstChild != null)
                                {
                                    if (xSubNode.FirstChild.InnerText.CompareTo(qualifier20C) == 0)
                                    {
                                        countError++;
                                    }
                                }
                            }

                            if (countError > 1) //to check the presence of 20C:PREV is optional or only once
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                isValid = false;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }



        /// <method>
        ///		SWIFTNetworkRule262_SRG2011
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 262.
        ///		If an Resulting Amount (field :19B::RESU) is present in subsequence E2,
        ///		then the corresponding Exchange Rate (field :92B::EXCH) must be present in the same (sub)sequence.
        ///		If the Resulting Amount is not present, the Exchange Rate is optional (Error code(s): E62).
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath19B" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath92B" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence to be validated.
        /// </param>
        /// <param name ="qualifierValue92B" type = "string">
        ///		Input containing the qualifier value of tag 92B.
        /// </param>
        /// <param name ="qualifierValue19B" type = "string">
        ///		Input containing the qualifier value of tag 19B.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule262_SRG2011(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath19B,
            string xPath92B,
            string xPathSequence,
            string qualifierValue19B,
            string qualifierValue92B,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule262_SRG2011" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;

            try
            {
                if (xDocument == null ||
                    xPath92B == null ||
                    xPath92B.Length == 0 ||
                    xPath19B == null ||
                    xPath19B.Length == 0 ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    qualifierValue19B == null ||
                    qualifierValue92B == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    bool is19BPresent = false;
                    bool is92BPresent = false;

                    XmlNodeList xNode19AList = xNodeSequence.SelectNodes(xPath19B);

                    foreach (XmlNode xNode in xNode19AList)
                    {
                        if (xNode.FirstChild != null)
                        {
                            if (xNode.FirstChild.InnerText.CompareTo(qualifierValue19B) == 0)
                            {
                                is19BPresent = true;
                                break;
                            }
                        }
                    }

                    XmlNodeList xNode92BList = xNodeSequence.SelectNodes(xPath92B);

                    foreach (XmlNode xNode in xNode92BList)
                    {
                        if (xNode.FirstChild != null)
                        {
                            if (xNode.FirstChild.InnerText.CompareTo(qualifierValue92B) == 0)
                            {
                                is92BPresent = true;
                                break;
                            }
                        }
                    }

                    if (is19BPresent && (!is92BPresent))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                        isValid = false;
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }




        /// <method>
        ///		SWIFTNetworkRule222
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 222.
        ///		If the message is new (:23G::NEWM) and if in sequence A field :25D::PROC the code ENTL is present, 
        ///		then sequence D Corporate Action Details is mandatory and in sequence D field :22F::ADDB is mandatory and 
        ///		one occurrence of :22F::ADDB must contain the code CAPA (Error code(s): E22).        
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath23G" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathField" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathSequence1" type = "string">
        ///		Input reference of the Sequence to be validated.
        /// </param>
        /// <param name ="xPathSequence2" type = "string">
        ///		Input reference of the Sequence to be validated.
        /// </param>
        /// <param name ="qualifierValue23G" type = "string">
        ///		Input containing the qualifier value of tag 23G.
        /// </param>
        /// <param name ="qualifierValue22F" type = "string">
        ///		Input containing the qualifier value of tag 22F.
        /// </param>
        /// <param name ="xPathCode" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule222(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath23G,
            string xPath25D,
            string xPath22F,
            string xPathField,
            string xPathSequence1,
            string xPathSequence2,
            string qualifierValue23G,
            string qualifierValue25D,
            string qualifierValue22F,
            string xPathCode25D,
            string xPathCode22F,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule222" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;

            try
            {
                if (xDocument == null ||
                    xPath23G == null ||
                    xPath23G.Length == 0 ||
                    xPath25D == null ||
                    xPath25D.Length == 0 ||
                    xPath22F == null ||
                    xPath22F.Length == 0 ||
                    xPathField == null ||
                    xPathField.Length == 0 ||
                    xPathSequence1 == null ||
                    xPathSequence1.Length == 0 ||
                    xPathSequence2 == null ||
                    xPathSequence2.Length == 0 ||
                    qualifierValue23G == null ||
                    qualifierValue25D == null ||
                    qualifierValue22F == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                bool is23GPresent = false;
                bool is25DPresent = false;
                bool is22FPresent = false;
                bool is25DdatasourcePresent = true;
                bool is22FdatasourcePresent = true;

                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence1);

                if (xListSequence != null)
                {
                    foreach (XmlNode xNodeSequence in xListSequence)
                    {

                        XmlNode xNode = xNodeSequence.SelectSingleNode(xPath23G);

                        //Check 23G::NEWM field present or not
                        if (xNode != null && xNode.FirstChild != null)
                        {
                            if (xNode.FirstChild.InnerText.CompareTo(qualifierValue23G) == 0)
                            {
                                is23GPresent = true;
                            }
                        }

                        xNode = xNodeSequence.SelectSingleNode(xPath25D);




                        //Check :25D::PROC//ENTL field present or not
                        if (xNode != null && xNode.FirstChild != null && xNode.LastChild != null)
                        {
                            if (xNode.FirstChild.InnerText.CompareTo(qualifierValue25D) == 0 && xNode.LastChild.InnerText.CompareTo(xPathCode25D) == 0)
                            {
                                is25DPresent = true;

                                //check if the node has an DataSourceScheme tag
                                XmlNode xNodeField = xNode.SelectSingleNode(xPathField);

                                if (xNodeField == null || xNodeField.InnerText == "")
                                {
                                    is25DdatasourcePresent = false;
                                }
                            }
                        }

                    }
                }


                xListSequence = xRoot.SelectNodes(xPathSequence2);

                if (xListSequence != null)
                {

                    foreach (XmlNode xNodeSequence in xListSequence)
                    {
                        XmlNodeList xNode22FList = xNodeSequence.SelectNodes(xPath22F);

                        foreach (XmlNode xNode in xNode22FList)
                        {
                            if (xNode.FirstChild != null && xNode.LastChild != null)
                            {

                                //Check :22F::ADDB//CAPA field present or not
                                if (xNode.FirstChild.InnerText.CompareTo(qualifierValue22F) == 0 && xNode.LastChild.InnerText.CompareTo(xPathCode22F) == 0)
                                {
                                    is22FPresent = true;

                                    //check if the node has an DataSourceScheme tag
                                    XmlNode xNodeField = xNode.SelectSingleNode(xPathField);

                                    if (xNodeField == null || xNodeField.InnerText == "")
                                    {
                                        is22FdatasourcePresent = false;
                                    }
                                    break;
                                }
                            }
                        }

                    }
                }

                // if the Data Source Scheme is present in field :25D::PROC or :22F::ADDB then the conditional rule does not apply.
                if (!((is25DPresent && is25DdatasourcePresent) || (is22FPresent && is22FdatasourcePresent)))
                {
                    if (is23GPresent)
                    {
                        if (is25DPresent ^ is22FPresent)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            isValid = false;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule209
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 209.
        ///		If the message is a replacement (:23G::REPL), then in sequence A field :25D::PROC, the code ENTL is not allowed and 
        ///		in sequence D field :22F::ADDB, the code CAPA is not allowed. If the message is an eligible balance notification (:23G::REPE), then in sequence A field :25D::PROC, 
        ///		the code ENTL is not allowed and in sequence D field :22F::ADDB, the code CAPA is optional (Error code(s): E09).     
        ///		Note: if the Data Source Scheme is present in field :25D::PROC or :22F::ADDB then the conditional rule does not apply.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath23G" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath22F" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathField" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathSequence1" type = "string">
        ///		Input reference of the Sequence to be validated.
        /// </param>
        /// <param name ="xPathSequence2" type = "string">
        ///		Input reference of the Sequence to be validated.
        /// </param>
        /// <param name ="qualifierValue23G" type = "string">
        ///		Input containing the qualifier value of tag 23G.
        /// </param>
        /// <param name ="qualifierValue22F" type = "string">
        ///		Input containing the qualifier value of tag 22F.
        /// </param>
        /// <param name ="xPathCode" type = "string">
        ///		Input reference of the field element to be validated.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule209(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath23G,
            string xPath25D,
            string xPath22F,
            string xPathField,
            string xPathSequence1,
            string xPathSequence2,
            string qualifierValue23G1,
            string qualifierValue23G2,
            string qualifierValue25D,
            string qualifierValue22F,
            string xPathCode25D,
            string xPathCode22F,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule209" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;

            try
            {
                if (xDocument == null ||
                    xPath23G == null ||
                    xPath23G.Length == 0 ||
                    xPath25D == null ||
                    xPath25D.Length == 0 ||
                    xPath22F == null ||
                    xPath22F.Length == 0 ||
                    xPathField == null ||
                    xPathField.Length == 0 ||
                    xPathSequence1 == null ||
                    xPathSequence1.Length == 0 ||
                    xPathSequence2 == null ||
                    xPathSequence2.Length == 0 ||
                    qualifierValue23G1 == null ||
                    qualifierValue23G2 == null ||
                    qualifierValue25D == null ||
                    qualifierValue22F == null ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                bool is23GPresent1 = false;
                bool is23GPresent2 = false;
                bool is25DPresent = false;
                bool is22FPresent = false;


                XmlNode xRoot = xDocument.Document;

                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence1);

                if (xListSequence != null)
                {
                    foreach (XmlNode xNodeSequence in xListSequence)
                    {

                        XmlNode xNode = xNodeSequence.SelectSingleNode(xPath23G);


                        //Check 23G::REPL or REPE field present or not.
                        if (xNode != null && xNode.FirstChild != null)
                        {
                            if (xNode.FirstChild.InnerText.CompareTo(qualifierValue23G1) == 0)
                            {
                                is23GPresent1 = true;
                            }
                            else
                                if (xNode.FirstChild.InnerText.CompareTo(qualifierValue23G2) == 0)
                                {
                                    is23GPresent2 = true;
                                }
                        }

                        xNode = xNodeSequence.SelectSingleNode(xPath25D);

                        //check if the node has an DataSourceScheme tag
                        XmlNode xNodeField = xNode.SelectSingleNode(xPathField);


                        //Check :25D::PROC//ENTL field present or not
                        if (xNode != null && xNode.FirstChild != null && xNode.LastChild != null && (xNodeField == null || xNodeField.InnerText == ""))
                        {
                            if (xNode.FirstChild.InnerText.CompareTo(qualifierValue25D) == 0 &&
                                xNode.LastChild.InnerText.CompareTo(xPathCode25D) == 0)
                            {
                                is25DPresent = true;
                            }
                        }
                    }

                }


                xListSequence = xRoot.SelectNodes(xPathSequence2);

                if (xListSequence != null)
                {

                    foreach (XmlNode xNodeSequence in xListSequence)
                    {
                        XmlNodeList xNode22FList = xNodeSequence.SelectNodes(xPath22F);

                        foreach (XmlNode xNode in xNode22FList)
                        {
                            if (xNode != null)
                            {

                                if (xNode.FirstChild != null && xNode.LastChild != null)
                                {
                                    //check if the node has an DataSourceScheme tag
                                    XmlNode xNodeField = xNode.SelectSingleNode(xPathField);

                                    //Check :22F::ADDB//CAPA field present or not
                                    if (xNode.FirstChild.InnerText.CompareTo(qualifierValue22F) == 0 && xNode.LastChild.InnerText.CompareTo(xPathCode22F) == 0
                                        && (xNodeField == null || xNodeField.InnerText == ""))
                                    {
                                        is22FPresent = true;
                                        break;
                                    }
                                }
                            }
                        }

                    }
                }




                if (((is23GPresent1 || is23GPresent2) && is25DPresent) || (is23GPresent1 && is22FPresent))
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule275
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 275. In sequence B, if Original Ordered Quantity (field :36B::ORDR) is present more than once then Buy/Sell Indicator (field :22H::BUSE) must be present with Indicator code FPOO or IPOO or IPPO.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPath22HQualifier" type = "string">
        ///		Input reference of the Element 22H in Sequence B.
        /// </param>
        /// <param name ="xPath22HIndicator" type = "string">
        ///		Input reference of the Element 22H in Sequence B.
        /// </param>
        /// <param name ="xPath36Bor90aor19Alist" type = "string">
        ///		Input reference of the Element 36B or 19A or 90a in Sequence B.
        /// </param>
        /// <param name ="qualifier22H" type = "string">
        ///		Reference containing the list of the qualifiers for xPath22HQualifier.
        /// </param>
        /// <param name ="indicatorList22H" type = "string">
        ///		Reference containing the list of the indicators for xPath22HIndicator.
        /// </param>
        /// <param name ="qualifier36Bor90aor19Alist" type = "string">
        ///		Reference containing the qualifier for xPath36Bor90aor19Alist.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Input containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule275(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath22HQualifier,
            string xPath22HIndicator,
            string xPath36Bor90aor19Alist,
            string qualifier22H,
            string indicatorList22H,
            string qualifier36Bor90aor19Alist,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule275" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            bool blnIndicatorPresent = true;
            try
            {
                if (xDocument == null ||
                   xPath36Bor90aor19Alist == null ||
                   xPath22HQualifier == null ||
                   xPath22HIndicator == null ||
                   qualifier36Bor90aor19Alist.Length == 0 ||
                   xPath22HQualifier.Length == 0 ||
                   xPath22HIndicator.Length == 0 ||
                   errorCode == null ||
                   errorCode.Length == 0)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                string[] xPathQualifiers = xPath36Bor90aor19Alist.Split(Constants.CHRCOMMA);
                string[] Qualifiers = qualifier36Bor90aor19Alist.Split(Constants.CHRCOMMA);

                for (int index = 0; index < xPathQualifiers.Length; index++)
                {
                    string xPathQuery = "";
                    string[] field36BOptions = xPathQualifiers[index].Split(Constants.CHRPIPE);
                    for (int index1 = 0; index1 < field36BOptions.Length; index1++)
                    {
                        if (index1 != 0)
                        {
                            xPathQuery = xPathQuery + Constants.CHRPIPE;
                        }
                        xPathQuery = xPathQuery + field36BOptions[index1] + " [contains(., '" + Qualifiers[index] + "')]";
                    }
                    XmlNodeList xList36B = xRoot.SelectNodes(xPathQuery);
                    if (xList36B.Count > 1)
                    {
                        blnIndicatorPresent = false;
                        XmlNodeList xList22H = xRoot.SelectNodes(xPath22HQualifier + "[contains(., '" + qualifier22H + "')]");
                        if (xList22H.Count > 0)
                        {
                            string formattedXPath22HIdentifier = "[contains(., '" + indicatorList22H.Replace(Constants.COMMA, "') or contains(., '") + "')]";
                            foreach (XmlNode xNode22H in xList22H)
                            {
                                if (xNode22H.SelectNodes(xPath22HIndicator + formattedXPath22HIdentifier).Count > 0)
                                {
                                    blnIndicatorPresent = true;
                                    index = xPathQualifiers.Length;
                                    break;
                                }
                            }
                        }
                    }
                }


                if (!blnIndicatorPresent)
                {
                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                    isValid = false;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	SwiftNetworkRule59_2011
        /// </method>
        /// <summary>
        /// In sequence A, if field 77D is present and the first six characters of the second line are equal to /SETC/, 
        /// then the first six (6) characters of the first line must contain /VALD/ and /SETC/ must be followed by a valid ISO 4217 currency code 
        /// and the end of line code, ie CrLf (Error code(s): C59)
        /// </summary>
        /// <param name="xDocument">
        /// 	XmlDocument
        /// </param>
        /// <param name="xPathTag">
        /// 	xPathTag of field 
        /// </param>
        /// <param name="errorCode">
        /// 	error code C59
        /// </param>
        /// <param name="policyName">
        /// 	Policy Name
        /// </param>
        /// <param name="ruleName">
        /// 	Rule name
        /// </param>
        /// <param name="ruleName">
        /// 	MessageType
        /// </param>
        /// <param name="errorObject">
        /// 	error object
        /// </param>
        /// <returns>
        /// 	returns true if validation succeeds,
        /// 	else returns false.
        /// </returns>
        public static bool SwiftNetworkRule59_2011(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SwiftNetworkRule59_2011" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                String currency = String.Empty;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList nodeList = xRoot.SelectNodes(xPathTag);


                foreach (XmlNode node in nodeList)
                {
                    XmlNode xNodeLine1 = node.ChildNodes[0];
                    XmlNode xNodeLine2 = node.ChildNodes[1];
                    XmlNode xNodeLine3 = node.ChildNodes[2];

                    //Check if /SRCE/ if present other than line 3
                    if (!IsAtValidLine(node, Constants.CODESRCE, 3))
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, node.Name, Constants.BLANK);
                        return isValid = false;
                    }

                    if (node.InnerText != null && node.InnerText.Length != 0)
                    {
                        #region // Check if line2 of field 72 present and starts with code /SETC/ or not.
                        if (xNodeLine2 != null && xNodeLine2.InnerText.StartsWith(Constants.CODESETC))
                        {
                            //Check if /SETC/ if present other than line 2 or other than first charecters
                            if (xNodeLine2.InnerText.IndexOf(Constants.CODESETC) > 0
                                || !IsAtValidLine(node, Constants.CODESETC, 2))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNodeLine2.ParentNode.Name, xNodeLine2.InnerText);
                                return isValid = false;
                            }

                            //check length of second line is equel to 9 or not.
                            if (xNodeLine2.InnerText.Length != 9)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                        xNodeLine2.ParentNode.Name, xNodeLine2.InnerText);
                                return isValid = false;
                            }
                            else
                            {
                                //check whether Currency used is valid ISO 4217 currency.
                                currency = xNodeLine2.InnerText.Substring(6);
                                if (!SqlConnector.hashCurrencyCodeList.ContainsKey(currency))
                                {

                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        "CurrencyCode", currency);
                                    return isValid = false;

                                }
                            }
                            //Check  is /VALD/ present in Line 1 or not.
                            if (xNodeLine1 == null || !xNodeLine1.InnerText.StartsWith(Constants.CODEVALD))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                            "CurrencyCode", currency);
                                return isValid = false;
                            }
                        }
                        #endregion

                        #region //the second line must be present with SETC when code VALD present in MT305
                        if (messageType != null && messageType == "MT305" && xNodeLine2 == null
                                && xNodeLine1.InnerText.StartsWith(Constants.CODEVALD))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                        "CurrencyCode", currency);
                            return isValid = false;
                        }
                        #endregion

                        #region //Adding error when line2 is not /SETC/ while Line 3 is /SRCE/
                        if (xNodeLine3 != null)
                        {
                            if ((xNodeLine3.InnerText.StartsWith(Constants.CODESRCE) || (xNodeLine3.InnerText.IndexOf(Constants.CODESRCE) > 0)))
                            {
                                if (!xNodeLine2.InnerText.StartsWith(Constants.CODESETC))
                                {
                                    //Adding error when line2 is not /SETC/ while Line 3 is not /SRCE/
                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        xNodeLine3.ParentNode.Name, xNodeLine3.InnerText);
                                    isValid = false;
                                }
                            }
                        }
                        #endregion
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	SwiftNetworkRule59_2015
        /// </method>
        /// <summary>
        /// In sequence A, if field 77D is present and the first six characters of the second line are equal to /SETC/, 
        /// then the first six (6) characters of the first line must contain /VALD/ and /SETC/ must be followed by a valid ISO 4217 currency code 
        /// and the end of line code, ie CrLf (Error code(s): C59)
        /// 
        ///  Following conditions are removed -
        ///  
        ///if the first six characters of the third line are /SRCE/, then the first six characters of the second line must be /SETC/(Error code(s): C59). 
        ///the code /SRCE/ is not allowed in any other place than the first six characters of the third line (Error code(s): C59).
        /// </summary>
        /// <param name="xDocument">
        /// 	XmlDocument
        /// </param>
        /// <param name="xPathTag">
        /// 	xPathTag of field 
        /// </param>
        /// <param name="errorCode">
        /// 	error code C59
        /// </param>
        /// <param name="policyName">
        /// 	Policy Name
        /// </param>
        /// <param name="ruleName">
        /// 	Rule name
        /// </param>
        /// <param name="ruleName">
        /// 	MessageType
        /// </param>
        /// <param name="errorObject">
        /// 	error object
        /// </param>
        /// <returns>
        /// 	returns true if validation succeeds,
        /// 	else returns false.
        /// </returns>
        public static bool SwiftNetworkRule59_2015(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathTag,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SwiftNetworkRule59_2015" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathTag == null ||
                    xPathTag.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                String currency = String.Empty;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList nodeList = xRoot.SelectNodes(xPathTag);


                foreach (XmlNode node in nodeList)
                {
                    if (node.InnerText != null && node.InnerText.Length != 0)
                    {
                        XmlNode xNodeLine1 = node.ChildNodes[0];
                        XmlNode xNodeLine2 = node.ChildNodes[1];

                        #region // Check if line2 of field 72 present and starts with code /SETC/ or not
                        if (xNodeLine2 != null && xNodeLine2.InnerText.StartsWith(Constants.CODESETC))
                        {
                            //check length of second line is equel to 9 or not.
                            if (xNodeLine2.InnerText.Length != 9)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                        xNodeLine2.ParentNode.Name, xNodeLine2.InnerText);
                                return isValid = false;
                            }
                            else
                            {
                                //check whether Currency used is valid ISO 4217 currency.
                                currency = xNodeLine2.InnerText.Substring(6);
                                if (!SqlConnector.hashCurrencyCodeList.ContainsKey(currency))
                                {

                                    errorObject.AddError(errorCode, policyName, ruleName,
                                        "CurrencyCode", currency);
                                    return isValid = false;

                                }
                            }
                            //Check  is /VALD/ present in Line 1 or not.
                            if (xNodeLine1 == null || !xNodeLine1.InnerText.StartsWith(Constants.CODEVALD))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                        xNodeLine1.ParentNode.Name, xNodeLine1.InnerText);
                                return isValid = false;
                            }
                        }
                        else
                        {
                            //Check if /SETC/ if present other than line 2 or other than first charecters
                            if ((xNodeLine2 != null && xNodeLine2.InnerText.IndexOf(Constants.CODESETC) > 0)
                                || !IsAtValidLine(node, Constants.CODESETC, 2))
                            {
                                errorObject.AddError(errorCode, policyName, ruleName,
                                    xNodeLine2.ParentNode.Name, xNodeLine2.InnerText);
                                return isValid = false;
                            }
                        }
                        #endregion

                        #region //the second line must be present with SETC when code VALD present in MT305
                        if (messageType != null && (xNodeLine2 == null || !(xNodeLine2.InnerText.StartsWith(Constants.CODESETC)))
                                && xNodeLine1.InnerText.StartsWith(Constants.CODEVALD))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName,
                                        xNodeLine2.ParentNode.Name, xNodeLine2.InnerText);
                            return isValid = false;
                        }
                        #endregion
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        /// 	CheckCurrencyAmount_2011
        /// </method>
        /// <summary>
        /// 	This function performs the amount and currency validation depending the bool values set.
        /// </summary>
        /// <param name="currency">
        ///		Contains the currency value to be validated
        /// </param>
        /// <param name="amount">
        ///		Contains the Amount value to be validated
        /// </param>
        /// <param name="currencyAmountList">
        ///		Contains the currency list and corresponding decimal places.
        /// </param>
        /// <param name="allowLeadingZero">
        ///		if set to false this function will perform leadingzero validation.
        /// </param>
        /// <param name="isCurrencyValidationRequired">
        ///		if set to true this function will perform currency code validation.
        /// </param>
        /// <param name="isCurrencyAmountValidationRequired">
        ///		if set to true this function will perform Amounts decimal place validation
        ///		with corresponding currency.
        /// </param>
        /// <param name="errorCode">
        ///		errorCode
        /// </param>
        /// <param name="elementCurrencyName">
        ///		Currency element name
        /// </param>
        /// <param name="elementAmountName">
        ///		Amount element name
        /// </param>
        /// <param name="ruleName">
        ///		rule name
        /// </param>
        /// <param name="policyName">
        ///		policy name
        /// </param>
        /// <param name="errorObj">
        ///		errorObject
        /// </param>
        /// <returns>
        /// 	bool
        /// </returns>
        public static bool CheckCurrencyAmount_2011(string currency,
            string amount,
            bool allowLeadingZero,
            bool isCurrencyValidationRequired,
            bool isCurrencyAmountValidationRequired,
            string errorCode,
            string elementCurrencyName,
            string elementAmountName,
            string ruleName,
            string policyName,
            ErrorCollection errorObj)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckCurrencyAmount_2011" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (currency == null ||
                    currency.Length == 0 ||
                    amount == null ||
                    amount.Length == 0 ||
                    currency.Length == 0)
                {
                    return false;
                }

                if (null == errorCode) throw new ArgumentNullException("ErrorCode");
                if (null == errorObj) throw new ArgumentNullException("errorObj");


                //Split the errorCodes passed
                string[] errorCodeList = errorCode.Split(Constants.CHRCOMMA);
                int errorCodeCount = errorCodeList.Length;


                //default (true) does not check leading zero
                if (!allowLeadingZero)
                {
                    //Checks for leading zeros if checkLeadingZero bool is set to false
                    if (!CheckLeadingZero(amount))
                    {
                        if (errorCodeCount == Constants.INT3)
                        {
                            errorObj.AddError(errorCodeList[1], policyName, ruleName, elementAmountName, amount);
                            return false;
                        }
                        else
                        {
                            errorObj.AddError(Constants.ERRORT40, policyName, ruleName, elementAmountName, amount);
                            return false;
                        }
                        //isValid = false;
                    }
                }

                if (!SqlConnector.hashCurrencyCodeList.ContainsKey(currency))
                {
                    isValid = false;
                    isCurrencyAmountValidationRequired = false;
                    errorObj.AddError(Constants.ERRORT52, policyName, ruleName, elementCurrencyName, currency);
                }

                if (isCurrencyAmountValidationRequired)
                {
                    //Extracts the decimal places value for a currency code from the
                    //hash table.
                    string decimalplaces = (String)SqlConnector.hashCurrencyCodeList[currency];

                    //Extracts the decimal digits after dot fron the amount present in string.
                    string[] amountData = amount.Split(Constants.CHRCOMMA);


                    //Checks for the validity of amount
                    if (amountData.Length >= 2)
                    {
                        if (Convert.ToInt32(decimalplaces, CultureInfo.InvariantCulture) != -1 &&
                            amountData.Length > 1 && amountData[1].Length > Convert.ToInt32(decimalplaces, CultureInfo.InvariantCulture))
                        {
                            isValid = false;
                        }
                    }
                    else
                    {
                        errorObj.AddError(errorCodeList[2], policyName, ruleName, elementAmountName, amount);
                        //isValid = false;
                        return false;
                    }
                }

                //Checks if the currency is present in the currency list provided
                if ((isCurrencyValidationRequired || isCurrencyAmountValidationRequired)
                    && !SqlConnector.hashCurrencyCodeList.Contains(currency))
                {
                    //errorObj.AddError(Constants.ERRORT52,policyName,ruleName,elementCurrencyName,currency);
                    isValid = false;
                    isCurrencyAmountValidationRequired = false;
                }

                if (isCurrencyAmountValidationRequired)
                {
                    //Extracts the decimal places value for a currency code from the
                    //hash table.                   
                    string decimalplaces = (String)SqlConnector.hashCurrencyCodeList[currency];

                    //Extracts the decimal places after comma fron the amount present in tag.
                    string[] amountData = amount.Split(Constants.CHRCOMMA);

                    //Checks for the validity of amount
                    if (amountData.Length >= 2)
                    {
                        if (Convert.ToInt32(decimalplaces, CultureInfo.InvariantCulture) != -1 &&
                            amountData.Length > 1 && amountData[1].Length > Convert.ToInt32(decimalplaces, CultureInfo.InvariantCulture))
                        {
                            errorObj.AddError(errorCodeList[0], policyName, ruleName, elementAmountName, amount);
                            isValid = false;
                        }
                    }
                    else
                    {
                        errorObj.AddError(errorCodeList[2], policyName, ruleName, elementAmountName, amount);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }


            return isValid;
        }

        /// <method>
        ///		CheckSingleMandatoryQualifier_Repetitive
        /// </method>
        /// <summary>
        ///		This method performs validation for fields with	multiple qualifiers to check
        ///		for a single mandatory qualifiers with Repetitive Option.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Comma separated input references of the elements to be validated.
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the list of the qualifiers.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckSingleMandatoryQualifier_Repetitive(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPath,
            string qualifierList,
            string errorCode,
            string policyName,
            string ruleName,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckSingleMandatoryQualifier" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                int countQualifier = 0;

                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                if (null == qualifierList) throw new ArgumentNullException("qualifierList");

                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    string QualifierName = "";
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        countQualifier = 0;
                        for (int i = 0; i <= xPathArray.Length - 1; i++)
                        {
                            XmlNodeList xNodeList = xNodeSequence.SelectNodes(xPathArray[i]);
                            foreach (XmlNode xNode in xNodeList)
                            {

                                if (qualifierList.IndexOf(xNode.InnerText) != -1 && QualifierName.Length == 0)
                                {
                                    countQualifier++;
                                    QualifierName = xNode.InnerText;
                                }
                                else if (qualifierList.IndexOf(xNode.InnerText) != -1 && string.Compare(QualifierName, xNode.InnerText, true) != 0)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, Constants.QUALIFIER, qualifierList);
                                    isValid = false;
                                }

                            }
                        }
                        if (countQualifier != 1)
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, Constants.QUALIFIER, qualifierList);
                            isValid = false;
                        }
                    }
                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName, xNodeSequence.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule289_SRG2012
        /// </method>
        /// <summary>       
        ///	In sequence B Netting Position Details, if field :22H::RECP indicator is PAYO or RECE, then subsequence B1 Cash Parties must be present twice, once with field :95a::ACCW and once with field :95a::BENM.                  
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        ///		Input reference of the element Sequence
        ///		e.g. //SequenceB
        /// </param>
        /// <param name="xPathSubSequence">
        ///		Input reference of the element Sub Sequence
        ///		e.g. ./SequenceB1
        /// </param>
        /// <param name ="xPath22H" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPath95List" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name="xPathQualifier">
        /// Input xPath of Qualifier
        /// </param>
        /// <param name ="conditionalTagQualifierValue" type = "string">
        ///		Input containing the qualifier RECP.
        /// </param>
        /// <param name ="conditionalTagIndicatorValue" type = "string">
        ///		Input containing the value PAYO.
        /// </param>
        /// <param name ="qualifier ACCW,BENM" type = "string">
        ///		Input containing the qualifier ACCW,BENM.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule289_SRG2012(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPath22H,
            string xPath95List,
            string xPathQualifier,
            string conditionalTagQualifierValue,
            string conditionalTagIndicatorValue,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule289_SRG2012" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    xPath22H == null ||
                    xPath22H.Length == 0 ||
                    xPath95List == null ||
                    xPath95List.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select the Sequence(SequenceB)
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                if (xListSequence != null && xListSequence.Count != 0)
                {
                    foreach (XmlNode xNodeSequence in xListSequence)
                    {
                        string xPathCondTag = xPath22H + Constants.OPENSQUAREBRACKET + Constants.QUALIFIER + Constants.EQUAL + Constants.SINGLEQUOTE + conditionalTagQualifierValue + Constants.SINGLEQUOTE + Constants.SPACE + Constants.AND + Constants.SPACE + Constants.INDICATOR + Constants.EQUAL + Constants.SINGLEQUOTE + conditionalTagIndicatorValue + "' and not(descendant::" + Constants.DATASOURCESCHEME + ")]";
                        XmlNodeList xNodeList22H = xRoot.SelectNodes(xPathCondTag);

                        if (xNodeList22H != null && xNodeList22H.Count != 0)
                        {

                            string[] codeListArray = codeList.Split(Constants.COMMA.ToCharArray());
                            string[] xPath95aList = xPath95List.Split(Constants.CHRCOMMA);

                            XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);

                            if (xListSubSequence != null && xListSubSequence.Count != 0 && xListSubSequence.Count >= 2)
                            {
                                bool isACCWpresent = false;
                                bool isBENMpresent = false;

                                foreach (XmlNode xNodeSubSequence in xListSubSequence)
                                {
                                    foreach (string xPath in xPath95aList)
                                    {

                                        XmlNodeList xNode95aList = xNodeSubSequence.SelectNodes(xPath);

                                        foreach (XmlNode xNode95a in xNode95aList)
                                        {
                                            if (xNode95a != null && xNode95a.InnerText.Length != 0)
                                            {
                                                XmlNode xNodeQualifier95a = xNode95a.SelectSingleNode(xPathQualifier);
                                                if (xNodeQualifier95a != null && xNodeQualifier95a.InnerText.Length != 0)
                                                {
                                                    if (xNodeQualifier95a.InnerText == codeListArray[0].ToString())
                                                    {
                                                        isACCWpresent = true;
                                                    }
                                                    else
                                                        if (xNodeQualifier95a.InnerText == codeListArray[1].ToString())
                                                        {
                                                            isBENMpresent = true;
                                                        }
                                                }

                                            }
                                        }
                                    }
                                }

                                //check ACCW and BENM both are present or not.
                                if ((!isACCWpresent) || (!isBENMpresent))
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    return isValid = false;
                                }
                            }
                            else
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                return isValid = false;
                            }
                        }
                    }
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule289_SRG2012
        /// </method>
        /// <summary>       
        ///	In sequence B Netting Position Details, if field :22H::RECP indicator is NOPA, then subsequence B1 Cash Parties must not be present (Error code(s): E89).         
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// <param name="xPathSequence">
        ///		Input reference of the element Sequence
        ///		e.g. //SequenceB
        /// </param>
        /// <param name="xPathSubSequence">
        ///		Input reference of the element Sub Sequence
        ///		e.g. ./SequenceB1
        /// </param>
        /// </param>
        /// <param name ="xPath22H" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="conditionalTagQualifierValue" type = "string">
        ///		Input containing the qualifier RECP.
        /// </param>
        /// <param name ="conditionalTagIndicatorValue" type = "string">
        ///		Input containing the value NOPA.
        /// </param>       
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule289_SRG2012(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPath22H,
            string conditionalTagQualifierValue,
            string conditionalTagIndicatorValue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule289_SRG2012" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence == null ||
                    xPathSubSequence.Length == 0 ||
                    xPath22H == null ||
                    xPath22H.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select the Sequence(SequenceB)
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                if (xListSequence != null && xListSequence.Count != 0)
                {
                    foreach (XmlNode xNodeSequence in xListSequence)
                    {
                        string xPathCondTag = xPath22H + Constants.OPENSQUAREBRACKET + Constants.QUALIFIER + Constants.EQUAL + Constants.SINGLEQUOTE + conditionalTagQualifierValue + Constants.SINGLEQUOTE + Constants.SPACE + Constants.AND + Constants.SPACE + Constants.INDICATOR + Constants.EQUAL + Constants.SINGLEQUOTE + conditionalTagIndicatorValue + "' and not(descendant::" + Constants.DATASOURCESCHEME + ")]";
                        XmlNodeList xNodeList22H = xRoot.SelectNodes(xPathCondTag);

                        if (xNodeList22H != null && xNodeList22H.Count != 0)
                        {

                            XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);

                            //check if Sequence b1 is present.
                            if (xListSubSequence != null && xListSubSequence.Count != 0)
                            {
                                errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                return isValid = false;

                            }
                        }
                    }
                }

            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule263
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 263 In subsequence D, if field :95a::EXCH is present, then field :97a is not allowed in the same sequence.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="xPath95a" type = "string">
        ///		Comma separated input references of the elements to be validated.
        /// </param>
        /// <param name ="xPath97a" type = "string">
        ///		Comma separated input references of the elements to be validated.
        /// </param>
        /// <param name ="qualifierList" type = "string">
        ///		Reference containing the list of the qualifiers for xPath1.
        /// </param>       
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule263(Microsoft.RuleEngine.TypedXmlDocument xDocument,
          string xPathSequence,
          string xPath95a,
          string xPath97a,
          string qualifierList,
          string errorCode,
          string policyName,
          string ruleName,
          string messageType,
          string conditionalRuleName,
          string conditionalRuleNumber,
          ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule263" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int lengthxPath95a = 0;
            int lengthxPath97a = 0;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath95a == null ||
                    xPath97a == null ||
                    xPath95a.Length == 0 ||
                    xPath97a.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                string[] xPathArray95a = xPath95a.Split(Constants.CHRCOMMA);
                lengthxPath95a = xPathArray95a.Length;

                string[] xPathArray97a = xPath97a.Split(Constants.CHRCOMMA);
                lengthxPath97a = xPathArray97a.Length;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        for (int nCount1 = 0; nCount1 <= lengthxPath95a - 1; nCount1++)
                        {
                            XmlNodeList xList1 = xNodeSequence.SelectNodes(xPathArray95a[nCount1].ToString());
                            foreach (XmlNode xNode1 in xList1)
                            {
                                if (xNode1.InnerText.ToString().Trim().CompareTo(qualifierList) == 0)
                                {
                                    for (int nCount2 = 0; nCount2 <= lengthxPath97a - 1; nCount2++)
                                    {
                                        XmlNodeList xList2 = xNodeSequence.SelectNodes(xPathArray97a[nCount2].ToString());

                                        if (xList2 != null && xList2.Count != 0)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isValid = false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule107_SRG2012
        /// </method>    
        /// <param name ="xPath26C" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="xPathUnitFeildsList" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name="Qualifier26C">
        /// Input containing the qualifier GOLD.
        /// </param>
        /// <param name ="codeList" type = "string">
        ///		Input containing the Codes TOZ,GOZ.
        /// </param>       
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule107_SRG2012(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPath26C,
            string xPathUnitFeildsList,
            string Qualifier26C,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule107_SRG2012" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPath26C == null ||
                    xPath26C.Length == 0 ||
                    xPathUnitFeildsList == null ||
                    xPathUnitFeildsList.Length == 0 ||
                    Qualifier26C == null ||
                    Qualifier26C.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select the 26C Elements
                XmlNodeList xListSequence = xRoot.SelectNodes(xPath26C);

                if (xListSequence != null && xListSequence.Count != 0)
                {
                    foreach (XmlNode xNodeSequence in xListSequence)
                    {
                        string Type4Value = string.Empty;
                        if (xNodeSequence != null && xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                        {
                            string completeValue = xNodeSequence.InnerText;
                            string[] tempArrayList = completeValue.Split('/');
                            if (tempArrayList.Length >= 2)
                            {
                                Type4Value = tempArrayList[2].Substring(5, 4);
                            }
                            if (Type4Value.CompareTo(Qualifier26C) == 0)
                            {
                                string[] codeListArray = codeList.Split(Constants.COMMA.ToCharArray());
                                string[] xPathUnitFeildList = xPathUnitFeildsList.Split(Constants.CHRCOMMA);

                                foreach (string xPath in xPathUnitFeildList)
                                {
                                    XmlNodeList xNodeUnitFeildList = xRoot.SelectNodes(xPath);

                                    foreach (XmlNode xNodeUnitFeild in xNodeUnitFeildList)
                                    {
                                        if (xNodeUnitFeild != null && xNodeUnitFeild.InnerText.Length != 0)
                                        {
                                            foreach (string code in codeListArray)
                                            {
                                                if (xNodeUnitFeild.InnerText == code)
                                                {
                                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                                    return isValid = false;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule8_SRG2012
        /// </method>
        /// <summary>       
        ///	This method performs validation for currency XAU,XAG,XPD,XPT.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// <param name="xPathSequence">
        ///		Input reference of the element Sequence
        ///		e.g. //SequenceB
        /// </param>
        /// <param name ="xPathAmountField" type = "string">
        ///		Input reference of the element Sequence
        /// </param>
        /// <param name ="xPathCurrency" type = "string">
        ///		Input reference of the element Sequence
        /// </param>
        /// <param name ="codeList" type = "string">
        ///		Input containing the value XAU,XAG,XPD,XPT.
        /// </param>       
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule8_SRG2012(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathAmountField,
            string xPathCurrency,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule8_SRG2012" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathAmountField == null ||
                    xPathAmountField.Length == 0 ||
                    xPathCurrency == null ||
                    xPathCurrency.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);
                if (xListSequence != null && xListSequence.Count != 0)
                {
                    foreach (XmlNode xNodeSequence in xListSequence)
                    {
                        XmlNodeList xNodeAmount = xNodeSequence.SelectNodes(xPathAmountField);
                        if (xNodeAmount != null && xNodeAmount.Count != 0)
                        {
                            foreach (XmlNode xNode in xNodeAmount)
                            {
                                XmlNode xNodeCurrencyCode = xNode.SelectSingleNode(xPathCurrency);
                                if (xNodeCurrencyCode != null && xNodeCurrencyCode.InnerText != null)
                                {
                                    string[] codeListArray = codeList.Split(Constants.CHRCOMMA);
                                    foreach (string code in codeListArray)
                                    {
                                        if (xNodeCurrencyCode.InnerText.ToString().Trim().CompareTo(code) == 0)
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            return isValid = false;

                                        }
                                    }

                                }
                            }
                        }
                    }
                }
            }

            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }
        /// <method>
        ///		SWIFTNetworkRule8
        /// </method>
        /// <summary>       
        ///	This method performs validation for currency XAU,XAG,XPD,XPT.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.      
        /// </param>
        /// <param name ="xPathAmountField" type = "string">
        ///		Input reference of the element Sequence
        /// </param>
        /// <param name ="xPathCurrency" type = "string">
        ///		Input reference of the element Sequence
        /// </param>
        /// <param name ="codeList" type = "string">
        ///		Input containing the value XAU,XAG,XPD,XPT.
        /// </param>       
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule8(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathAmountField,
            string xPathCurrency,
            string codeList,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule8" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {

                if (xDocument == null ||
                    xPathAmountField == null ||
                    xPathAmountField.Length == 0 ||
                    xPathCurrency == null ||
                    xPathCurrency.Length == 0 ||
                    codeList == null ||
                    codeList.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xNodeAmount = xRoot.SelectNodes(xPathAmountField);
                if (xNodeAmount != null && xNodeAmount.Count != 0)
                {
                    foreach (XmlNode xNode in xNodeAmount)
                    {
                        XmlNode xNodeCurrencyCode = xNode.SelectSingleNode(xPathCurrency);

                        if (xNodeCurrencyCode != null && xNodeCurrencyCode.InnerText != null)
                        {
                            string[] codeListArray = codeList.Split(Constants.CHRCOMMA);
                            foreach (string code in codeListArray)
                            {
                                if (xNodeCurrencyCode.InnerText.ToString().Trim().CompareTo(code) == 0)
                                {
                                    errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                    return isValid = false;

                                }
                            }

                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        /// <method>
        ///		SWIFTNetworkRule8_1_SRG2012
        /// </method>
        /// <summary>
        ///		This function performs validation specific to the 'SignCodeAmount' attribute. The validation performed is:-
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name="xPathSequence">
        ///		Input reference of the element Sequence
        ///		e.g. //SequenceB
        /// </param>
        /// <param name ="xPathAmountField" type = "string">
        ///		Input reference of the element Sequence
        /// </param>
        /// <param name ="xPathSignCodeAmount" type = "string">
        ///		Input reference of the element to be validated.
        /// </param>
        /// <param name ="currencyList" type = "string">
        ///		Input containing the list of Currency Codes.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        /// <param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="messageType" type = "string">
        ///		Input containing the Message type.
        /// </param>
        /// <param name ="conditionalRuleName" type = "string">
        ///		Input containing the conditionalRuleName
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        ///		Input containing the conditionalRuleNumber
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule8_1_SRG2012(Microsoft.RuleEngine.TypedXmlDocument xDocument,
             string xPathSequence,
            string xPathAmountField,
            string xPathSignCodeAmount,
            string currencyList,
            string errorCode,
            string policyName,
            string ruleName,
             string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            if (null == currencyList) throw new ArgumentNullException("currencyList");

            bool isValid = true;
            string sign = string.Empty;
            string currencyCode = string.Empty;
            string signCodeAmount = string.Empty;

            if (xDocument == null ||
                xPathSequence == null ||
                xPathSequence.Length == 0 ||
                xPathAmountField == null ||
                xPathAmountField.Length == 0 ||
                xPathSignCodeAmount == null ||
                xPathSignCodeAmount.Length == 0 ||
                errorCode == null ||
                errorCode.Length == 0 ||
                errorObject == null)
            {
                return false;

            }

            XmlNode xRoot = xDocument.Document;
            XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

            if (xListSequence != null && xListSequence.Count != 0)
            {
                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    XmlNodeList xNodeAmount = xNodeSequence.SelectNodes(xPathAmountField);
                    if (xNodeAmount != null && xNodeAmount.Count != 0)
                    {
                        foreach (XmlNode xNode in xNodeAmount)
                        {

                            XmlNode xNodeCurrencyCode = xNode.SelectSingleNode(xPathSignCodeAmount);
                            if (xNodeCurrencyCode != null && xNodeCurrencyCode.InnerText != null)
                            {
                                //Get the value of SignCodeAmount
                                signCodeAmount = xNodeCurrencyCode.InnerText.ToString().Trim();

                                //Select the fourth character of the SignCodeAmount
                                sign = signCodeAmount.Substring(3, 1);

                                //Check if the fourth character is a number or alphabet in order to check whether the Sign is present or not
                                if (sign[0] >= Constants.CHR0 && sign[0] <= Constants.CHR9)
                                {
                                    //Select the first three characters of the SignCodeAmount, if Sign is not present
                                    currencyCode = signCodeAmount.Substring(0, 3);
                                }
                                else
                                {
                                    //Select the second,third and fourth characters of the SignCodeAmount, if Sign is present
                                    currencyCode = signCodeAmount.Substring(1, 3);
                                }
                                string[] codeListArray = currencyList.Split(Constants.CHRCOMMA);
                                foreach (string code in codeListArray)
                                {
                                    if (currencyCode.CompareTo(code) == 0)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        return isValid = false;

                                    }
                                }

                            }
                        }
                    }
                }
            }

            return isValid;
        }


        /// <method>
        ///		SWIFTNetworkRule221
        /// </method>
        /// <summary>
        ///		This method performs validation for Conditional Rule 221 In any occurrence of sequence E, if field :92B::IDFX Issuer Declared Exchange Rate is present, then sequence D must be present and field :92a::DEVI Declared Rate must be present in sequence D. 
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence1" type = "string">
        ///		Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Comma separated input references of the elements to be validated.
        /// </param>
        /// <param name ="qualifierList1" type = "string">
        ///		Reference containing the list of the qualifiers for xPath1.
        /// </param>
        /// <param name ="xPathSequence2" type = "string">
        ///		Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="xPath2" type = "string">
        ///		Comma separated input references of the elements to be validated.
        /// </param>
        /// <param name ="qualifierList2" type = "string">
        ///		Reference containing the list of the qualifiers for xPath2.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool SWIFTNetworkRule221(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence1,
            string xPath1,
            string qualifierList1,
            string xPathSequence2,
            string xPath2,
            string qualifierList2,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule252" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            int lengthxPath1 = 0;
            int lengthxPath2 = 0;
            try
            {
                if (xDocument == null ||
                    xPathSequence1 == null ||
                    xPathSequence1.Length == 0 ||
                    xPathSequence2 == null ||
                    xPathSequence2.Length == 0 ||
                    xPath1 == null ||
                    xPath2 == null ||
                    xPath1.Length == 0 ||
                    xPath2.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                string[] xPathArray1 = xPath1.Split(Constants.CHRCOMMA);
                lengthxPath1 = xPathArray1.Length;

                string[] xPathArray2 = xPath2.Split(Constants.CHRCOMMA);
                lengthxPath2 = xPathArray2.Length;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence1);
                bool isDEVIpresent = false;
                bool isIDFXpresent = false;
                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        for (int nCount1 = 0; nCount1 <= lengthxPath1 - 1; nCount1++)
                        {
                            XmlNodeList xList1 = xNodeSequence.SelectNodes(xPathArray1[nCount1].ToString());
                            foreach (XmlNode xNode1 in xList1)
                            {
                                if (xNode1.InnerText.ToString().Trim().CompareTo(qualifierList1) == 0)
                                {
                                    isIDFXpresent = true;
                                    XmlNodeList xListSequence2 = xRoot.SelectNodes(xPathSequence2);
                                    foreach (XmlNode xNodeSequence2 in xListSequence2)
                                    {
                                        if (xNodeSequence2.InnerText != null && xNodeSequence2.InnerText.Length != 0)
                                        {
                                            for (int nCount2 = 0; nCount2 <= lengthxPath2 - 1; nCount2++)
                                            {
                                                XmlNodeList xList2 = xNodeSequence2.SelectNodes(xPathArray2[nCount2].ToString());
                                                foreach (XmlNode xNode2 in xList2)
                                                {
                                                    if (xNode2.InnerText.ToString().Trim().CompareTo(qualifierList2) == 0)
                                                    {
                                                        isDEVIpresent = true;
                                                        return isValid;
                                                    }
                                                }
                                            }
                                        }
                                        else
                                        {
                                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                            isValid = false;
                                        }
                                    }

                                }
                            }
                        }
                        //check if IDFX present and DEVI isnot present.
                        if ((isIDFXpresent) && (!isDEVIpresent))
                        {
                            errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                            return isValid = false;
                        }

                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }

        #endregion

        #endregion

        #region NETWORKRULE D96
        //Number must equal the number of occurrences of the subsequent field 30M (Error code(s): D96).

        /// <method>
        ///		CheckOccurencesOfField
        /// </method>
        /// <summary>
        ///		This method performs validation for fields to check for number of occurences of 30M field.
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="xPath" type = "string">
        ///		Input reference of the Sequence which contains the element to be validated.
        /// </param>
        /// <param name ="xPath1" type = "string">
        ///		Input reference of the Sequence which contains the element whose count has to be validated.
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>
        public static bool CheckOccurencesOfField(Microsoft.RuleEngine.TypedXmlDocument xDocument,
          string xPathSequence,
          string xPath,
          string xPath1,
          string errorCode,
          string policyName,
          string ruleName,
          ErrorCollection errorObject)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function CheckOccurencesOfField" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);
            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPath == null ||
                    xPath.Length == 0 ||
                    xPath1 == null ||
                    xPath1.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }
                
                string[] xPathArray1 = xPath1.Split(Constants.CHRCOMMA);
                string[] xPathArray = xPath.Split(Constants.CHRCOMMA);

                int lengthxPath = xPathArray.Length;

                XmlNode xRoot = xDocument.Document;
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    if (xNodeSequence.InnerText != null && xNodeSequence.InnerText.Length != 0)
                    {
                        for (int nCount = 0; nCount <= lengthxPath - 1; nCount++)
                        {
                            XmlNodeList xList1 = xNodeSequence.SelectNodes(xPathArray1[nCount].ToString());
                            XmlNodeList xList = xNodeSequence.SelectNodes(xPathArray[nCount].ToString());
                            if (xList.Count != 0)
                            {
                                foreach (XmlNode xn in xList)
                                {
                                    if (Convert.ToInt32(xn.InnerText) != xList1.Count)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, xn.Name, xn.InnerText);
                                        isValid = false;
                                    }
                                }
                            }
                        }
                    }

                    else
                    {
                        errorObject.AddError(errorCode, policyName, ruleName,
                            xNodeSequence.Name, Constants.NOCONTENT);
                        isValid = false;
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

            return isValid;
        }
        #endregion

		/// <summary>
		/// Validate that the code used within each of a set of sub-nodes is not among a code list.
		/// </summary>
		/// <param name="xPathNode">XPath to a node of interest.</param>
		/// <param name="xPathSubNodes">XPath to nodes below the node of interest.</param>
		/// <param name="codeList">A list of code to test against.</param>
		/// <param name="errorCode">e.g., "T49"</param>
		/// <param name="policyName">e.g., "NetworkRuleT49_Policy"</param>
		/// <param name="ruleName">e.g., "Validate_MT300"</param>
		public static bool CheckCodeNotUsed(TypedXmlDocument xDocument,
				string xPathNode,
				string xPathSubNodes,
				string codeList,
				string errorCode, string policyName, string ruleName, ErrorCollection errorObject)
		{
			Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered function CheckCodeNotUsed");
			if (xDocument == null ||
					string.IsNullOrEmpty(xPathNode) ||
					string.IsNullOrEmpty(xPathSubNodes) ||
					string.IsNullOrEmpty(codeList) ||
					string.IsNullOrEmpty(errorCode) ||
					string.IsNullOrEmpty(ruleName) ||
					errorObject == null)
			{
				return false;
			}

			XmlNode parent = xDocument.Document.SelectSingleNode(xPathNode);
			if (parent != null)
			{
				IList<string> codes = codeList.Split(',');
				Regex codeExtractor = new Regex("^/([^/]+)/", RegexOptions.None);

				foreach (XmlNode node in parent.SelectNodes(xPathSubNodes))
				{
					System.Text.RegularExpressions.Match m = codeExtractor.Match(node.InnerText);
					if (m.Success && codes.Contains(m.Groups[1].Value))
					{
						string messageType = ruleName.Split('_').Skip(1).FirstOrDefault();
						string elementName = parent.LocalName;
						errorObject.AddError(errorCode, policyName, ruleName, messageType, null, elementName, null);
						return false;
					}
				}
			}

            return true;
        }
	/// <method>
        /// 	ConvertToInteger
        /// </method>
        /// <summary>
        /// 	This method converts an input string to Int32
        /// 	If the input string is null then it returns 0;
        /// </summary>
        public static Int32 ConvertToInteger(string Number)
        {
            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function ConvertToInteger:");
            try
            {
                if (null == Number) throw new ArgumentNullException("Not valid Number");

                string tempValue = string.Empty;
                Int32 num = 0;

                if (Convert.ToInt32(Number) >= 0)
                {
                    num = Convert.ToInt32(Number);
                    return num;
                }
                else
                {
                    return 0;
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }

        }
		//
         /// <method>
        ///		SWIFTNetworkRule237_SRG2019
        /// </method>
        /// <summary>
        ///		This method performs validation for the Network Rule 237 for each occurrence of Sequence C1a1A2a1A(MT548) or D1a1A2a1A(MT537)
		///  	Check will be performed only if datasource schema is not present in xPath25D.
		///     This method can be used to cover below scenarios
		///     1.	when 24B Qualifier value should be same as 25D Statuscodevalue i.e if 24B:PENF is present then 25D:SETT//PENF should be present
		///     2.  when 24B Qualifier value is different from 25D Statuscodevalue i.e if 24B:PENF is present then 25D:SETT//PEND should be present
        /// </summary>
        /// <param name ="xDocument" type = "Microsoft.RuleEngine.TypedXmlDocument">
        ///		Input containing the xml document to be validated.
        /// </param>
        /// <param name ="xPathSequence" type = "string">
        ///		Input reference of the Sequence C1a1A2a1 (or) D1a1A2a1.
        /// </param>
        /// <param name ="xPathSubSequence" type = "string">
        ///		Input reference of the Sequence C1a1A2a1A (or) D1a1A2a1A.
        /// </param>
        /// <param name ="xPath25D" type = "string">
        ///		Input reference of the element 25D in Sequence C1a1A2a1 (or) D1a1A2a1.
        /// </param>
        /// <param name ="xPath24B" type = "string">
        ///		Input reference of the element 24B in Sequence C1a1A2a1A (or) D1a1A2a1A.
        /// </param>
        /// <param name ="xPathQualifier" type = "string">
        ///		Reference containing the xPath of the Qualifier.
        /// </param>
        /// <param name ="xPathDataSourceScheme" type = "string">
        ///		Reference containing the xPath of the Data Source Scheme.
        /// </param>
        /// <param name ="xPathStatusCode" type = "string">
        ///		Reference containing the xPath of the Status Code.
        /// </param>
		/// <param name ="statusCodevalue" type = "string">
        ///		Input containing the value of the Status Code.
        /// </param>
        /// <param name ="errorCode" type = "string">
        ///		Input containing the error code.
        /// </param>
        ///<param name ="policyName" type = "string">
        ///		Input containing the policy name.
        /// </param>
        /// <param name ="ruleName" type = "string">
        ///		Input containing the rule name.
        /// </param>
        /// <param name="messageType" type = "string">
        /// 	Input containing the Message type.
        /// </param>
        /// <param name="conditionalRuleName" type = "string">
        /// 	Input containing the Conditional Rule Name.
        /// </param>
        /// <param name ="conditionalRuleNumber" type = "string">
        /// 	Intput containing the conditional Rule Number.
        /// </param>
        /// <param name ="errorObject" type = "string">
        ///		Input containing the error object to which the errors will be added.
        /// </param>
        /// <returns type = "boolean">
        ///		True if validation succeeds, False otherwise.
        /// </returns>

       public static bool SWIFTNetworkRule237_SRG2019(Microsoft.RuleEngine.TypedXmlDocument xDocument,
            string xPathSequence,
            string xPathSubSequence,
            string xPath25D,
            string xPath24B,
            string xPathQualifier,
            string xPathDataSourceScheme,
            string xPathStatusCode,
            string statusCodevalue,
            string errorCode,
            string policyName,
            string ruleName,
            string messageType,
            string conditionalRuleName,
            string conditionalRuleNumber,
            ErrorCollection errorObject)
        {

            Trace.Tracer.TraceMessage(TraceLevel.Messages, "Entered Function SWIFTNetworkRule237_SRG2019" + " , " + " Policy Name :" + policyName + " , " + " Rule Name :" + ruleName);

            bool isValid = true;
            try
            {
                if (xDocument == null ||
                    xPathSequence == null ||
                    xPathSubSequence == null ||
                    xPathSequence.Length == 0 ||
                    xPathSubSequence.Length == 0 ||
                    xPath25D == null ||
                    xPath25D.Length == 0 ||
                    xPath24B == null ||
                    xPath24B.Length == 0 ||
                    xPathQualifier == null ||
                    xPathQualifier.Length == 0 ||
                    xPathDataSourceScheme == null ||
                    xPathDataSourceScheme.Length == 0 ||
                    xPathStatusCode == null ||
                    xPathStatusCode.Length == 0 ||
                    errorCode == null ||
                    errorCode.Length == 0 ||
                    errorObject == null)
                {
                    return false;
                }

                XmlNode xRoot = xDocument.Document;

                //Select all the nodes of Sequence C1a1A2a1 (or) D1a1A2a1
                XmlNodeList xListSequence = xRoot.SelectNodes(xPathSequence);

                foreach (XmlNode xNodeSequence in xListSequence)
                {
                    //Select the node of the Tag 25D in Sequence C1a1A2a1 (or) D1a1A2a1
                    XmlNode xNode25D = xNodeSequence.SelectSingleNode(xPath25D);

                    if (xNode25D != null)
                    {
                        //Check for the presence of Data Source Scheme in Tag 25D
                        if (xNode25D.SelectSingleNode(xPathDataSourceScheme) == null)
                        {
                            //Select all the nodes of Sequence C1a1A2a1A (or) D1a1A2a1A
                            XmlNodeList xListSubSequence = xNodeSequence.SelectNodes(xPathSubSequence);

                            foreach (XmlNode xNodeSubSequence in xListSubSequence)
                            {
                                //Select the node of the Tag 24B in Sequence C1a1A2a1A (or) D1a1A2a1A
                                XmlNode xNode24B = xNodeSubSequence.SelectSingleNode(xPath24B);

                                if (xNode24B != null && xNode24B.SelectSingleNode(xPathQualifier) != null && xNode25D.SelectSingleNode(xPathStatusCode) != null)
                                {
                                    //Get the value of the Qualifier of Tag 24B
                                    string xNode24BQualifier = xNode24B.SelectSingleNode(xPathQualifier).InnerText.ToString(CultureInfo.InvariantCulture);
                                    //Get the value of the Status Code of Tag 25D
                                    string xNode25DStatusCode = xNode25D.SelectSingleNode(xPathStatusCode).InnerText.ToString(CultureInfo.InvariantCulture);
									//If the value of Qualifier of Tag 25D is equal to statusCodevalue,return true
                                    if (xNode25DStatusCode.CompareTo(statusCodevalue)==0)
                                    {
                                        isValid=true;
                                    }
                                    //If the value of Qualifier of Tag 24B is not equal to value of Status Code of Tag 25D, throw an error
                                   else  if (xNode24BQualifier.CompareTo(xNode25DStatusCode) != 0)
                                    {
                                        errorObject.AddError(errorCode, policyName, ruleName, messageType, conditionalRuleName, conditionalRuleNumber);
                                        isValid = false;
                                    }
                                    
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Tracer.TraceMessage(TraceLevel.Error, "Error: {0}" + e.StackTrace + "\n" + "Reason :" + e.Message);
                throw;
            }
            return isValid;
        }
    }
}
